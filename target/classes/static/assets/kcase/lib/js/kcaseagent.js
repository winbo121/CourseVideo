var K_OSName = "Windows";

if (typeof JSON !== 'object') {
    JSON = {};
}

(function () {
    'use strict';

    var rx_one = /^[\],:{}\s]*$/,
        rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
        rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
        rx_four = /(?:^|:|,)(?:\s*\[)+/g,
        rx_escapable = /[\\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

    function f(n) {
        return n < 10
            ? '0' + n
            : n;
    }

    function this_value() {
        return this.valueOf();
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function () {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear() + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate()) + 'T' +
                f(this.getUTCHours()) + ':' +
                f(this.getUTCMinutes()) + ':' +
                f(this.getUTCSeconds()) + 'Z'
                : null;
        };

        Boolean.prototype.toJSON = this_value;
        Number.prototype.toJSON = this_value;
        String.prototype.toJSON = this_value;
    }

    var gap,
        indent,
        meta,
        rep;


    function quote(string) {
        rx_escapable.lastIndex = 0;
        return rx_escapable.test(string)
            ? '"' + string.replace(rx_escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string'
                    ? c
                    : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"'
            : '"' + string + '"';
    }

    function str(key, holder) {
        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

        if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

        switch (typeof value) {
            case 'string':
                return quote(value);
            case 'number':
                return isFinite(value) ? String(value) : 'null';
            case 'boolean':
            case 'null':
                return String(value);
            case 'object':
                if (!value) {
                    return 'null';
                }

                gap += indent;
                partial = [];

                if (Object.prototype.toString.apply(value) === '[object Array]') {
                    length = value.length;
                    for (i = 0; i < length; i += 1) {
                        partial[i] = str(i, value) || 'null';
                    }

                    v = partial.length === 0
                        ? '[]'
                        : gap
                            ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                            : '[' + partial.join(',') + ']';
                    gap = mind;
                    return v;
                }

                if (rep && typeof rep === 'object') {
                    length = rep.length;
                    for (i = 0; i < length; i += 1) {
                        if (typeof rep[i] === 'string') {
                            k = rep[i];
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (
                                        gap
                                            ? ': '
                                            : ':'
                                    ) + v);
                            }
                        }
                    }
                } else {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (
                                        gap
                                            ? ': '
                                            : ':'
                                    ) + v);
                            }
                        }
                    }
                }

                v = partial.length === 0
                    ? '{}'
                    : gap
                        ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                        : '{' + partial.join(',') + '}';
                gap = mind;
                return v;
        }
    }

    if (typeof JSON.stringify !== 'function') {
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"': '\\"',
            '\\': '\\\\'
        };
        JSON.stringify = function (value, replacer, space) {
            var i;
            gap = '';
            indent = '';

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }
            } else if (typeof space === 'string') {
                indent = space;
            }

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                (typeof replacer !== 'object' ||
                typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

            return str('', {'': value});
        };
    }

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {
            var j;

            function walk(holder, key) {
                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }

            text = String(text);
            rx_dangerous.lastIndex = 0;
            if (rx_dangerous.test(text)) {
                text = text.replace(rx_dangerous, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

            if (
                rx_one.test(
                    text
                        .replace(rx_two, '@')
                        .replace(rx_three, ']')
                        .replace(rx_four, '')
                )
            ) {
                j = eval('(' + text + ')');

                return typeof reviver === 'function' ? walk({'': j}, '') : j;
            }
            throw new SyntaxError('JSON.parse');
        };
    }
}());

(function () {

    kcaseagt = {};

    /* private */
    initBignum();
    var util = new initUtil();
    var prop = new initProp();
    var cipher = new initCipher();
    cipher.modes = new initCipherModes();
    var seed = new initSeed();
    var asn1 = new initAsn1();
    var random = new initRandom();
    var comm = new initComm();
    var rsa = new initRsa();
    var sha256 = new initSha256();
    var log = new initLog();

    /* public */
    kcaseagt = new initApi();

    kcaseagt.browserName = util.getBrowserName();

    /**
     * encrypt : 암호화 모드 \
     * decrypt : 복호화 모드
     *
     * @attribute mode
     * @type {{encrypt: number, decrypt: number}}
     * @readonly
     */
    kcaseagt.mode = {
        encrypt: 0,
        decrypt: 1,
        restore: 2,
        remove: 3,
        http: 4,
        tcp: 5
    };

    /**
     * 암호화 알고리즘에 대한 Attribute
     *
     * @attribute algorithm
     * @readonly
     * @type {{SEED: string, ARIA12: string, ARIA14: string, ARIA16: string, DES3: string, AES: string, RSA_PKCS: number, RSA_OAEP: number, KCDSA: number, ECDSA: number}}
     */
    kcaseagt.algorithm = {
        SEED: "SEED",
        SEED256: "SEED256",
        ARIA12: "ARIA12",
        ARIA14: "ARIA14",
        ARIA16: "ARIA16",
        DES3: "3DES",
        AES: "AES",
        RSA_PKCS: 0,
        RSA_OAEP: 1,
        KCDSA: 2,
        ECDSA: 3
    };

    /**
     * 해시 알고리즘에 대한 Attribute
     *
     * @attribute hash
     * @readonly
     * @type {{SHA1: number, SHA224: number, SHA256: number, SHA384: number, SHA512: number}}
     */
    kcaseagt.hash = {
        SHA1: 0,
        SHA224: 1,
        SHA256: 2,
        SHA384: 3,
        SHA512: 4
    };

    kcaseagt.pkiMode = {
        ISSUE: 0,
        RENEWAL: 1,
        KEYRENEWAL: 2,
        SUSPENSION: 3,
        ABOLITION: 4
    };

    kcaseagt.enable = prop.enable;

    /**
     * KCASE JS API
     *
     * @module kcaseagt
     */
    function initApi() {
        var dlgDictionary = new Object();
        var certPolicyCnt = 0;

        /* init flag */
        var integrityCheckFlag = false;

        /**
         * KCASEAGENT 초기화
         *
         * @method init
         * @param {Object} [option] 초기화 옵션 객체
         * @param {Boolean} [option.debug] 콘솔 로그 출력 여부
         * @param {String} option.libRoot JS 라이브러리 루트 경로
         * @param {String} option.sessId 모듈 세션 아이디
         * @param {String} [option.mainTitle] 인증서 창 타이틀명
         * @param {String} [option.adminTitle] 인증서 관리창 타이틀명
         * @param {Object} [option.mediaOpt]
         * kcaseagt.enable.all: 모든 미디어 제어 가능 \
         * kcaseagt.enable.harddisk: 하드 디스크 제어 가능 플래그 \
         * kcaseagt.enable.remdisk: 이동식 디스크 제어 가능 플래그 \
         * kcaseagt.enable.savetoken: 저장토큰 제어 가능 플래그 \
         * kcaseagt.enable.pkcs11: 보안토큰 제어 가능 플래그 \
         * kcaseagt.enable.mobile: 휴대폰 제어 가능 플래그 \
         *
         * 예 ) kcaseagt.enable.harddisk | kcaseagt.enable.remdisk | kcaseagt.enable.pkcs11
         * @param {String} [option.position] 인증서 창 출력 위치 \
         * "top" : 최상위 위치 \
         * "center" : 가운데 위치 \
         * "bottom" : 하단에 위치
         * @param {Function} [option.success] 초기화 성공 콜백함수
         * @param {Function} [option.error] 초기화 실패 콜백함수
         * @param {Function} [option.serviceError] 서비스 에러 콜백함수 (미설치 및 버전 미일치)
         * @param {Function} [option.sessionError] 세션 만료에 대한 콜백함수
         * @param {Function} [option.noUbiKey] 휴대폰 유비키 서비스 미설치에 대한 콜백 함수
         * @param {Boolean} [option.isUseUbikey] 유비키 사용자들 강제 업데이트를 위한 플래그	2017-06-21 DYLEE
         * @param {Boolean} [option.maxpwdcnt] 사용자 비밀번호 오류 횟수 제한	2017-11-08 DYLEE
         * @param {Boolean} [option.isMOE] 교육부인지 판단하기 위한 플래그 2018-08-17 YJPARK
         */
        this.init = function (option) {
            if (comm.established) {
                return;
            }

            comm.established = true;

            var options = {
                debug: false,
                libRoot: "",
                sessId: "",
                config: "",
                mainTitle: "",
                adminTitle: "",
                mediaOpt: kcaseagt.enable.all,
                invisibleMedia : 0x00,
                position: "default",
                userName: undefined,
                ubikeyVer: "",
								ubiurl: "",
                success: function () {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                },
                serviceError: function() {
                    alert("Ajax Failed")
                },
                sessionError: function() {
                    alert("KCaseLib Failed");
                },
                noUbiKey: null,
                isUseUbikey: false,
                maxpwdcnt : 5,
                keychangedate : false,
                ISMOE : 0
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            if (options.position === "center") {
                options.position = "top+" + ((kcaseQuery(window).height() - 600)/2);
            } else if (options.position === "bottom") {
                options.position = "top+" + ((kcaseQuery(window).height() - 300)/2);
            } else if (options.position === "top") {
                options.position = "top+" + ((kcaseQuery(window).height() - 900)/2);
            } else {
                options.position = "top+" + ((kcaseQuery(window).height() - 800)/2);
            }

            prop.debug = options.debug;

            /**
             * Ubikey 사용자들 강제 업데이트를 위한 구문 추가 2017-06-21 DYLEE
             *
             * kcaseapi.js에서 init시 isUseUbikey값을 properties option 값 셋팅
             * 초기값과 init시 값을 할당하지 않으면 false, true로 할당시에만 true로 셋팅
             *
             */
			  prop.isUseUbikey = options.isUseUbikey;

            if (!prop.debug) {
                log.d = function() {};
            }

            // Init Jqeury-UI Dialog
            kcaseQuery.widget("ui.kcDialog", {
                version: "1.11.4",
                options: {
                    mainTitle: true,
                    appendTo: "head",
                    autoOpen: false,
                    buttons: [],
                    closeOnEscape: true,
                    closeText: "Close",
                    dialogClass: "",
                    draggable: true,
                    hide: null,
                    height: "auto",
                    maxHeight: null,
                    maxWidth: null,
                    minHeight: 150,
                    minWidth: 150,
                    modal: true,
                    position: {
                        my: options.position,
                        at: "top",
                        of: window,
                        collision: "none",
                        // Ensure the titlebar is always visible
                        using: function( pos ) {
                            var topOffset = kcaseQuery( this ).css( pos ).offset().top;
                            if ( topOffset < 0 ) {
                                kcaseQuery( this ).css( "top", pos.top - topOffset );
                            }
                        }
                    },
                    resizable: false,
                    show: null,
                    title: null,
                    width: 300,

                    // callbacks
                    beforeClose: null,
                    close: null,
                    drag: null,
                    dragStart: null,
                    dragStop: null,
                    focus: null,
                    open: null,
                    resize: null,
                    resizeStart: null,
                    resizeStop: null
                },

                sizeRelatedOptions: {
                    buttons: true,
                    height: true,
                    maxHeight: true,
                    maxWidth: true,
                    minHeight: true,
                    minWidth: true,
                    width: true
                },

                resizableRelatedOptions: {
                    maxHeight: true,
                    maxWidth: true,
                    minHeight: true,
                    minWidth: true
                },

                _create: function() {
                    this.originalCss = {
                        display: this.element[ 0 ].style.display,
                        width: this.element[ 0 ].style.width,
                        minHeight: this.element[ 0 ].style.minHeight,
                        maxHeight: this.element[ 0 ].style.maxHeight,
                        height: this.element[ 0 ].style.height
                    };
                    this.originalPosition = {
                        parent: this.element.parent(),
                        index: this.element.parent().children().index( this.element )
                    };
                    this.originalTitle = this.element.attr( "title" );
                    this.options.title = this.options.title || this.originalTitle;

                    this._createWrapper();

                    this.element
                        .show()
                        .removeAttr( "title" )
                        .addClass( "kc-dialog-content kc-widget-content" )
                        .appendTo( this.uiDialog );

                    this._createTitlebar();
                    this._createButtonPane();
                    if ( this.options.draggable && kcaseQuery.fn.draggable ) {
                        this._makeDraggable();
                    }
                    if ( this.options.resizable && kcaseQuery.fn.resizable ) {
                        this._makeResizable();
                    }

                    this._isOpen = false;

                    this._trackFocus();
                },

                _init: function() {
                    if ( this.options.autoOpen ) {
                        this.open();
                    }
                },

                _appendTo: function() {
                    return kcaseQuery("#kcasedialog");
                    /*var element = this.options.appendTo;
                     if ( element && (element.jquery || element.nodeType) ) {
                     return kcaseQuery( element );
                     }
                     return this.document.find( element || "body" ).eq( 0 );*/
                },

                _destroy: function() {
                    var next,
                        originalPosition = this.originalPosition;

                    this._untrackInstance();
                    this._destroyOverlay();

                    this.element
                        .removeUniqueId()
                        .removeClass( "kc-dialog-content kc-widget-content" )
                        .css( this.originalCss )
                        // Without detaching first, the following becomes really slow
                        .detach();

                    this.uiDialog.stop( true, true ).remove();

                    if ( this.originalTitle ) {
                        this.element.attr( "title", this.originalTitle );
                    }

                    next = originalPosition.parent.children().eq( originalPosition.index );
                    // Don't try to place the dialog next to itself (#8613)
                    if ( next.length && next[ 0 ] !== this.element[ 0 ] ) {
                        next.before( this.element );
                    } else {
                        originalPosition.parent.append( this.element );
                    }
                },

                widget: function() {
                    return this.uiDialog;
                },

                disable: kcaseQuery.noop,
                enable: kcaseQuery.noop,

                close: function( event ) {
										//this.uiDialog.attr("tabIndex", -1);
                    var activeElement,
                        that = this;

                    if ( !this._isOpen || this._trigger( "beforeClose", event ) === false ) {
                        return;
                    }

                    this._isOpen = false;
                    this._focusedElement = null;
                    this._destroyOverlay();
                    this._untrackInstance();

                    if ( !this.opener.filter( ":focusable" ).focus().length ) {

                        // support: IE9
                        // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
                        try {
                            activeElement = this.document[ 0 ].activeElement;

                            // Support: IE9, IE10
                            // If the <body> is blurred, IE will switch windows, see #4520
                            if ( activeElement && activeElement.nodeName.toLowerCase() !== "body" ) {

                                // Hiding a focused element doesn't trigger blur in WebKit
                                // so in case we have nothing to focus on, explicitly blur the active element
                                // https://bugs.webkit.org/show_bug.cgi?id=47182
                                kcaseQuery( activeElement ).blur();
                            }
                        } catch ( error ) {}
                    }

                    this._hide( this.uiDialog, this.options.hide, function() {
                        that._trigger( "close", event );
                    });
                },

                isOpen: function() {
                    return this._isOpen;
                },

                moveToTop: function() {
                    this._moveToTop();
                },

                _moveToTop: function( event, silent ) {
                    var moved = false,
                        zIndices = this.uiDialog.siblings( ".kc-front:visible" ).map(function() {
                            return +kcaseQuery( this ).css( "z-index" );
                        }).get(),
                        zIndexMax = Math.max.apply( null, zIndices );

                    if ( zIndexMax >= +this.uiDialog.css( "z-index" ) ) {
                        this.uiDialog.css( "z-index", zIndexMax + 1 );
                        moved = true;
                    }

                    if ( moved && !silent ) {
                        this._trigger( "focus", event );
                    }
                    return moved;
                },

                open: function() {
                    var that = this;
                    if ( this._isOpen ) {
                        if ( this._moveToTop() ) {
                            this._focusTabbable();
                        }
                        return;
                    }

                    this._isOpen = true;
                    this.opener = kcaseQuery( this.document[ 0 ].activeElement );

                    this._size();
                    this._position();
                    this._createOverlay();
                    this._moveToTop( null, true );
                    
                    //this.uiDialog.attr("tabIndex", 0);
                    // Ensure the overlay is moved to the top with the dialog, but only when
                    // opening. The overlay shouldn't move after the dialog is open so that
                    // modeless dialogs opened after the modal dialog stack properly.
                    if ( this.overlay ) {
                        this.overlay.css( "z-index", this.uiDialog.css( "z-index" ) - 1 );
                    }

                    this._show( this.uiDialog, this.options.show, function() {
                        that._focusTabbable();
                        that._trigger( "focus" );
                    });

                    // Track the dialog immediately upon openening in case a focus event
                    // somehow occurs outside of the dialog before an element inside the
                    // dialog is focused (#10152)
                    this._makeFocusTarget();

                    this._trigger( "open" );
                },

                _focusTabbable: function() {
                    // Set focus to the first match:
                    // 1. An element that was focused previously
                    // 2. First element inside the dialog matching [autofocus]
                    // 3. Tabbable element inside the content element
                    // 4. Tabbable element inside the buttonpane
                    // 5. The close button
                    // 6. The dialog itself
                    var hasFocus = this._focusedElement;
                    if ( !hasFocus ) {
                        hasFocus = this.element.find( "[autofocus]" );
                    }
                    if ( !hasFocus.length ) {
                        hasFocus = this.element.find( ":tabbable" );
                    }
                    if ( !hasFocus.length ) {
                        hasFocus = this.uiDialogButtonPane.find( ":tabbable" );
                    }
                    if ( !hasFocus.length ) {
                        hasFocus = this.uiDialogTitlebarClose.filter( ":tabbable" );
                    }
                    if ( !hasFocus.length ) {
                        hasFocus = this.uiDialog;
                    }
                    hasFocus.eq( 0 ).focus();
                },

                _keepFocus: function( event ) {
                    function checkFocus() {
                        var activeElement = this.document[0].activeElement,
                            isActive = this.uiDialog[0] === activeElement ||
                                kcaseQuery.contains( this.uiDialog[0], activeElement );
                        if ( !isActive ) {
                            this._focusTabbable();
                        }
                    }
                    event.preventDefault();
                    checkFocus.call( this );
                    // support: IE
                    // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
                    // so we check again later
                    this._delay( checkFocus );
                },

                _createWrapper: function() {
                    this.uiDialog = kcaseQuery("<div>")
                        .addClass( "kc-dialog kc-widget kc-widget-content kc-corner-all kc-front " +
                            this.options.dialogClass )
                        .hide()
                        .attr({
                            // Setting tabIndex makes the div focusable
                            tabIndex: -1,
                            role: "dialog"
                        })
                        .appendTo( this._appendTo() );

                    this._on( this.uiDialog, {
                        keydown: function( event ) {
                            if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
                                event.keyCode === kcaseQuery.ui.keyCode.ESCAPE ) {
                                event.preventDefault();
                                this.close( event );
                                if(prop.isSubView){
                                	prop.CANCEL_SUB_DIALOG();
                                }
                                else{
                                	prop.CANCEL_DIALOG();
                              	}
                              	prop.isSubView = false;
                                return;
                            }

                            // prevent tabbing out of dialogs
                            if ( event.keyCode !== kcaseQuery.ui.keyCode.TAB || event.isDefaultPrevented() ) {
                                return;
                            }
                            var tabbables = this.uiDialog.find( ":tabbable" ),
                                first = tabbables.filter( ":first" ),
                                last = tabbables.filter( ":last" );

                            if ( ( event.target === last[0] || event.target === this.uiDialog[0] ) && !event.shiftKey ) {
                                this._delay(function() {
                                    first.focus();
                                });
                                event.preventDefault();
                            } else if ( ( event.target === first[0] || event.target === this.uiDialog[0] ) && event.shiftKey ) {
                                this._delay(function() {
                                    last.focus();
                                });
                                event.preventDefault();
                            }
                        },
                        mousedown: function( event ) {
                            if ( this._moveToTop( event ) ) {
                                this._focusTabbable();
                            }
                        }
                    });

                    // We assume that any existing aria-describedby attribute means
                    // that the dialog content is marked up properly
                    // otherwise we brute force the content as the description
                    if ( !this.element.find( "[aria-describedby]" ).length ) {
                        this.uiDialog.attr({
                            "aria-describedby": this.element.uniqueId().attr( "id" )
                        });
                    }
                },

                _createTitlebar: function() {
                    var uiDialogTitle;

                    var titleName;

                    if(this.options.mainTitle) {
                        titleName = "kc-dialog-title2";
                    } else {
                        titleName = "kc-dialog-title";
                    }

                    this.uiDialog.attr("title", this.options.title);

                    this.uiDialogTitlebar = kcaseQuery( "<div><h3>" + this.options.title + "</h3></div>" )
                        .addClass( "kc-dialog-titlebar " + titleName)
                        .prependTo( this.uiDialog );

                    //this.uiDialogTitlebar.css("width", this.options.width);

                    //this.uiDialogTitlebar.css("background", "url('http://10.20.130.98:8081/kcase/lib/img/banner.png')");

                    this._on( this.uiDialogTitlebar, {
                        mousedown: function( event ) {
                            // Don't prevent click on close button (#8838)
                            // Focusing a dialog that is partially scrolled out of view
                            // causes the browser to scroll it into view, preventing the click event
                            if ( !kcaseQuery( event.target ).closest( ".kc-dialog-close" ) ) {
                                // Dialog isn't getting focus when dragging (#8063)
                                this.uiDialog.focus();
                            }
                        }
                    });

                    // support: IE
                    // Use type="button" to prevent enter keypresses in textboxes from closing the
                    // dialog in IE (#9312)
                    this.uiDialogTitlebarClose = kcaseQuery( "<a>" )
                        .addClass( "kc-dialog-close" )
                        .appendTo( this.uiDialogTitlebar );
                    this._on( this.uiDialogTitlebarClose, {
                        click: function( event ) {
                            event.preventDefault();
                            this.close( event );
                            if(prop.isSubView){
                            	prop.CANCEL_SUB_DIALOG();
                            }
                            else{
                            	prop.CANCEL_DIALOG();
                          	}
                          	prop.isSubView = false;
                        }
                    });

                    uiDialogTitle = kcaseQuery( "<span>" )
                        .uniqueId()
                        //.addClass( "kc-dialog-title" )
                        .prependTo( this.uiDialogTitlebar );
                    this._title( uiDialogTitle );

                    this.uiDialog.attr({
                        "aria-labelledby": uiDialogTitle.attr( "id" )
                    });
                },

                _title: function( title ) {
                    if ( !this.options.title ) {
                        title.html( "&#160;" );
                    }
                    //title.text( this.options.title );
                },

                _createButtonPane: function() {
                    this.uiDialogButtonPane = kcaseQuery( "<div>" )
                        .addClass( "kc-dialog-buttonpane kc-widget-content kc-helper-clearfix" );

                    this.uiButtonSet = kcaseQuery( "<div>" )
                        .addClass( "kc-dialog-buttonset" )
                        .appendTo( this.uiDialogButtonPane );

                    this._createButtons();
                },

                _createButtons: function() {
                    var that = this,
                        buttons = this.options.buttons;

                    // if we already have a button pane, remove it
                    this.uiDialogButtonPane.remove();
                    this.uiButtonSet.empty();

                    if ( kcaseQuery.isEmptyObject( buttons ) || (kcaseQuery.isArray( buttons ) && !buttons.length) ) {
                        this.uiDialog.removeClass( "kc-dialog-buttons" );
                        return;
                    }

                    kcaseQuery.each( buttons, function( name, props ) {
                        var click, buttonOptions;
                        props = kcaseQuery.isFunction( props ) ?
                            { click: props, text: name } :
                            props;
                        // Default to a non-submitting button
                        props = kcaseQuery.extend( { type: "button" }, props );
                        // Change the context for the click callback to be the main element
                        click = props.click;
                        props.click = function() {
                            click.apply( that.element[ 0 ], arguments );
                        };
                        buttonOptions = {
                            icons: props.icons,
                            text: props.showText
                        };
                        delete props.icons;
                        delete props.showText;
                        kcaseQuery( "<button></button>", props )
                            .button( buttonOptions )
                            .appendTo( that.uiButtonSet );
                    });
                    this.uiDialog.addClass( "kc-dialog-buttons" );
                    this.uiDialogButtonPane.appendTo( this.uiDialog );
                },

                _makeDraggable: function() {
                    var that = this,
                        options = this.options;

                    function filteredUi( ui ) {
                        return {
                            position: ui.position,
                            offset: ui.offset
                        };
                    }

                    this.uiDialog.draggable({
                        cancel: ".kc-dialog-content, .kc-dialog-titlebar-close",
                        handle: ".kc-dialog-titlebar",
                        //handle: ".kc-dialog-title2",
                        containment: "document",
                        start: function( event, ui ) {
                            kcaseQuery( this ).addClass( "kc-dialog-dragging" );
                            that._blockFrames();
                            that._trigger( "dragStart", event, filteredUi( ui ) );
                        },
                        drag: function( event, ui ) {
                            that._trigger( "drag", event, filteredUi( ui ) );
                        },
                        stop: function( event, ui ) {
                            var left = ui.offset.left - that.document.scrollLeft(),
                                top = ui.offset.top - that.document.scrollTop();

                            options.position = {
                                my: "left top",
                                at: "left" + (left >= 0 ? "+" : "") + left + " " +
                                "top" + (top >= 0 ? "+" : "") + top,
                                of: that.window
                            };
                            kcaseQuery( this ).removeClass( "kc-dialog-dragging" );
                            that._unblockFrames();
                            that._trigger( "dragStop", event, filteredUi( ui ) );
                        }
                    });
                },

                _makeResizable: function() {
                    var that = this,
                        options = this.options,
                        handles = options.resizable,
                        // .ui-resizable has position: relative defined in the stylesheet
                        // but dialogs have to use absolute or fixed positioning
                        position = this.uiDialog.css("position"),
                        resizeHandles = typeof handles === "string" ?
                            handles	:
                            "n,e,s,w,se,sw,ne,nw";

                    function filteredUi( ui ) {
                        return {
                            originalPosition: ui.originalPosition,
                            originalSize: ui.originalSize,
                            position: ui.position,
                            size: ui.size
                        };
                    }

                    this.uiDialog.resizable({
                        cancel: ".kc-dialog-content",
                        containment: "document",
                        alsoResize: this.element,
                        maxWidth: options.maxWidth,
                        maxHeight: options.maxHeight,
                        minWidth: options.minWidth,
                        minHeight: this._minHeight(),
                        handles: resizeHandles,
                        start: function( event, ui ) {
                            kcaseQuery( this ).addClass( "kc-dialog-resizing" );
                            that._blockFrames();
                            that._trigger( "resizeStart", event, filteredUi( ui ) );
                        },
                        resize: function( event, ui ) {
                            that._trigger( "resize", event, filteredUi( ui ) );
                        },
                        stop: function( event, ui ) {
                            var offset = that.uiDialog.offset(),
                                left = offset.left - that.document.scrollLeft(),
                                top = offset.top - that.document.scrollTop();

                            options.height = that.uiDialog.height();
                            options.width = that.uiDialog.width();
                            options.position = {
                                my: "left top",
                                at: "left" + (left >= 0 ? "+" : "") + left + " " +
                                "top" + (top >= 0 ? "+" : "") + top,
                                of: that.window
                            };
                            kcaseQuery( this ).removeClass( "kc-dialog-resizing" );
                            that._unblockFrames();
                            that._trigger( "resizeStop", event, filteredUi( ui ) );
                        }
                    })
                        .css( "position", position );
                },

                _trackFocus: function() {
                    this._on( this.widget(), {
                        focusin: function( event ) {
                            this._makeFocusTarget();
                            this._focusedElement = kcaseQuery( event.target );
                        }
                    });
                },

                _makeFocusTarget: function() {
                    this._untrackInstance();
                    this._trackingInstances().unshift( this );
                },

                _untrackInstance: function() {
                    var instances = this._trackingInstances(),
                        exists = kcaseQuery.inArray( this, instances );
                    if ( exists !== -1 ) {
                        instances.splice( exists, 1 );
                    }
                },

                _trackingInstances: function() {
                    var instances = this.document.data( "kc-dialog-instances" );
                    if ( !instances ) {
                        instances = [];
                        this.document.data( "kc-dialog-instances", instances );
                    }
                    return instances;
                },

                _minHeight: function() {
                    var options = this.options;

                    return options.height === "auto" ?
                        options.minHeight :
                        Math.min( options.minHeight, options.height );
                },

                _position: function() {
                    // Need to show the dialog to get the actual offset in the position plugin
                    var isVisible = this.uiDialog.is( ":visible" );
                    if ( !isVisible ) {
                        this.uiDialog.show();
                    }
                    this.uiDialog.position( this.options.position );

                    if ( !isVisible ) {
                        this.uiDialog.hide();
                    }
                },

                _setOptions: function( options ) {
                    var that = this,
                        resize = false,
                        resizableOptions = {};

                    kcaseQuery.each( options, function( key, value ) {
                        that._setOption( key, value );

                        if ( key in that.sizeRelatedOptions ) {
                            resize = true;
                        }
                        if ( key in that.resizableRelatedOptions ) {
                            resizableOptions[ key ] = value;
                        }
                    });

                    if ( resize ) {
                        this._size();
                        this._position();
                    }
                    if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
                        this.uiDialog.resizable( "option", resizableOptions );
                    }
                },

                _setOption: function( key, value ) {
                    var isDraggable, isResizable,
                        uiDialog = this.uiDialog;

                    if ( key === "dialogClass" ) {
                        uiDialog
                            .removeClass( this.options.dialogClass )
                            .addClass( value );
                    }

                    if ( key === "disabled" ) {
                        return;
                    }

                    this._super( key, value );

                    if ( key === "appendTo" ) {
                        this.uiDialog.appendTo( this._appendTo() );
                    }

                    if ( key === "buttons" ) {
                        this._createButtons();
                    }

                    if ( key === "closeText" ) {
                        this.uiDialogTitlebarClose.button({
                            // Ensure that we always pass a string
                            label: "" + value
                        });
                    }

                    if ( key === "draggable" ) {
                        isDraggable = uiDialog.is( ":data(ui-draggable)" );
                        if ( isDraggable && !value ) {
                            uiDialog.draggable( "destroy" );
                        }

                        if ( !isDraggable && value ) {
                            this._makeDraggable();
                        }
                    }

                    if ( key === "position" ) {
                        this._position();
                    }

                    if ( key === "resizable" ) {
                        // currently resizable, becoming non-resizable
                        isResizable = uiDialog.is( ":data(ui-resizable)" );
                        if ( isResizable && !value ) {
                            uiDialog.resizable( "destroy" );
                        }

                        // currently resizable, changing handles
                        if ( isResizable && typeof value === "string" ) {
                            uiDialog.resizable( "option", "handles", value );
                        }

                        // currently non-resizable, becoming resizable
                        if ( !isResizable && value !== false ) {
                            this._makeResizable();
                        }
                    }

                    if ( key === "title" ) {
                        this._title( this.uiDialogTitlebar.find( ".kc-dialog-title" ) );
                    }
                },

                _size: function() {
                    // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
                    // divs will both have width and height set, so we need to reset them
                    var nonContentHeight, minContentHeight, maxContentHeight,
                        options = this.options;

                    // Reset content sizing
                    this.element.show().css({
                        width: "auto",
                        minHeight: 0,
                        maxHeight: "none",
                        height: 0
                    });

                    if ( options.minWidth > options.width ) {
                        options.width = options.minWidth;
                    }

                    // reset wrapper sizing
                    // determine the height of all the non-content elements
                    nonContentHeight = this.uiDialog.css({
                        height: "auto",
                        width: options.width
                    })
                        .outerHeight();
                    minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
                    maxContentHeight = typeof options.maxHeight === "number" ?
                        Math.max( 0, options.maxHeight - nonContentHeight ) :
                        "none";

                    if ( options.height === "auto" ) {
                        this.element.css({
                            minHeight: minContentHeight,
                            maxHeight: maxContentHeight,
                            height: "auto"
                        });
                    } else {
                        this.element.height( Math.max( 0, options.height - nonContentHeight ) );
                    }

                    if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
                        this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
                    }
                },

                _blockFrames: function() {
                    this.iframeBlocks = this.document.find( "iframe" ).map(function() {
                        var iframe = kcaseQuery( this );

                        return kcaseQuery( "<div>" )
                            .css({
                                position: "absolute",
                                width: iframe.outerWidth(),
                                height: iframe.outerHeight()
                            })
                            .appendTo( iframe.parent() )
                            .offset( iframe.offset() )[0];
                    });
                },

                _unblockFrames: function() {
                    if ( this.iframeBlocks ) {
                        this.iframeBlocks.remove();
                        delete this.iframeBlocks;
                    }
                },

                _allowInteraction: function( event ) {
                    if ( kcaseQuery( event.target ).closest( ".kc-dialog" ).length ) {
                        return true;
                    }

                    // TODO: Remove hack when datepicker implements
                    // the .ui-front logic (#8989)
                    return !!kcaseQuery( event.target ).closest( ".ui-datepicker" ).length;
                },

                _createOverlay: function() {
                    if ( !this.options.modal ) {
                        return;
                    }

                    // We use a delay in case the overlay is created from an
                    // event that we're going to be cancelling (#2804)
                    var isOpening = true;
                    this._delay(function() {
                        isOpening = false;
                    });

                    if ( !this.document.data( "kc-dialog-overlays" ) ) {
                        this._on( this.document, {
                            focusin: function( event ) {
                                if ( isOpening ) {
                                    return;
                                }

                                if ( !this._allowInteraction( event ) ) {
                                    event.preventDefault();
                                    this._trackingInstances()[ 0 ]._focusTabbable();
                                }
                            }
                        });
                    }

                    this.overlay = kcaseQuery( "<div>" )
                        .addClass( "kc-widget-overlay kc-front" )
                        .appendTo( this._appendTo() );
                    this._on( this.overlay, {
                        mousedown: "_keepFocus"
                    });
                    this.document.data( "kc-dialog-overlays",
                        (this.document.data( "kc-dialog-overlays" ) || 0) + 1 );
                },

                _destroyOverlay: function() {
                    if ( !this.options.modal ) {
                        return;
                    }

                    if ( this.overlay ) {
                        var overlays = this.document.data( "kc-dialog-overlays" ) - 1;

                        if ( !overlays ) {
                            this.document
                                .unbind( "focusin" )
                                .removeData( "kc-dialog-overlays" );
                        } else {
                            this.document.data( "kc-dialog-overlays", overlays );
                        }

                        this.overlay.remove();
                        this.overlay = null;
                    }
                }
            });

            // Set Error Callback Functions
            if (prop.AJAX_ERROR_FUNC == null) {
                prop.AJAX_ERROR_FUNC = options.serviceError;
            }
            if (prop.AJAX_SESSION_EXPIRED == null) {
                prop.AJAX_SESSION_EXPIRED = options.sessionError;
            }
            if (prop.NOT_INSTALLED_UBIKEY == null) {
                prop.NOT_INSTALLED_UBIKEY = options.noUbiKey;
            }
            
            if (prop.INVALID_PASSWORD_EXCESS == null) {
            	prop.INVALID_PASSWORD_EXCESS = function(errCode, errMsg){
            			alert(errCode + " : " + errMsg);
            	};
            }
            if (prop.CANCEL_DIALOG == null) {
            	prop.CANCEL_DIALOG = function(){
            			alert("취소되었습니다.");
            	};
            }
            if (prop.CANCEL_SUB_DIALOG == null) {
            	prop.CANCEL_SUB_DIALOG = function(){
            			alert("취소되었습니다.");
            	};
            }
						/**
             * Ubikey 사용자들 강제 업데이트를 위한 구문 추가 2017-06-21 DYLEE
             *
             * Ubikey Version이 일치 하지 않는 경우 외부에서 정의해준 error로 처리
             *
             */
            if(prop.INVALID_VERSION_FOR_UBIKEYUSER == null) {
            	prop.INVALID_VERSION_FOR_UBIKEYUSER = options.error;
            }

            // Set Properties
            prop.mediaOpt = options.mediaOpt;
            prop.invisibleMedia = options.invisibleMedia;
            prop.ROOT_DIR = options.libRoot;

            var div = document.createElement('div');
            div.id = "kcasedialog";

            document.body.appendChild(div);

            kcaseQuery("#" + div.id).load(options.libRoot + "/view/dialogview.html", function () {
                dlgDictionary = initDialog();

                kcaseQuery("." + prop.cs.subDlgTitle).css("background", "url('"+ options.libRoot + prop.SUB_LOGO_URL +"')");
                kcaseQuery("." + prop.cs.mainDlgTitle).css("background", "url('"+ options.libRoot + prop.MAIN_LOGO_URL +"') no-repeat");

                var img = kcaseQuery("<img src='" + options.libRoot + "/img/off.png" + "'/>");
                kcaseQuery(".kc-off").append(img);

                var buImg = kcaseQuery("<img src='" + options.libRoot + "/img/bu.png" + "'/>");
                kcaseQuery(".kc-bu").append(buImg);

                // Insert Imgs
                var hddOnBtn = kcaseQuery(".kc-dialog .kc-rbg-normal .kc-ico-hdd");
                hddOnBtn.css("background", "url('"+ options.libRoot +"/img/icon_hdd_off.png')");

                var remOnBtn = kcaseQuery(".kc-dialog .kc-rbg-normal .kc-ico-removable");
                remOnBtn.css("background", "url('"+ options.libRoot +"/img/icon_removable_off.png')");

                var saveOnBtn = kcaseQuery(".kc-dialog .kc-rbg-normal .kc-ico-save-pkcs");
                saveOnBtn.css("background", "url('"+ options.libRoot +"/img/icon_save_pkcs_off.png')");

                var p11OnBtn = kcaseQuery(".kc-dialog .kc-rbg-normal .kc-ico-hw-pkcs");
                p11OnBtn.css("background", "url('"+ options.libRoot +"/img/icon_hw_pkcs_off.png')");

                var mobileOnBtn = kcaseQuery(".kc-dialog .kc-rbg-normal .kc-ico-mobile");
                mobileOnBtn.css("background", "url('"+ options.libRoot +"/img/icon_mobile_off.png')");

                if(options.sessId == "") {
                    comm.sessionId = util.encode64(random.generate(8));
                } else {
                    comm.sessionId = util.encode64(options.sessId);
                }

                comm.sessionKeyId = random.generate(16);

                // Dialog Title
                prop.title.cert = options.mainTitle;
                prop.title.admin = options.adminTitle;

                // debug log key
                if (prop.debug) {

                    /*to extend log encryption.
                     //RSA Public Key
                     var pemPubKey = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCIFbL8gul3o6673JWA5KKtj1m5ErwBh8dKepoqsNSl/WysVuTUQVXvZ+rxkoIzOh3M6eqGCWp+9wnvANSGHvvldKmNAu44wKkdDwmkhEktYkMsU2X8xzZT6ktWYZdbvaPp/hmCJ2U0NzSLVsOGh3WEoMsNN2wSYOcY0LhvOuz1swIDAQAB";
                     var key = rsa.publicKeyFromPem(pemPubKey);

                     log.setLogEncKey(key);
                     */
                    log.d("init debug");
                }
			/**
             * Ubikey 사용자들 강제 업데이트를 위한 구문 추가 2017-06-21 DYLEE
             *
             * init시 ubikeyVer과 url 추가
             * 값이 없으면 agent에 고정된 값으로 처리
             *
             * 2017-11-08 비밀번호 오류 최대값 설정 추가
             * mxpwdcnt
             *
             */
                _integrityInit({
                    version: prop.version,
                    success: options.success,
                    error: options.error,
                    userName: options.userName,
										ubikeyVer: options.ubikeyVer,
										ubiurl: options.ubiurl,
                    config: JSON.stringify(options.config),
                    maxpwdcnt: options.maxpwdcnt,
                    keychangedate: options.keychangedate,
                    ISMOE : options.ISMOE
                });
            });
        };

        /**
         * 잉카 키보드 보안 모듈 동작 설정
         *
         * @method enableNosAdapter
         */
        this.enableNosAdapter = function() {
            prop.usingNosAdapter = true;
            log.d("using nos : " + prop.usingNosAdapter);
        };

        /**
         * 서비스 에러 발생 시 동작할 콜백함수
         *
         * @method defineServiceError
         * @param {Function} func : 콜백함수
         * @deprecated
         */
        this.defineServiceError = function(func) {
            prop.AJAX_ERROR_FUNC = func;
        };

        /**
         * 세면 만료 시 동작할 콜백함수
         *
         * @method defineSessionExpired
         * @param {Function} func : 콜백함수
         * @deprecated
         */
        this.defineSessionExpired = function(func) {
            prop.AJAX_SESSION_EXPIRED = func;
        };

        /**
         * 유비키 미설치시 동작할 콜백함수
         *
         * @method defineNotInstalledUbiKey
         * @param {Function} func : 콜백함수
         */
        this.defineNotInstalledUbiKey = function(func) {
            prop.NOT_INSTALLED_UBIKEY = func;
        };

	 		  /**
         * 인증서 다이얼로그 등 UI 취소시 콜백함수
         *
         * @method defineCancelDialgo
         * @param {Function} func : 콜백함수
         */
        this.defineCancelDialog = function(func) {
            prop.CANCEL_DIALOG = func;
        };
        
				this.defineCancelSubDialog = function(func) {
					prop.CANCEL_SUB_DIALOG = func;
				};
	 		  /**
         * 패스워드 오류 횟수 콜백 함수
         *
         * @method definePasswordExcess
         * @param {Function} func : 콜백함수
         */
				this.definePasswordExcess = function(func) {
						prop.INVALID_PASSWORD_EXCESS = func;
				};

        /**
         * 브라우저 이름 출력
         *
         * @method getBrowserName
         * @return {String} 브라우저 이름
         */
        this.getBrowserName = util.getBrowserName;

        /**
         * 브라우저 버전 출력
         *
         * @method getBrowserVersion
         * @return {Number} 브라우저 버전
         */
        this.getBrowserVersion = util.getBrowserVersion;

        /**
         * 운영체제 출력
         *
         * @method getOSName
         * @return {String} OS 이름
         */
        this.getOSName = util.getOSName;

        /**
         * Base64 인코딩
         *
         * @method encode64
         * @param {String} input : 입력값
         * @return {String} 출력값
         */
        this.encode64 = util.encode64;

        /**
         * Base64 디코딩
         *
         * @method decode64
         * @param {String} input : 입력값
         * @return {String} 출력값
         */
        this.decode64 = util.decode64;

        /**
         * UTF-8 인코딩
         *
         * @method encodeUtf8
         * @param {String} input : 입력값
         * @return {String} 출력값
         */
        this.encodeUtf8 = util.encodeUtf8;

        /**
         * UTF-8 디코딩
         *
         * @method decodeUtf8
         * @param {String} input : 입력값
         * @return {String} 출력값
         */
        this.decodeUtf8 = util.decodeUtf8;

        /* Option Util */
        //this.setOption = util.setOption;

				/* Selected CertInfo */
				this.getSelectedCertDN = function(){
					var certInfo = util.getSelectedObject(prop.cs.certSelectedRow);
					if (certInfo == undefined) {
         			certInfo = null;
					} else {
							certInfo = certInfo.data("certInfo").subjectDN;
					}

					return certInfo;
				};
        /* Dialog Open */
        var openDialog = function (option) {
        		kcaseQuery(document).blur(); // 포커싱아웃
						dlgDictionary[prop.id.dialog.cert].open(option);
            /* Click hard disk after dialog open */
            kcaseQuery("#" + prop.id.certPosTable).find("button").eq(0).attr('tabindex', 1).focus();            
            kcaseQuery("#" + prop.id.certPosTable).find("button").eq(0).click();
        };

        /**
         * 인증서 정책을 추가합니다.
         * 추가되지 않은 인증서 정책 ID는 인증서 창에서 보이지 않습니다.
         *
         * @method addCertPolicy
         * @param {String} pol : 인증서 Policy ID
         */
        this.addCertPolicy = function(pol) {
            prop.certPolices[certPolicyCnt++] = pol;
        };

        var _checkVersion = function(resVersion, error) {
            if (resVersion != undefined) {
                var resVerArray = resVersion.split(".");
                var jsVerArray = prop.version.split(".");

				        // 2017.07.25 DYLEE Version 비교시 Major Version이 올라갔을 경우 하위 Minor Version 비교시 에러 나는 경우를 대비해서 수정
                var resVer = resVerArray[0] + resVerArray[1] + resVerArray[2];
                var jsVer = jsVerArray[0] + jsVerArray[1] + jsVerArray[2];

                try {
									if (new Number(jsVer) > new Number(resVer)) {
                      	throw "error";
									}
                } catch(e) {
                    throw e;
                }
            } else {
            		throw "error";
            } // 2018.02.14 DYLEE resVersion이 undefined 인 경우에도 미설치 함수를 이용할 수 있도록 수정 구버전에서 버전 return이 null
            	
        };
        /**
         * Ubikey 사용자들 강제 업데이트를 위한 함수 추가 2017-06-21 DYLEE
         * 1.3.8 Version 이하는 강제 업데이트
         */
        var _checkVersion_ubikey = function(resVersion, error) {
            if (resVersion != undefined) {
                var resVerArray = resVersion.split(".");
                var jsVerArray = [1, 3, 8];

                // 2017.07.25 DYLEE Version 비교시 Major Version이 올라갔을 경우 하위 Minor Version 비교시 에러 나는 경우를 대비해서 수정
                var resVer = resVerArray[0] + resVerArray[1] + resVerArray[2];
                var jsVer = jsVerArray[0] + jsVerArray[1] + jsVerArray[2];

                try {
										if (new Number(jsVer) > new Number(resVer)) {
                      	throw "error";
										}
                } catch(e) {
                    throw e;
                } // 2018.02.14 DYLEE resVersion이 undefined 인 경우에도 미설치 함수를 이용할 수 있도록 수정 구버전에서 버전 return이 null

            } else {
            		throw "error";
            }
        };

        /* Integrity Init & Security Session */
        var _integrityInit = function (option) {
            var options = {
                config: "",
                version: "",
                hashValue: "",
                success: function () {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            var intObj = {
                version: options.version,
                //hashValue: options.hashValue,
                userName: options.userName,
                config: options.config,
				 ubikeyVer: options.ubikeyVer,
				 ubiurl: options.ubiurl,
			 	 maxpwdcnt: options.maxpwdcnt, 
				 keychangedate: options.keychangedate,
				 ISMOE: options.ISMOE
            };

            comm.reqIntegrityInit(intObj, function (result) {

                var status = result.Status;

                if (status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                    comm.established = false;
                    return;
                }

                try {
                    _checkVersion(result.Version);
                } catch (e) {
                    var err = prop.errCode.agent.VERSION_DIFF_ERROR[0];
                    options.error(err, prop.getErrorMsg(err));    // 버전 일치 메시지
                    comm.established = false;
                    return;
                }

                var decodedSignMsg = util.decode64(result.IntMsg);
                var rsaPubKey = rsa.publicKeyFromPem(result.PubKey);

                var hash = sha256.create();
                //hash.update(intObj.hashValue);
                hash.update(result.Hash);
                var verify = rsa.verify(hash.digest().bytes(), decodedSignMsg, rsaPubKey);

                /* 전자서명 검증 성공 시 */
                if (verify === true) {
                    var key, iv, encKey, b64key, nonce;

                    key = random.generate(16);
                    iv = random.generate(16);
                    nonce = random.generate(32);

                    /* 대칭키 , Nonce 암호화 */
                    encKey = rsa.encrypt(key + iv + nonce, rsaPubKey);

                    /* 대칭키와 nonce값을 Base64로 인코딩 */
                    b64key = util.encode64(encKey);

                    comm.reqHandshake(b64key, function (result) {
                        var status = result.Status;
                        if (result.Status != prop.success) {
                            options.error(status, prop.getErrorMsg(status));
                        } else {
                            var decryptedHandMsg;
                            /* Session 관리 */
                            comm.securitySession.setSecureMode(key, iv);
                            decryptedHandMsg = comm.securitySession.decrypt(util.decode64(result.HandshakeMsg));

                            /* 대칭키로 암/복호화 확인 */
                            if (nonce === decryptedHandMsg) {
                                integrityCheckFlag = true;

                                log.d("kcaseagent init success!");

                                // Adapter
                                /*if (typeof npPfsCtrl !== 'object') {
                                 prop.usingNosAdapter = false;
                                 } else {
                                 npPfsCtrl.isVirtualMachine(function (result) {
                                 if (result == true) {
                                 prop.usingNosAdapter = false;
                                 } else {
                                 //var npClassList = util.getElementsByClassName('nppfs-npk');

                                 //if (npClassList.length != 0) {
                                 prop.usingNosAdapter = true;
                                 //} else {
                                 //    prop.usingNosAdapter = false;
                                 //}
                                 }
                                 });
                                 }*/

                                // On Keep Alive Proc
                                util.onKeepAliveProc();

                                options.success();
                            } else {
                                options.error("암복호화 실패");
                                comm.established = false;
                            }
                        }
                    });
                }
                else {
                    options.error("전자서명 실패");
                    comm.established = false;
                }
            });
        };

        /**
         * KCaseAgent가 설치 되었는지 체크합니다.
         *
         * @method checkInstallAgent
         * @param {Object} [option] option
         * @param {Boolean} [option.isUseUbikey] Ubikey 사용자는 강제 업데이트를 위한 플래그 2017-06-21 DYLEE
         * @param {Function} [option.success] 설치 유무에 대한 성공 콜백함수
         * @param {Function} [option.error] 설치 유무에 대한 실패 콜백함수
         */
        this.checkInstallAgent = function (option) {
            var options = {
            	isUseUbikey:false,
                success: function () {
                },
                error: function () {
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            comm.reqInstallCheck(options.error, function(result) {
                try {
                	if(options.isUseUbikey){
                		_checkVersion_ubikey(result.Version);
                	}
                	else{
                		_checkVersion(result.Version);
                	}
                    options.success();
                } catch (e) {
                    var err = prop.errCode.agent.VERSION_DIFF_ERROR[0];
                    options.error(err, prop.getErrorMsg(err));    // 버전 일치 메시지
                }
            });
        };

        /* kcaseagnet close security session */
        // Deprecated
        this.closeSecSession = function (option) {
            var options = {
                success: function () {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };
            /* 옵션 파라미터 처리 */
            if (option !== undefined) {
                util.setOption(options, option);
            }
            comm.reqCloseSecurity(function (result) {
                if (result.Status == 0) {
                    comm.securitySession.disableSecureMode();
                    options.success();
                }
            });
        };

        /**
         * 블록암호에 사용할 대칭키와 IV를 생성합니다.
         *
         * @method generateSymKeyIv
         * @param {Object} [option] option
         * @param {Object} option.algorithm 블록암호 알고리즘
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */
        this.generateSymKeyIv = function (option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                algorithm: kcaseagt.algorithm.SEED,
                success: function (key, iv) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            comm.reqGenSymmetricKey(options.algorithm, function (result) {
                var status = result.Status;

                if (status == prop.success) {
                    options.success(result.SymmKey, result.SymmIv);
                } else {
                    options.error(result.Status, prop.getErrorMsg(result.Status));
                }
            });
        };

        /**
         * 블록암호에 사용할 대칭키와 IV를 생성합니다.
         *
         * @method generateSymKeyIv
         * @param {Object} [option] option
         * @param {Object} option.algorithm 블록암호 알고리즘
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */

        this.AsymmEncrypt = function (option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                FileName: "",
                Input: "",
                success: function (Output) {
                	alert("Result : " +  Output);
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            comm.reqAsymmEncrypt(options.FileName, options.Input, function (result) {
                var status = result.Status;

                if (status == prop.success) {
                    options.success(result.Output);
                } else {
                    options.error(result.Status, prop.getErrorMsg(result.Status));
                }
            });
        };
        /**
         * 블록 암호 알고리즘을 이용하여 암호화 및 복호화를 수행합니다.
         *
         * @method blockCipher
         * @param {Object} [option] option
         * @param {Number} option.mode 0 -> 암호화 모드, 1 -> 복호화 모드
         * @param {Object} option.algorithm 블록 암호 알고리즘
         * @param {String} option.key Base64 형태 대칭키
         * @param {String} option.iv Base64 형태 IV
         * @param {String} option.input 입력값
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */
        this.blockCipher = function (option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                mode: 0,
                algorithm: kcaseagt.algorithm.SEED,
                key: "",
                iv: "",
                input: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            var reqObj = {
                mode: options.mode,
                algorithm: options.algorithm,
                key: options.key,
                iv: options.iv,
                inputText: options.input
            };

            if (reqObj.mode == 0) {
                reqObj.inputText = util.encode64(util.encodeUtf8(reqObj.inputText));
            }

            comm.reqBlockCipher(reqObj, function (result) {
                var status = result.Status;

                if (status == prop.success) {
                    if (options.mode == 1) {
                        result.Output = util.decodeUtf8(util.decode64(result.Output));
                    }
                    options.success(result.Output);
                } else {
                    options.error(result.Status, prop.getErrorMsg(result.Status));
                }
            });
        };

				this.ASP_blockCipher = function (option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                mode: 0,
                algorithm: kcaseagt.algorithm.SEED,
                key: "",
                iv: "",
                input: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            var reqObj = {
                mode: options.mode,
                algorithm: options.algorithm,
                key: options.key,
                iv: options.iv,
                inputText: options.input
            };

            if (reqObj.mode == 0) {
                reqObj.inputText = util.encode64(util.encodeUtf8(reqObj.inputText));
            }
            comm.ASP_reqBlockCipher(reqObj, function (result) {
                var status = result.Status;

                if (status == prop.success) {
                    if (options.mode == 1) {
                        result.Output = util.decodeUtf8(util.decode64(result.Output));
                    }
                    options.success(result.Output);
                } else {
                    options.error(result.Status, prop.getErrorMsg(result.Status));
                }
            });
        };

        /**
         * 선택한 인증서로 전자서명을 수행합니다.
         *
         * @method genSignData
         * @param {Object} [option] option
         * @param {String} option.input 입력값
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */
        this.genSignData = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                /*algorithm: kcaseagt.algorithm.RSA_PKCS,
                 keybit: 2048,
                 hash: kcaseagt.hash.SHA256,*/
                input: "",
                success: function (output) {
                },
                error: function (c, msg) {
                 	alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            options.service = "sign";

            openDialog(options);
        };

        /**
         * 전자서명 값에 대한 검증을 수행합니다.
         *
         * @method verifySignData
         * @param {Object} [option] option
         * @param {String} option.input 전자서명을 검증할 값
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */
        this.verifySignData = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                input: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            comm.reqVerifySignData(options.input, function (result) {
                var status = result.Status;

                if (status != prop.success) {
                    options.error(result.Status, prop.getErrorMsg(result.Status));
                } else {
                    options.success(util.decode64(result.Output));
                }
            });
        };

				this.ASP_verifySignData = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                input: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            comm.reqVerifySignData(options.input, function (result) {
                var status = result.Status;

                if (status != prop.success) {
                    options.error(result.Status, prop.getErrorMsg(result.Status));
                } else {
                    options.success(util.decodeUtf8(util.decode64(result.Output)));
                }
            });
        };
        /**
         * 선택한 인증서의 R값을 이용하여 신원확인 요청 값을 생성합니다.
         *
         * @method getVidInfo
         * @param {Object} [option] option
         * @param {String} [option.peerCert] Base64 형태의 상대방 인증서
         * @param {String} option.vid 신원확인 값
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */
        this.getVidInfo = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                peerCert: "",
                vidopt: "",
                vid: "",
                success: function (output) {
                },
                error: function (c, msg) {
									alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            if (options.vid.length <= 0) {
                var status = 0x5001;    // INVALID_INPUTDATA
                options.error(status, prop.getErrorMsg(status));
                return;
            }

            options.service = "vid";

            openDialog(options);
        };

        /**
         * 선택한 인증서의 R값을 이용하여 신원확인 요청 값을 생성합니다.
         *
         * @method getVidInfo
         * @param {Object} [option] option
         * @param {String} [option.peerCert] Base64 형태의 상대방 인증서
         * @param {String} option.vid 신원확인 값
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         *
         * 2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix
         */
        this.ASP_getVidInfo = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                peerCert: "",
                vidopt: "",
                vid: "",
                success: function (output) {
                },
                error: function (c, msg) {
                 	alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            if (options.vid.length <= 0) {
                var status = 0x5001;    // INVALID_INPUTDATA
                options.error(status, prop.getErrorMsg(status));
                return;
            }

            options.service = "vidASP";

            openDialog(options);
        };

        /**
         * 식별번호를 입력받아 Local에서 본인확인 검증을 합니다.
         * EPKI Center 전용 vid 검증
         *
         * @method verifyVID
         * @param {Object} [option] option
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */
        this.verifyVID = function(option) {
            if (!integrityCheckFlag) {
                return;
            }

            var options = {
                success: function (output) {
                },
                error: function (c, msg) {
                   alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            options.service = "epkiVid";

            openDialog(options);
        };

 /**
         * 선택한 인증서의 R값을 이용하여 신원확인 요청 값을 생성합니다.
         *
         * @method getVidInfo
         * @param {Object} [option] option
         * @param {String} [option.peerCert] Base64 형태의 상대방 인증서
         * @param {String} option.vid 신원확인 값
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */
        this.getVidInfoNSignedData = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                vid: "",
                success: function (output) {
                },
                error: function (c, msg) {
									alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            if (options.vid.length <= 0) {
                var status = 0x5001;    // INVALID_INPUTDATA
                options.error(status, prop.getErrorMsg(status));
                return;
            }

            options.service = "vidHira";

            openDialog(options);
        };
        /**
         * PKCS#7 EnvelopedData를 생성합니다.
         *
         * @method genEnvelopedData
         * @param {Object} [option] option
         * @param {String} [option.peerCert] Base64 형태의 상대방 인증서
         * @param {Object} option.algorithm 암호화 알고리즘
         * @param {String} option.input 입력값
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */
        this.genEnvelopedData = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                algorithm: "",
                peerCert: "",
                input: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            options.input = util.encode64(util.encodeUtf8(options.input));

            if (!prop.isSaveServerCert) {
                comm.setEnvCert(options.peerCert, function(response) {
                    if (response.Status == prop.success) {
                        _callGenEnvelopedData();
                        prop.isSaveServerCert = true;
                    } else {
                        options.error(response.Status, prop.getErrorMsg(response.Status));
                    }
                });
            } else {
                _callGenEnvelopedData();
            }

            function _callGenEnvelopedData() {
                comm.reqEnvelopedData(options, function(result) {
                    var status = result.Status;

                    if(status != prop.success) {
                        options.error(status, prop.getErrorMsg(status));
                    } else {
                        options.success(result.Output);
                    }
                });
            }
        };

        /**
         * PKCS#7 EnvelopedData를 생성합니다.  (ASP)
         *
         * @method genEnvelopedData
         * @param {Object} [option] option
         * @param {String} [option.peerCert] Base64 형태의 상대방 인증서
         * @param {Object} option.algorithm 암호화 알고리즘
         * @param {String} option.input 입력값
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         *
         * 2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix
         *
         */
		this.ASP_genEnvelopedData = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                algorithm: "",
                peerCert: "",
                input: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            options.input = util.encode64(util.encodeUtf8(options.input));

            if (!prop.isSaveServerCert) {
                comm.setEnvCert(options.peerCert, function(response) {
                    if (response.Status == prop.success) {
                        ASP_callGenEnvelopedData();
                        prop.isSaveServerCert = true;
                    } else {
                        options.error(response.Status, prop.getErrorMsg(response.Status));
                    }
                });
            } else {
                ASP_callGenEnvelopedData();
            }

			// 2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix

            function ASP_callGenEnvelopedData() {
                comm.ASP_reqEnvelopedData(options, function(result) {
                    var status = result.Status;

                    if(status != prop.success) {
                        options.error(status, prop.getErrorMsg(status));
                    } else {
                        options.success(result.Output);
                    }
                });
            }
        };

        /**
         * 선택한 인증서로 로그인 요청 값을 생성합니다.
         *
         * @method certLogin
         * @param {Object} [option] option
         * @param {String} [option.peerCert] Base64 형태의 상대방 인증서
         * @param {String} [option.input] 입력값
         * @param {String} [option.vid] 신원확인 값
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */
        this.certLogin = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                vid: "",
                peerCert: "",
                input: "",
                success: function (output) {
                },
                error: function (c, msg) {
                   alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            options.service = "login";

            openDialog(options);
        };

        /**
         * 선택한 인증서로 로그인 요청 값을 생성합니다. (ASP)
         *
         * 2017-07-13 DYLEE ASP 누락 함수 추가

         * @method ASP_certLogin
         * @param {Object} [option] option
         * @param {String} [option.peerCert] Base64 형태의 상대방 인증서
         * @param {String} [option.input] 입력값
         * @param {String} [option.vid] 신원확인 값
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */
        this.ASP_certLogin = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                vid: "",
                peerCert: "",
                input: "",
                success: function (output) {
                },
                error: function (c, msg) {
                   alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            options.service = "loginASP";

            openDialog(options);
        };

        /**
         * 채널보안 생성에 대한 요청값을 생성합니다.
         *
         * @method initSecureChannel
         * @param {Object} [option] option
         * @param {Object} option.algorithm 채널보안 암호화 알고리즘
         * @param {String} [option.peerCert] Base64 형태의 상대방 인증서
         * @param {String} [option.input] 입력값
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */
        this.initSecureChannel = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                algorithm: kcaseagt.algorithm.SEED,
                input: "",
                peerCert: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            comm.reqInitSecureChannel(options.input, options.algorithm, options.peerCert, function(result) {
                var status = result.Status;

                if(status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                } else {
                    options.success(result.Output);
                }
            });
        };
	/**
         * 채널보안 생성에 대한 요청값을 생성합니다. (ASP)
         *
         * @method initSecureChannel
         * @param {Object} [option] option
         * @param {Object} option.algorithm 채널보안 암호화 알고리즘
         * @param {String} [option.peerCert] Base64 형태의 상대방 인증서
         * @param {String} [option.input] 입력값
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         *
         *	2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix
         *
         */
        this.ASP_initSecureChannel = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                algorithm: kcaseagt.algorithm.SEED,
                input: "",
                peerCert: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            comm.ASP_reqInitSecureChannel(options.input, options.algorithm, options.peerCert, function(result) {
                var status = result.Status;

                if(status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                } else {
                    options.success(result.Output);
                }
            });
        };
        /**
         * 채널보안이 형성된 후 로그인 요청값을 생성합니다.
         *
         * @method secureChannelLogin
         * @param {Object} [option] option
         * @param {Object} option.algorithm 채널보안 암호화 알고리즘
         * @param {String} [option.peerCert] Base64 형태의 상대방 인증서
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */
        this.secureChannelLogin = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                algorithm: kcaseagt.algorithm.SEED,
                peerCert: "",
                success: function (output) {
                },
                error: function (c, msg) {
                 	alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            options.service = "secLogin";

            openDialog(options);
        };

        /**
         * 채널보안이 형성된 후 로그인 요청값을 생성합니다. (ASP)
         *
         * @method secureChannelLogin
         * @param {Object} [option] option
         * @param {Object} option.algorithm 채널보안 암호화 알고리즘
         * @param {String} [option.peerCert] Base64 형태의 상대방 인증서
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         *
         * 2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix
         *
         */
		this.ASP_secureChannelLogin = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                algorithm: kcaseagt.algorithm.SEED,
                peerCert: "",
                success: function (output) {
                },
                error: function (c, msg) {
									alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            options.service = "secLoginASP";

            openDialog(options);
        };
        /**
         * 채널보안이 형성된 후 암호화를 수행합니다.
         *
         * @method secureEncrypt
         * @param {Object} [option] option
         * @param {String} option.input 입력값
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */
        this.secureEncrypt = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                input: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            comm.reqExSecureChannel(kcaseagt.mode.encrypt, options.input, function(result) {
                var status = result.Status;

                if(status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                } else {
                    options.success(result.Output);
                }
            });
        };

        /**
         * 채널보안이 형성된 후 암호화를 수행합니다. (ASP)
         *
         * @method secureEncrypt
         * @param {Object} [option] option
         * @param {String} option.input 입력값
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         *
         * 2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix
         *
         */
        this.ASP_secureEncrypt = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                input: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            comm.ASP_reqExSecureChannel(kcaseagt.mode.encrypt, options.input, function(result) {
                var status = result.Status;

                if(status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                } else {
                    options.success(result.Output);
                }
            });
        };
        /**
         * 채널보안이 형성된 후 복호화를 수행합니다.
         *
         * @method secureDecrypt
         * @param {Object} [option] option
         * @param {String} option.input 입력값
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */
        this.secureDecrypt = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                input: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            comm.reqExSecureChannel(kcaseagt.mode.decrypt, options.input, function(result) {
                var status = result.Status;

                if(status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                } else {
                    options.success(result.Output);
                }
            });
        };
        /**
         * 채널보안이 형성된 후 복호화를 수행합니다.
         *
         * @method secureDecrypt
         * @param {Object} [option] option
         * @param {String} option.input 입력값
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         *
         * 2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix
         *
         */
        this.ASP_secureDecrypt = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                input: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            comm.ASP_reqExSecureChannel(kcaseagt.mode.decrypt, options.input, function(result) {
                var status = result.Status;

                if(status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                } else {
                    options.success(util.decodeUtf8(util.decode64(result.Output)));
                }
            });
        };
        /**
         * 채널보안을 종료합니다.
         *
         * @method closeSecureChannel
         * @param {Object} [option] option
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */
        this.closeSecureChannel = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                success: function () {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            comm.reqCloseSecureChannel(function(result) {
                var status = result.Status;

                if(status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                } else {
                    options.success();
                }
            });
        };

/**
         * 선택한 인증서에 대해 인증서 유효성검증을 수행합니다.(SCVP)
         *
         * @method genSignForValid
         * @param {Object} [option] option
         * @param {String} option.input 입력값
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */
        this.genSignForValid = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                svrIp: "",
                svrPort: "",
                success: function (output) {
                },
                error: function (c, msg) {
                	alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            options.service = "validCertScvp";

            openDialog(options);
        };

        /* dec enveloped data */
        this.decEnvelopedData = function(option) {

        };

        /**
         * 인증서 관리 창을 호출합니다.
         *
         * @method openAdminDialog
         */
        this.openAdminDialog = function() {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                service: "admin"
            };

            openDialog(options);
        };

        /**
         * 인증서 PKI 관리(발급/갱신/키갱신/효력정지/폐지) 창을 호출합니다.
         *
         * @method openPKIMgrDialog
         * @param {Object} [option] option
         * @param {Object} option.menu 발급/갱신/키갱신/효력정지/폐지 기능 선택
         */
        this.openPKIMgrDialog = function(option) {
            if (!integrityCheckFlag) {
                return;
            }

            if (option == undefined || option.menu == undefined) {
                return;
            }

            var options = {
                menu: 0,
                mode: 0,
                port: 0,
                addr: "",
                success: function () {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };
            util.setOption(options, option);

            if (options.menu == kcaseagt.pkiMode.ISSUE)
            {
            	var baseHeight = $(window).height();
            	var objHeight = 250;

            	var topSize = (baseHeight / 2) - (objHeight / 2) - 70;

                options.service = "issue";
                options.position = {
                    my: "top+" + topSize,
                    at: "top",
                    of: window
                };

                dlgDictionary[prop.id.dialog.issueCode].open(options);

                if (option.refNo != undefined && option.authCode != undefined) {
                    kcaseQuery("#" + prop.id.dialog.issueCode).find("button").eq(0).click();
                }
            } else {
                options.service = "pkiManager";
                options.height = 540;
                options.onlyPw = true;

                switch (option.menu) {
                    case kcaseagt.pkiMode.RENEWAL:
                        options.title = prop.title.renewal;
                        break;
                    case kcaseagt.pkiMode.KEYRENEWAL:
                        options.title = prop.title.keyRenewal;
                        break;
                    case kcaseagt.pkiMode.SUSPENSION:
                        options.title = prop.title.suspension;
                        break;
                    case kcaseagt.pkiMode.ABOLITION:
                        options.title = prop.title.abolition;
                        break;
                }

                openDialog(options);
            }
        };

        /**
         * 인증서 PKI 관리(발급/갱신/키갱신/효력정지/폐지) 창을 호출합니다(NT서버용).
         *
         * @method openPKIMgrDialog_NT
         * @param {Object} [option] option
         * @param {Object} option.menu 발급/갱신/키갱신/효력정지/폐지 기능 선택
         */
        this.openPKIMgrDialog_NT = function(option) {
            if (!integrityCheckFlag) {
                return;
            }

            if (option == undefined || option.menu == undefined) {
                return;
            }

            var options = {
                menu: 0,
                mode: 0,
                port: 0,
                addr: "",
                success: function (msg) {
                		alert(msg);
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };
            util.setOption(options, option);

            if (options.menu == kcaseagt.pkiMode.ISSUE)
            {
            	var baseHeight = $(window).height();
            	var objHeight = 250;

            	var topSize = (baseHeight / 2) - (objHeight / 2) - 70;

                options.service = "issue_NT";
                options.position = {
                    my: "top+" + topSize,
                    at: "top",
                    of: window
                };

                dlgDictionary[prop.id.dialog.issueCode].open(options);

                if (option.refNo != undefined && option.authCode != undefined) {
                    kcaseQuery("#" + prop.id.dialog.issueCode).find("button").eq(0).click();
                }
            } else {
                options.service = "pkiManager_NT";
                options.height = 540;
                options.onlyPw = true;

                switch (option.menu) {
                    case kcaseagt.pkiMode.RENEWAL:
                        options.title = prop.title.renewal;
                        break;
                    case kcaseagt.pkiMode.KEYRENEWAL:
                        options.title = prop.title.keyRenewal;
                        break;
                    case kcaseagt.pkiMode.SUSPENSION:
                        options.title = prop.title.suspension;
                        break;
                    case kcaseagt.pkiMode.ABOLITION:
                        options.title = prop.title.abolition;
                        break;
                }

                openDialog(options);
            }
        };

        /**
         * 모바일로 인증서 내보내기 창을 호출합니다.
         *
         * @method openCertExportMobileDialog
         */
        this.openCertExportMobileDialog = function(option) {
            if (!integrityCheckFlag) {
                return;
            }

            var options = {
                title: "Mobile로 인증서 내보내기",
                service: "moveCert",
                peerCert: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            openDialog(options);
        };

        /**
         * 승인코드 확인 메세지 요청 창을 호출합니다.
         *
         * @method openPermitCodeDialog
         */
        this.openPermitCodeDialog = function(option) {
            if (!integrityCheckFlag) {
                return;
            }

            var options = {
                service: "importInit",
                peerCert: "",
                position: {
                    my: "top+300",
                    at: "top",
                    of: window
                },
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            dlgDictionary[prop.id.dialog.permitCode].open(options);
        };

        /**
         * 모바일에서 인증서 가져오기 창을 호출합니다.
         *
         * @method openCertImportMobileDialog
         */
        this.openCertImportMobileDialog = function(option) {
            var options = {
                service: "import",
                peerCert: "",
                position: {
                    my: "top+300",
                    at: "top",
                    of: window
                },
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            dlgDictionary[prop.id.dialog.permitCode].open(options);
            kcaseQuery("#" + prop.id.dialog.permitCode).find("button").eq(0).click();
        };

        /**
         *
         * @param option
         */
        this.openFileDialog = function(option) {
            var options = {
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            var dlg = dlgDictionary[prop.id.dialog.file];
            dlg.setPosition({
                my: "top+300",
                at: "top",
                of: window
            });

            dlg.open(option);
        };

        /* Request File Encrypt */
        this.fileCipher = function(option) {
            if (!integrityCheckFlag) {
                return;
            }

            var options = {
                mode: 0,
                inputPath: [],
                //extension: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            var inPathList = [];

            if (options.mode == kcaseagt.mode.remove) {
                inPathList = options.inputPath;
            } else {
                for (var i in options.inputPath) {
                    inPathList[i] = util.encode64(util.encodeUtf8(options.inputPath[i]));
                }
            }

            var cipherObj = {
                mode: options.mode,
                inputPath: inPathList
                //extension: util.encode64(util.encodeUtf8(options.extension))
            };

            comm.reqFileCipher(cipherObj, function(result) {
                var status = result.Status;

                if (status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                } else {
                    options.success(result.Output);
                }
            });
        };

        /* Request File Encrypt */
        this.localFileCipher = function(option) {
            if (!integrityCheckFlag) {
                return;
            }

            var options = {
                mode: 0,
                key: "",
                iv: "",
                inputPath: [],
                //extension: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            var inPathList = [];

            for (var i in options.inputPath) {
                inPathList[i] = util.encode64(util.encodeUtf8(options.inputPath[i]));
            }

            var cipherObj = {
                mode: options.mode,
                key: options.key,
                iv: options.iv,
                inputPath: inPathList
                //extension: util.encode64(util.encodeUtf8(options.extension))
            };

            comm.reqLocalFileCipher(cipherObj, function(result) {
                var status = result.Status;

                if (status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                } else {
                    options.success(result.Output);
                }
            });
        };

        /**
         * 선택한 파일에 대하여 해시값을 구한 후 해시값을 서명합니다.
         *
         * @method genSignFileHash
         * @param {Object} [option] option
         * @param {Object} option.inputPath 파일 경로
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */

        this.genSignFileHash = function(option) {
            /*
             util.spinner.show(true);
             setTimeout(function () { //need spinner draw wait
             var hash = sha256.create();
             hash.update(option.input);
             option.success(util.encode64(hash.digest().getBytes()));
             util.spinner.hide();
             }, 2);
             //*/
            //*
            var options = {

                success: function () {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            options.service = "fHashSign";

            openDialog(options);
            //*/
        };
	/**
         * 선택한 파일에 대하여 해시값을 구한 후 해시값을 서명합니다.
         *
         * @method genFileSign
         * @param {Object} [option] option
         * @param {Object} option.inputPath 파일 경로
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */

        this.genFileSign = function(option) {
            var options = {

                success: function () {
                },
                error: function (c, msg) {
                	alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            options.service = "fFileSign";

            openDialog(options);
        };

		//fFileSign
        /**
         * 해시 알고리즘에 따라 해시값을 생성합니다.
         *
         * @method genHashData
         * @param {Object} [option] option
         * @param {Object} option.algorithm 해시 알고리즘
         * @param {String} option.input 입력값
         * @param {Function} [option.success] 성공 콜백함수
         * @param {Function} [option.error] 실패 콜백함수
         */
        this.genHashData = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                algorithm: "SHA256",
                input: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            options.input = util.encode64(util.encodeUtf8(options.input));

            comm.reqHashData(options.input, options.algorithm, function(result) {
                var status = result.Status;

                if(status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                } else {
                    options.success(result.Output);
                }
            });
        };

        /* Set Base Key */
        this.setBaseKey = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                algorithm: kcaseagt.algorithm.SEED,
                input: "",
                success: function () {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            comm.reqSetBaseKey(options.input, options.algorithm, function(result) {
                var status = result.Status;

                if(status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                } else {
                    options.success();
                }
            });
        };

        /* Get Base Key */
        this.getBaseKey = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            comm.reqGetBaseKey(function(result) {
                var status = result.Status;

                if(status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                } else {
                    options.success(result.KeyData);
                }
            });
        };

        /* Clear Base Key */
        this.clearBaseKey = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                success: function () {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            comm.reqClearBaseKey(function(result) {
                var status = result.Status;

                if(status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                } else {
                    options.success();
                }
            });
        };

        /* Base Key Encrypt */
        this.baseKeyEncrypt = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                input: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            options.input = util.encode64(util.encodeUtf8(options.input));

            comm.reqBaseKeyEncrypt(options.input, function(result) {
                var status = result.Status;

                if(status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                } else {
                    options.success(result.Ciphertext);
                }
            });
        };

        /* Base Key Decrypt */
        this.baseKeyDecrypt = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                input: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            comm.reqBaseKeyDecrypt(options.input, function(result) {
                var status = result.Status;

                if(status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                } else {
                    options.success(result.Plaintext);
                }
            });
        };

        /* Get Cert Data */
        this.getCertData = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            options.service = "getCert";

            openDialog(options);
        };

        /* Generate Multi EnvelopedData */
        this.genMultiEnvelopedData = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                input: "",
                peerCert1: "",
                peerCert2: "",
                algorithm: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            var envObj = {
                algorithm: options.algorithm,
                peerCert1: options.peerCert1,
                peerCert2: options.peerCert2,
                input: util.encode64(util.encodeUtf8(options.input))
            };

            comm.reqMultiEnvelopedData(envObj, function (result) {
                var status = result.Status;

                if (status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                } else {
                    options.success(result.Output);
                }
            });

            /*options.service = "multiEnv";

             openDialog(options);*/
        };

        /* Generate Multi DevelopedData */
        this.decryptMultiEnvelopedData = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                input: "",
                success: function (output) {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            comm.reqCheckAsymmKey(function(result){
                var status = result.Status;

                if (status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                } else {
                    if (result.Saved == 1) {
                        comm.reqDecryptMultiEnvelopedData(undefined, undefined, options.input, function (result) {
                            var status = result.Status;

                            if (status != prop.success) {
                                options.error(status, prop.getErrorMsg(status));
                            } else {
                                options.success(result.Output);
                            }
                        });
                    } else {
                        options.service = "multiDev";

                        openDialog(options);
                    }
                }
            });
        };

        /* Clear Asymmetric Key */
        this.clearAsymmetricKey = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
                success: function () {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }

            comm.reqClearAsymKey(function(result) {
                var status = result.Status;

                if(status != prop.success) {
                    options.error(status, prop.getErrorMsg(status));
                } else {
                    options.success();
                }
            });
        };
        /* ServerURL을 통하여 서버 공개키 획득 */
        this.reqEnvCert = function(option) {
            if (!integrityCheckFlag) {
                return;
            }
            var options = {
            		certurl: "",
                success: function () {
                },
                error: function (c, msg) {
                    alert(c + ": " + msg);
                }
            };

            if (option !== undefined) {
                util.setOption(options, option);
            }
        	 comm.getEnvCert(options.certurl, function(response) {
                if (response.Status == prop.success) {
                    options.success(response.Output);
                } else {
                    options.error(response.Status, prop.getErrorMsg(response.Status));
                }
            });
        }
    }

    function initComm() {
        /**
         * API Name 리스트
         *
         * @type {Object}
         */
        var APINameList = {
            CHECK_INSTALL: 0,
            INTEGRITY_INIT: 1,
            HANDSHAKE: 2,
            CLOSE_SECURITY: 3,
            INIT: 4,
            REMDISK_LIST: 5,
            DIRECTORY_LIST: 6,
            SECURITY_TOKEN_LIST: 7,
            AGENT_CHECK: 8,
            CERT_LIST_ADMIN: 9,
            CERT_LIST: 10,
            CERT_LOGIN: 11,
            CERT_DELETE: 12,
            CERT_VERIFY: 13,
            CERT_CHANGE_PASSWORD: 14,
            CERT_COPY: 15,
            CERT_IMPORT: 16,
            CERT_EXPORT: 17,
            CERT_COPY_ST: 18,
            CERT_IMPORT_ST: 19,
            CERT_GENSIGN_ST: 20,
            CERT_GENERATE_SIGNDATA: 21,
            CERT_VERIFY_SIGNDATA: 22,
            GENERATE_SYMM_KEY: 23,
            GENERATE_IV: 24,
            BLOCKCIPHER: 26,
            ENVELOP_DATA: 29,
            DEVELOP_DATA: 30,
            VERIFY_VID: 31,
            VERIFY_PASSWORD: 32, // before VERIFY_VID
            SECURE_CHANNEL_INIT: 33,
            SECURE_CHANNEL_CLOSE: 34,
            SECURE_CHANNEL_EXCHANGE: 35,
            SECURE_CHANNEL_LOGIN: 36,
            FILE_CIPHER: 37,
            SAVE_TOKEN_LIST: 38,
            SET_BASE_KEY: 40,
            GET_BASE_KEY: 41,
            CLEAR_BASE_KEY: 42,
            BASE_KEY_ENCRYPT: 43,
            BASE_KEY_DECRYPT: 44,
            MULTI_ENV_DATA: 45,
            MULTI_DEV_DATA: 46,
            CLEAR_ASSYM_KEY: 47,
            GET_CERT_DATA: 48,
            GET_CERT_INFO: 49,
            HASH_DATA: 50,
            OPEN_UBIKEY: 53,
            CHECK_ASYMMKEY: 54,
            SET_ENVCERT: 55,
            //신규
            CERT_ISSUE: 56,
            CERT_RENEWAL: 57,
            CERT_KEY_RENEWAL: 58,
            CERT_SUSPENSION: 59,
            CERT_ABOLITION: 60,
            FILEHASH_SIGN: 61,
            CERT_CONVERT: 62,
            MOBILE_EXPORT_CERT: 63,
            MOBILE_IMPORT_CERT_INIT: 64,
            MOBILE_IMPORT_CERT: 65,
            ENVELOP_DATA_ASP: 66,
            VERIFY_VID_ASP: 67,
            SECURE_CHANNEL_INIT_ASP: 68,
            SECURE_CHANNEL_LOGIN_ASP: 69,
            FILE_SIGN: 70,
            SECURE_CHANNEL_EXCHANGEASP: 71,
            CERT_LOGINASP: 72,
            BLOCKCIPHER_ASP:73,
            ASYMM_ENCRYPT:74,
            MOBILE_EXPORT_QR: 75,
            VALIDATE_SCVP:76,
            REQ_ENV_CERT: 77,
            VERIFY_VID_HIRA: 78,
            LOCAL_FILE_CIPHER: 79,
						CERT_ISSUE_NT: 80,
            CERT_RENEWAL_NT: 81,
            CERT_KEY_RENEWAL_NT: 82,
            CERT_SUSPENSION_NT: 83,
            CERT_ABOLITION_NT: 84

        };

        this.sessionId = "kcase";
        this.sessionKeyId = "";
        this.established = false;

        /* 암호 통신 정보 */
        function SecurityInfoBase() {
            var isSecure = false,
                sessionKey = undefined,
                sessionIv = undefined;

            /* Internel Function List */
            function checkInputParams() {
                if (!isSecure) {
                    return false;
                }
                if (sessionKey == undefined || sessionIv == undefined) {
                    return false;
                }
                return true;
            }

            /* function list */
            this.isSecureMode = function () {
                return isSecure;
            };
            this.setSecureMode = function (key, iv) {
                sessionKey = key;
                sessionIv = iv;
                isSecure = true;
            };
            this.disableSecureMode = function () {
                sessionKey = undefined;
                sessionIv = undefined;
                isSecure = false;
                this.sessionId = "kcase";
            };
            this.encrypt = function (p) {
                if (checkInputParams()) {
                    var plainBytes = util.createBuffer(p, "utf8");
                    var cipherobj = cipher.createCipher("SEED-CBC", sessionKey);
                    cipherobj.start({iv: sessionIv});
                    cipherobj.update(plainBytes);
                    cipherobj.finish();
                    return cipherobj.output.data;
                } else {
                    return undefined;
                }
            };
            this.decrypt = function (c) {
                if (checkInputParams()) {
                    var encBytes = util.createBuffer(c);
                    var decipher = cipher.createDecipher("SEED-CBC", sessionKey);
                    decipher.start({iv: sessionIv});
                    decipher.update(encBytes);
                    decipher.finish();
                    return decipher.output.data;
                } else {
                    return undefined;
                }
            };
        }

        this.securitySession = new SecurityInfoBase();

        /* iFrame Data Post */
        var framePost = function (callback) {
            var url = prop.requestUrl;
            var obj = this;
            obj.time = new Date().getTime();
            obj.form = kcaseQuery('<form action="' + url + '" target="kcaseiframe' + obj.time + '" method="post" style="display:none;" id="kcaseform' + obj.time + '" name="kcaseform' + obj.time + '"></form>');

            obj.addParameter = function (parameter, value) {
                kcaseQuery("<input type='hidden' />").attr("name", parameter).attr("value", value).appendTo(obj.form);
            };

            obj.send = function () {
                var frame = kcaseQuery('<iframe data-time="' + obj.time + '" style="width:1px;height:1px;display:none;" id="kcaseiframe' + obj.time + '" name="kcaseiframe' + obj.time + '"></iframe>');
                kcaseQuery("body").append(frame);
                kcaseQuery("body").append(obj.form);
                obj.form.submit();
                frame.load(function () {
                    kcaseQuery('#kcaseform' + kcaseQuery(this).data('time')).remove();
                    kcaseQuery(this).remove();
                    callback();
                });
            };
        };

        /**
         * check Agent is installed
         * @param error
         * @param daemonSvcResponse
         */
        this.reqInstallCheck = function(error, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CHECK_INSTALL,
                Error: error
            };
            //_daemonServiceRequest(obj, false, daemonSvcResponse);  //init 및 checkinstall에 Loading창 활성화
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 무결성 확인 요청
         *
         * @param {Object} intObj : 무결성 체크 정보 객체
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqIntegrityInit = function (intObj, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.INTEGRITY_INIT,
                Version: intObj.version,
                HashValue: intObj.hashValue,
                UserName: intObj.userName,
                Config: intObj.config,
				ubikeyVer: intObj.ubikeyVer,
				ubiurl: intObj.ubiurl,
				maxpwdcnt: intObj.maxpwdcnt,
				keychangedate: intObj.keychangedate,
				ISMOE: intObj.ISMOE
            };
            //_daemonServiceRequest(obj, false, daemonSvcResponse);  //init 및 checkinstall에 Loading창 활성화
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 대칭키 교환 요청
         *
         * @param {Object} encKey : 암호화된 대칭 키
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqHandshake = function (encKey, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.HANDSHAKE,
                EncryptedKey: encKey
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * 암호 통신 종료 요청
         *
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqCloseSecurity = function (daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CLOSE_SECURITY
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * 이동식 디스크 리스트 요청
         *
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqRemovableDiskList = function (daemonSvcResponse) {
            var obj = {
                APIName: APINameList.REMDISK_LIST
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * 디렉토리 리스트 요청
         *
         * @param {String} path : 디렉토리 요청 경로
         * @param {String} ext : 검색 파일 확장명
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqDirectoryList = function (path, ext, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.DIRECTORY_LIST,
                ReqPath: path,
                Ext: ext
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * 보안토큰 리스트 요청
         *
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqSecTokenList = function (daemonSvcResponse) {
            var obj = {
                APIName: APINameList.SECURITY_TOKEN_LIST
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 저장토큰 리스트 요청
         *
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqSaveTokenList = function (daemonSvcResponse) {
            var obj = {
                APIName: APINameList.SAVE_TOKEN_LIST
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 인증서 리스트 요청
         *
         * @param {Object} reqOpt : 인증서 리스트 요청 옵션
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqCertList = function (reqOpt, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CERT_LIST,
                Media: reqOpt.media,
                Drive: reqOpt.drive,
                CertOpt: reqOpt.optList,
                CertPolicies: reqOpt.certPolicies,
                Pkcs11Name: reqOpt.secTokProg,
                Password: reqOpt.saveTokenPw
            };

            var pLoading = false;
            if (obj.Media == prop.media.pkcs11 || obj.Media == prop.media.savetoken) {
                pLoading = true;
            }

            _daemonServiceRequest(obj, pLoading, daemonSvcResponse);
        };

        /**
         * 인증서 로그인 요청
         *
         * @param {Object} certInfo : 선택 인증서 객체
         * @param {Object} inputPw : 인증서 비밀번호
         * @param {Object} loginObj : 상대방인증서, 원문, VID 값
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqCertLogin = function (certInfo, inputPw, loginObj, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CERT_LOGIN,
                Media: certInfo.media,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                Pkcs11Name: loginObj.progName,
                Password: inputPw,
                VID: loginObj.vid
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

				/**
         * 인증서 로그인 요청 (ASP)
         *
         * @param {Object} certInfo : 선택 인증서 객체
         * @param {Object} inputPw : 인증서 비밀번호
         * @param {Object} loginObj : 상대방인증서, 원문, VID 값
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         *
         * 2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix
         *
         */
        this.ASP_reqCertLogin = function (certInfo, inputPw, loginObj, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CERT_LOGINASP,
                Media: certInfo.media,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                Pkcs11Name: loginObj.progName,
                Password: inputPw,
                VID: loginObj.vid
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };
        /**
         * 전자서명 생성 요청
         *
         * @param {Object} certInfo : 선택 인증서 객체
         * @param {Object} certPw : 인증서 비밀번호
         * @param {Object} signObj : 서명알고리즘, 키 비트, 해시, 원문
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqGenSignData = function (certInfo, certPw, signObj, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CERT_GENERATE_SIGNDATA,
                Media: certInfo.media,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                Password: certPw,
                Algorithm: signObj.algorithm,
                KeyBit: signObj.keybit,
                Hash: signObj.hash,
                Input: signObj.input
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

 /**
         * 인증서 SCVP 검증 요청
         *
         * @param {Object} certInfo : 선택 인증서 객체
         * @param {Object} certPw : 인증서 비밀번호
         * @param {Object} signObj : 서명알고리즘, 키 비트, 해시, SCVP 서버 IP, SCVP 서버 PORT
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqValidCertBySCVP = function (certInfo, certPw, signObj, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.VALIDATE_SCVP,
                Media: certInfo.media,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                Password: certPw,
                SvrIp: signObj.svrIp,
                SvrPort : signObj.svrPort
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 전자서명 검증 요청
         *
         * @param {Object} input : 검증 요청 객체
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqVerifySignData = function (input, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CERT_VERIFY_SIGNDATA,
                Input: input
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * Enveloped Data 요청
         *
         * @param {Object} envObj : 알고리즘, 상대방 인증서(공개키), 원문
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqEnvelopedData = function (envObj, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.ENVELOP_DATA,
                Algorithm: envObj.algorithm,
                Input: envObj.input
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * Enveloped Data 요청
         *
         * @param {Object} envObj : 알고리즘, 상대방 인증서(공개키), 원문
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         *
         * 2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix
         *
         */
        this.ASP_reqEnvelopedData = function (envObj, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.ENVELOP_DATA_ASP,
                Algorithm: envObj.algorithm,
                Input: envObj.input
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };


        /**
         * Develope 요청
         *
         * @param {Object} certInfo : 선택 인증서 객체
         * @param {Object} intObj : 인증서 비밀번호, EnvelopedData
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqDevelopeData = function (certInfo, intObj, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.DEVELOP_DATA,
                Media: certInfo.media,
                CertDn: certInfo.certDn,
                Password: intObj.inputPw,
                EnvelopedData: intObj.envelopedData
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * 인증서 PASSWORD 체크 요청
         *
         * @param {Object} certInfo : 선택 인증서 객체
         * @param {Object} inputPw : 인증서 비밀번호
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqCheckCertPW = function (certInfo, inputPw, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.VERIFY_PASSWORD,
                Media: certInfo.media,
                CertDn: certInfo.certDn,
                Password: inputPw
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * VID 정보 요청
         *
         * @param {Object} certInfo : 선택 인증서 객체
         * @param {Object} certPw : 인증서 비밀번호
         * @param {String} vid : VID 값
         * @param {String} vidopt : client 인증여부
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqVerifyVidInfo = function (certInfo, certPw, vid, vidopt, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.VERIFY_VID,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                Media: certInfo.media,
                Password: certPw,
                VID: vid,
                VIDOPT: vidopt
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * VID 정보 요청 및 서명
         *
         * @param {Object} certInfo : 선택 인증서 객체
         * @param {Object} certPw : 인증서 비밀번호
         * @param {String} vid : VID 값
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqVerifyVidInfoHira = function (certInfo, certPw, vid, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.VERIFY_VID_HIRA,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                Media: certInfo.media,
                Password: certPw,
                VID: vid,
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };
        /**
         * VID 정보 요청
         *
         * @param {Object} certInfo : 선택 인증서 객체
         * @param {Object} certPw : 인증서 비밀번호
         * @param {String} vid : VID 값
         * @param {String} vidopt : client 인증여부
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         *
         * 2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix
         *
         */

        this.ASP_reqVerifyVidInfo = function (certInfo, certPw, vid, vidopt, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.VERIFY_VID_ASP,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                Media: certInfo.media,
                Password: certPw,
                VID: vid,
                VIDOPT: vidopt
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * 인증서 삭제 요청
         *
         * @param {Object} certInfo : 선택 인증서 객체
         * @param {Object} password : 보안토큰 비밀번호
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqDeleteCert = function (certInfo, password, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CERT_DELETE,
                Media: certInfo.media,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                PinPassword: password
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * 인증서 검증 요청
         *
         * @param {Object} certInfo : 선택 인증서 객체
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqCertVerify = function (certInfo, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CERT_VERIFY,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 비밀번호 변경
         *
         * @param {Object} certInfo : 선택 인증서 객체
         * @param {Object} oldPw : 기존 인증서 비밀번호
         * @param {Object} newPw : 변경할 인증서 비밀번호
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqChangePassword = function (certInfo, oldPw, newPw, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CERT_CHANGE_PASSWORD,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                OldPassword: oldPw,
                NewPassword: newPw
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * 인증서 복사
         *
         * @param {Object} certInfo : 선택 인증서 객체
         * @param {Object} selectMediaInfo : 복사할 미디어 매체 정보
         * @param {Object} password : 인증서 비밀번호
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqCopyCert = function (certInfo, selectMediaInfo, password, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CERT_COPY,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                ToMedia: selectMediaInfo.toMedia,
                ToDrive: selectMediaInfo.toDrive,
                Password: password
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * 인증서 가져오기
         *
         * @param {Object} reqPath : PFX 파일이 위치한 경로
         * @param {Object} toMedia : 복사할 미디어 매체
         * @param {Object} toDrive : 복사할 미디어 매체의 저장 드라이브
         * @param {Object} password : 인증서 비밀번호
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqImportCert = function (reqPath, toMedia, toDrive, password, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CERT_IMPORT,
                ToMedia: toMedia,
                ToDrive: toDrive,
                ReqPath: reqPath,
                Password: password
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * 인증서 내보내기
         *
         * @param {Object} certInfo : 내보낼 인증서 정보 객체
         * @param {Object} reqPath : 내보낼 미디어 매체 경로
         * @param {Object} password : 인증서 비밀번호
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqExportCert = function (certInfo, reqPath, password, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CERT_EXPORT,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                ReqPath: reqPath,
                Password: password
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * SSL 인증서 변환
         *
         * @param {String} certPath : SSL 인증서 파일 경로
         * @param {String} keyPath : SSL 인증서의 키 파일 경로
         * @param {Object} password : 인증서 비밀번호
         * @param {String} savePath : PFX파일 저장 경로
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqConvertCert = function (certPath, keyPath, password, savePath, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CERT_CONVERT,
                SSLCertPath: util.encode64(util.encodeUtf8(certPath)),
                SSLKeyPath: util.encode64(util.encodeUtf8(keyPath)),
                SSLKeyPass: password,
                SSLSavePath: util.encode64(util.encodeUtf8(savePath))
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 인증서 복사 - 보안토큰
         *
         * @param {Object} certInfo : 복사할 인증서 정보 객체
         * @param {Object} secTokenData : 보안토큰 정보 객체
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqCopyCertSecToken = function (certInfo, secTokenData, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CERT_COPY_ST,
                ToMedia: secTokenData.toMedia,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                Pkcs11Name: secTokenData.progName,
                Password: secTokenData.certPw,
                PinPassword: secTokenData.pinPw
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 인증서 가져오기 - 보안토큰
         *
         * @param {Object} reqPath : 가져올 인증서의 위치 경로
         * @param {Object} secTokenData : 보안토큰 정보 객체
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqImportCertSecToken = function (reqPath, secTokenData, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CERT_IMPORT_ST,
                ReqPath: reqPath,
                Pkcs11Name: secTokenData.progName,
                Password: secTokenData.certPw,
                PinPassword: secTokenData.pinPw
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 전자서명 생성 - 보안토큰
         *
         * @param {Object} certInfo : 선택한 인증서 정보 객체
         * @param {Object} signObj : 전자서명 생성 입력 정보 객체
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqSignDataPkcs11 = function (certInfo, signObj, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CERT_GENSIGN_ST,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                Pkcs11Name: signObj.progName,
                PinPassword: signObj.pinPw,
                Input: signObj.input
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 블록 암, 복호화 요청
         *
         * @param {Object} reqObj : 블록 암/복호화 정보 객체
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqBlockCipher = function (reqObj, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.BLOCKCIPHER,
                Mode: reqObj.mode,
                Algorithm: reqObj.algorithm,
                SymmKey: reqObj.key,
                SymmIv: reqObj.iv,
                Input: reqObj.inputText
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        this.ASP_reqBlockCipher = function (reqObj, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.BLOCKCIPHER_ASP,
                Mode: reqObj.mode,
                Algorithm: reqObj.algorithm,
                SymmKey: reqObj.key,
                SymmIv: reqObj.iv,
                Input: reqObj.inputText
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
     			* 비대칭키 암호화
     			* @param {String} input : 서버인증서 경로
     			* @param {String} input : 암호호할 원문값
     			* @returns {String} output : 비대칭키로 암호화된 데이터(B64데이터)
     		*/

				this.reqAsymmEncrypt = function (FilePath, PlainData, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.ASYMM_ENCRYPT,
                FileName: FilePath,
                Input: PlainData,
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };
        /**
         * 대칭키 생성 요청
         *
         * @param {Object} algorithm : 생성할 키 알고리즘
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         * @param {Boolean} pLoading : 로딩바 출력 여부
         */
        this.reqGenSymmetricKey = function (algorithm, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.GENERATE_SYMM_KEY,
                Algorithm: algorithm
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * IV 생성 요청
         *
         * @param {Object} intObj : 요청 정보 객체
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqGenInitVector = function (intObj, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.GENERATE_IV,
                Byte: intObj.byte
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * 보안채널 생성 요청
         *
         * @param {Object} peerCert: 상대방 인증서
         * @param {Object} algorithm: 블록암호 알고리즘
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqInitSecureChannel = function (input, algorithm, peerCert, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.SECURE_CHANNEL_INIT,
                Algorithm: algorithm,
                PeerCert: peerCert,
                Input: input
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * 보안채널 생성 요청
         *
         * @param {Object} peerCert: 상대방 인증서
         * @param {Object} algorithm: 블록암호 알고리즘
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         *
         * 2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix
         *
         */
        this.ASP_reqInitSecureChannel = function (input, algorithm, peerCert, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.SECURE_CHANNEL_INIT_ASP,
                Algorithm: algorithm,
                PeerCert: peerCert,
                Input: input
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * 보안채널 종료 요청
         *
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqCloseSecureChannel = function (daemonSvcResponse) {
            var obj = {
                APIName: APINameList.SECURE_CHANNEL_CLOSE
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * 보안채널 메시지 교환
         *
         * @param {Number} mode: 암 복호화 모드
         * @param {String} input: 입력값
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqExSecureChannel = function (mode, input, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.SECURE_CHANNEL_EXCHANGE,
                Mode: mode,
                Input: input
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * 보안채널 메시지 교환
         *
         * @param {Number} mode: 암 복호화 모드
         * @param {String} input: 입력값
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         *
         * 2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix
         *
         */
        this.ASP_reqExSecureChannel = function (mode, input, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.SECURE_CHANNEL_EXCHANGEASP,
                Mode: mode,
                Input: input
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };
        /**
         * 보안채널 로그인 동시수행
         *
         * @param certInfo
         * @param inputPw
         * @param algorithm
         * @param daemonSvcResponse
         */
        this.reqSecChannelLogin = function (certInfo, inputPw, algorithm, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.SECURE_CHANNEL_LOGIN,
                Media: certInfo.media,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                //CertDn: certInfo.certIndex,
                CertSn: certInfo.serialNumber,
                Password: inputPw,
                Algorithm: algorithm
            };

            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 보안채널 로그인 동시수행 (ASP)
         *
         * @param certInfo
         * @param inputPw
         * @param algorithm
         * @param daemonSvcResponse
         *
         * 2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix
         *
         */
	this.ASP_reqSecChannelLogin = function (certInfo, inputPw, algorithm, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.SECURE_CHANNEL_LOGIN_ASP,
                Media: certInfo.media,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                //CertDn: certInfo.certIndex,
                CertSn: certInfo.serialNumber,
                Password: inputPw,
                Algorithm: algorithm
            };

            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 파일 암호화/복호화
         *
         * @param cipherObj
         * @param daemonSvcResponse
         */
        this.reqFileCipher = function(cipherObj, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.FILE_CIPHER,
                Mode: cipherObj.mode,
                Input: cipherObj.inputPath
                //Ext: cipherObj.extension
            };

            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 파일 암호화/복호화 key / iv 파라메터로 입력 가능
         *
         * @param cipherObj
         * @param daemonSvcResponse
         */
        this.reqLocalFileCipher = function(cipherObj, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.LOCAL_FILE_CIPHER,
                Mode: cipherObj.mode,
                Key: cipherObj.key,
                Iv: cipherObj.iv,
                Input: cipherObj.inputPath
                //Ext: cipherObj.extension
            };

            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 파일 해시 전자 서명
         *
         * @param {String} inputPath : 파일 경로
         * @param {Object} certInfo : 인증서 정보
         * @param {Object} certpw : 인증서 패스워드
         * @param {Function} daemonSvcResponse : 요청 응답시 수행할 동작
         */
        this.reqSignFileHash = function(inputPath, certInfo, certPw, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.FILEHASH_SIGN,
                Input: inputPath,
                Media: certInfo.media,
                ToDrive: certInfo.drive,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                Password: certPw
            };

            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

		this.reqFileSign = function(inputPath, certInfo, certPw, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.FILE_SIGN,
                Input: inputPath,
                Media: certInfo.media,
                ToDrive: certInfo.drive,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                Password: certPw
            };

            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 해시 데이터 생성
         *
         * @param input
         * @param algorithm
         * @param daemonSvcResponse
         */
        this.reqHashData = function(input, algorithm, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.HASH_DATA,
                Input: input,
                Hash: algorithm
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /* Not Use
        this.reqSetBaseKey = function(input, algorithm, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.SET_BASE_KEY,
                KeyData: input,
                Algorithm: algorithm
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        this.reqGetBaseKey = function(daemonSvcResponse) {
            var obj = {
                APIName: APINameList.GET_BASE_KEY
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        this.reqClearBaseKey = function(daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CLEAR_BASE_KEY
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        this.reqBaseKeyEncrypt = function(input, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.BASE_KEY_ENCRYPT,
                Plaintext: input
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        this.reqBaseKeyDecrypt = function(input, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.BASE_KEY_DECRYPT,
                Ciphertext: input
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };
        */

        /**
         * Get Cert Data(Base64)
         * @param certInfo
         * @param certPw
         * @param daemonSvcResponse
         */
        this.reqGetCertData = function(certInfo, certPw, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.GET_CERT_DATA,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                Password: certPw
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * Generate Multi EnvelopedData
         * @param envObj
         * @param daemonSvcResponse
         */
        this.reqMultiEnvelopedData = function(envObj, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.MULTI_ENV_DATA,
                Algorithm: envObj.algorithm,
                PeerCert1: envObj.peerCert1,
                PeerCert2: envObj.peerCert2,
                Input: envObj.input
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * Decrypt Multi EnvelopedData
         * @param certInfo
         * @param certPw
         * @param input
         * @param daemonSvcResponse
         */
        this.reqDecryptMultiEnvelopedData = function(certInfo, certPw, input, daemonSvcResponse) {
            var obj;
            if (certInfo != undefined) {
                obj = {
                    APIName: APINameList.MULTI_DEV_DATA,
                    CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                    CertSn: certInfo.serialNumber,
                    Password: certPw,
                    Input: input
                };
            } else {
                obj = {
                    APIName: APINameList.MULTI_DEV_DATA,
                    Input: input
                };
            }

            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * Clear Asymmetric Key
         * @param daemonSvcResponse
         */
        this.reqClearAsymKey = function(daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CLEAR_ASSYM_KEY
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * Open UBI KEY
         * @param daemonSvcResponse
         */
        this.reqOpenUbikey = function(daemonSvcResponse) {
            var obj = {
                APIName: APINameList.OPEN_UBIKEY
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * Check AsymmKey
         * @param daemonSvcResponse
         */
        this.reqCheckAsymmKey = function(daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CHECK_ASYMMKEY
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * Set Server Certificate
         * @param peerCert
         * @param daemonSvcResponse
         */
        this.setEnvCert = function(peerCert, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.SET_ENVCERT,
                PeerCert: peerCert
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * Set Server Certificate
         * @param peerCert
         * @param daemonSvcResponse
         */
        this.getEnvCert = function(certUrl, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.REQ_ENV_CERT,
                getcerturl: certUrl
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 인증서 발급
         *
         * @param {Object} reqOpt : 인증서 발급 요청 옵션
         * @param {Function} daemonSvcResponse : 요청 응답시 수행할 동작
         */
        this.reqIssueCert = function(reqOpt, certPw, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CERT_ISSUE,
                Mode: reqOpt.mode,
                Addr: reqOpt.addr,
                Port: reqOpt.port,
                RefNo: reqOpt.refNo,
                AuthCode: reqOpt.authCode,
                Media: reqOpt.media,
                ToDrive: reqOpt.drive,
                Password: certPw
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 인증서 갱신/키갱신/효력정지/폐지
         *
         * @param {Object} reqOpt : 갱신/키갱신/효력정지/폐지 옵션
         * @param {Object} certInfo : 인증서 정보
         * @param {Object} certpw : 인증서 패스워드
         * @param {number} reason : 폐지 사유
         * @param {Function} daemonSvcResponse : 요청 응답시 수행할 동작
         */
        this.reqPKIManager = function(reqOpt, certInfo, certPw, reason, daemonSvcResponse) {
            var obj = {
                APIName: undefined,
                Mode: reqOpt.mode,
                Addr: reqOpt.addr,
                Port: reqOpt.port,
                Media: certInfo.media,
                ToDrive: certInfo.drive,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                Reason: reason,
                Password: certPw
            };

            switch (reqOpt.menu) {
                case kcaseagt.pkiMode.RENEWAL:
                    obj.APIName = APINameList.CERT_RENEWAL;
                    break;
                case kcaseagt.pkiMode.KEYRENEWAL:
                    obj.APIName = APINameList.CERT_KEY_RENEWAL;
                    break;
                case kcaseagt.pkiMode.SUSPENSION:
                    obj.APIName = APINameList.CERT_SUSPENSION;
                    break;
                case kcaseagt.pkiMode.ABOLITION:
                    obj.APIName = APINameList.CERT_ABOLITION;
                    break;
            }

            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 인증서 발급
         *
         * @param {Object} reqOpt : 인증서 발급 요청 옵션
         * @param {Function} daemonSvcResponse : 요청 응답시 수행할 동작
         */
        this.reqIssueCert_NT = function(reqOpt, certPw, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.CERT_ISSUE_NT,
                Mode: reqOpt.mode,
                Addr: reqOpt.addr,
                Port: reqOpt.port,
                RefNo: reqOpt.refNo,
                AuthCode: reqOpt.authCode,
                Media: reqOpt.media,
                ToDrive: reqOpt.drive,
                Password: certPw
            };
            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };

        /**
         * 인증서 갱신/키갱신/효력정지/폐지
         *
         * @param {Object} reqOpt : 갱신/키갱신/효력정지/폐지 옵션
         * @param {Object} certInfo : 인증서 정보
         * @param {Object} certpw : 인증서 패스워드
         * @param {number} reason : 폐지 사유
         * @param {Function} daemonSvcResponse : 요청 응답시 수행할 동작
         */
        this.reqPKIManager_NT = function(reqOpt, certInfo, certPw, reason, daemonSvcResponse) {
            var obj = {
                APIName: undefined,
                Mode: reqOpt.mode,
                Addr: reqOpt.addr,
                Port: reqOpt.port,
                Media: certInfo.media,
                ToDrive: certInfo.drive,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                Reason: reason,
                Password: certPw
            };

            switch (reqOpt.menu) {
                case kcaseagt.pkiMode.RENEWAL:
                    obj.APIName = APINameList.CERT_RENEWAL_NT;
                    break;
                case kcaseagt.pkiMode.KEYRENEWAL:
                    obj.APIName = APINameList.CERT_KEY_RENEWAL_NT;
                    break;
                case kcaseagt.pkiMode.SUSPENSION:
                    obj.APIName = APINameList.CERT_SUSPENSION_NT;
                    break;
                case kcaseagt.pkiMode.ABOLITION:
                    obj.APIName = APINameList.CERT_ABOLITION_NT;
                    break;
            }

            _daemonServiceRequest(obj, true, daemonSvcResponse);
        };
        /**
         * 모바일(WizSign)으로 인증서 내보내기를 위한 Enveloped 데이터 생성 요청
         *
         * @param {String} peerCert: 서버 인증서
         * @param {Object} certInfo : 인증서 정보
         * @param {Object} certpw : 인증서 패스워드
         * @param {int} code : 승인번호
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqExportCertForMobile = function (peerCert, certInfo, certPw, code, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.MOBILE_EXPORT_CERT,
                PeerCert: peerCert,
                Media: certInfo.media,
                ToDrive: certInfo.drive,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                Password: certPw,
                PermitCode: code
            };

            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

				/**
         * 모바일(WizSign)으로 인증서 내보내기를 위한 Enveloped 데이터 생성 요청
         *
         * @param {String} peerCert: 서버 인증서
         * @param {Object} certInfo : 인증서 정보
         * @param {Object} certpw : 인증서 패스워드
         * @param {int} code : 승인번호
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqExportCertForMobile = function (peerCert, certInfo, certPw, code, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.MOBILE_EXPORT_CERT,
                PeerCert: peerCert,
                Media: certInfo.media,
                ToDrive: certInfo.drive,
                CertDn: util.encode64(util.encodeUtf8(certInfo.subjectDN)),
                CertSn: certInfo.serialNumber,
                Password: certPw,
                PermitCode: code
            };

            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };
        
        /**
         * 모바일 중계서버(WizSign)로 보낼 승인번호 데이터 생성 요청
         *
         * @param {Object} peerCert: 서버 인증서
         * @param {String} peerCert: 인증코드
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqPermitCodeForMobile = function (peerCert, code, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.MOBILE_IMPORT_CERT_INIT,
                PeerCert: peerCert,
                PermitCode: code
            };

            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * Keep Alive
         *
         * @param daemonSvcResponse
         */
        this.reqAgentKeepAlive = function(daemonSvcResponse) {
            var obj = {
                APIName: APINameList.AGENT_CHECK
            };
            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * 모바일 중계서버(WizSign)에서 받아온 데이터로 인증서 가져오기
         *
         * @param {Object} peerCert: 서버 인증서
         * @param {String} peerCert: 인증코드
         * @param {Object} certInfo : 인증서 정보
         * @param {Object} certpw : 인증서 패스워드
         * @param {Function} daemonSvcResponse : 성공 시 수행할 동작
         */
        this.reqImportCertForMobile = function (reqOpt, key, daemonSvcResponse) {
            var obj = {
                APIName: APINameList.MOBILE_IMPORT_CERT,
                PeerCert: reqOpt.peerCert,
                PfxData: reqOpt.pfx,
                Media: reqOpt.media,
                ToDrive: reqOpt.drive,
                Password: key
            };

            _daemonServiceRequest(obj, false, daemonSvcResponse);
        };

        /**
         * Ajax 요청
         *
         * @param {Object} sendObj : 데몬에 요청할 오브젝트 정보
         * @param {Boolean} pLoading : 로딩바 강제 출력 여부
         * @param {Function} resultFunc : 성공 시 수행할 동작
         */
        function _daemonServiceRequest(sendObj, pLoading, resultFunc) {
            var obj, sendData, closeMode = false;

            //log.d(JSON.stringify(sendObj));

            if (sendObj.APIName == APINameList.CLOSE_SECURITY) {
                closeMode = true;
            }

            obj = {
                SessionId: comm.sessionId,
                Data: undefined,
                Method: "post"
            };

            if (comm.securitySession.isSecureMode() == true) {
                var nonce = util.encode64(random.generate(8));

                obj.Data = util.encode64(comm.sessionKeyId + comm.securitySession.encrypt(nonce + util.encode64(JSON.stringify(sendObj))));
            } else {
                obj.Data = util.encode64(comm.sessionKeyId + JSON.stringify(sendObj));
            }

            sendData = JSON.stringify(obj);

            var timeoutValue;

            if (sendObj.APIName == APINameList.INTEGRITY_INIT) {
                //timeoutValue = 7500 + (sendData.length / 5);
                timeoutValue = 15000;
            } else if (sendObj.APIName == APINameList.CHECK_INSTALL) {
            		timeoutValue = 5000;
            } else {
                timeoutValue = 0;
            }

            if (pLoading) {
                util.spinner.show(true);
            } else {
                if ((timeoutValue > 8000.0 || timeoutValue == 0) && sendObj.APIName != APINameList.AGENT_CHECK) {
                    util.spinner.show(true);
                }
            }

            function _ajaxSuccess(data) {
                var jsonObj;

                if (sendObj.APIName == APINameList.CHECK_INSTALL) {
                    resultFunc(data);
                } else {
                    if (comm.securitySession.isSecureMode() == true && closeMode == false) {
                        if (data.Status != undefined) {
                            jsonObj = {
                                Status: -2
                            }
                        } else {
                            var decData = comm.securitySession.decrypt(util.decode64(data.Output));
                            jsonObj = kcaseQuery.parseJSON(decData);
                        }
                    } else {
                        jsonObj = data;
                    }

                    if(jsonObj.Status == -2) {
                        comm.established = false;
                        prop.AJAX_SESSION_EXPIRED();
                        util.offKeepAliveProc();
                    } else {
                        comm.sessionId = jsonObj.SessionId;

                        /* Invoke Callback Function */
                        resultFunc(jsonObj);
                    }
                }

                util.spinner.hide();
            }

            function _ajaxError(err) {
                comm.established = false;

                if (sendObj.APIName == APINameList.AGENT_CHECK) {
                    util.offKeepAliveProc();
                } else if (sendObj.APIName == APINameList.CHECK_INSTALL) {
                    var err = prop.errCode.agent.NO_INSTALL[0];
                    sendObj.Error(err, prop.getErrorMsg(err));
                } else {
                    prop.AJAX_ERROR_FUNC(err);
                }

                util.spinner.hide();
            }

            if (kcaseagt.browserName == "Explorer" || kcaseagt.browserName == "Swing" || kcaseagt.browserName == "Mozilla") {
                if (sendData.length > 1024) {
                    obj.Method = "frame";
                    var time = new Date();
                    var strTime = time.getTime().toString();
                    var postCall = new framePost(function() {
                        obj = {
                            SessionId: comm.sessionId,
                            Data: strTime,
                            Method: "pol"
                        };
                        kcaseQuery.ajax({
                            url: prop.requestUrl,
                            jsonpCallback: "KCASE",
                            dataType: 'jsonp',
                            async: false,
                            data: {
                                data: encodeURIComponent(JSON.stringify(obj))
                            },
                            cache: true,
                            timeout: 0,
                            success: function(data) {
                                _ajaxSuccess(data);
                            },
                            error: function(data, status, err) {
                                _ajaxError(err);
                            }
                        });
                    });
                    postCall.addParameter("data", JSON.stringify(obj));
                    postCall.send();
                } else {
                    if (sendObj.APIName == APINameList.AGENT_CHECK) {
                        obj.Method = "keep";
                    } else if (sendObj.APIName == APINameList.CHECK_INSTALL) {
                        obj.Method = "install";
                    } else {
                        obj.Method = "get";
                    }

                    kcaseQuery.ajax({
                        url: prop.requestUrl,
                        //method: "POST",
                        jsonpCallback: "KCASE",
                        dataType: 'jsonp',
                        async: false,
                        data: {
                            data: encodeURIComponent(JSON.stringify(obj))
                        },
                        cache: true,
                        timeout: timeoutValue,
                        success: function(data) {
                            _ajaxSuccess(data);
                        },
                        error: function(data, status, err) {
                            _ajaxError(err);
                        }
                    });
                }
            } else {
                if (sendObj.APIName == APINameList.AGENT_CHECK) {
                    obj.Method = "keep";
                } else if (sendObj.APIName == APINameList.CHECK_INSTALL) {
                    obj.Method = "install";
                } else {
                    obj.Method = "post";
                }
                kcaseQuery.ajax({
                    url: prop.requestUrl,
                    method: "POST",
                    async: true,
                    data: {
                        data: encodeURIComponent(JSON.stringify(obj))
                    },
                    success: function(data) {
                        _ajaxSuccess(data);
                    },
                    error: function(data, status, err) {
                        _ajaxError(err);
                    }
                });
            }

        }
    }

    function initProp() {
        /* kcaseagent js version */
        this.version = "1.3.17";
        /* kcaseagent requset address */

        this.requestUrl = "https://127.0.0.1:39721";
        /* kcaseagent keep alive interval */
        this.intervalTime = 120000;

        /* url 경로 */
        this.SECURITY_TOKEN_INSTALL_URL = "http://www.rootca.or.kr/kor/hsm/hsm.jsp";
        var rootdir = this.ROOT_DIR = "";
        this.MAIN_LOGO_URL = "/img/main.png";
        this.SUB_LOGO_URL = "/img/sub.png";
        this.AJAX_ERROR_FUNC = null;
        this.AJAX_SESSION_EXPIRED = null;
        this.NOT_INSTALLED_UBIKEY = null;
        this.CANCEL_DIALOG = null;
        this.CANCEL_SUB_DIALOG = null;
        this.INVALID_PASSWORD_EXCESS = null;

        /* check nos */
        this.usingNosAdapter = false;

        /* EnvCert */
        this.isSaveServerCert = false;
				
				/* check is SubView */
				this.isSubView = false;
				
        /* Constants */
        this.success = 0;
        this.error = -1;

        /* Media List */
        this.media = {
            hardDisk: 0,
            removableDisk: 1,
            pkcs11: 2,
            mobile: 3,
            savetoken: 4
        };

        /* Media Enable */
        this.mediaOpt = 0xFF;
				this.invisibleMedia = 0x00;
        /* Media Enable Mask Value */
        this.enable = {
            all: 0xFF,
            harddisk: 0x10,
            remdisk: 0x08,
            savetoken: 0x04,
            pkcs11: 0x02,
            mobile: 0x01
        };

        /* the key for logs */
        //this.logkey = undefined;

        /**
         * 현재 선택된 인증서 종류
         *
         * @type {Object}
         */
        this.selectCertOpt = {
            CERTLIST_ALL: 0x003B01,
            CERTLIST_NPKI: 0x002801,
            CERTLIST_GPKI: 0x001A01,

            ADMIN_CERTLIST_ALL: 0x003B81,
            ADMIN_CERTLIST_NPKI: 0x002881,
            ADMIN_CERTLIST_GPKI: 0x001A81,

            CERTLIST_ENC_ALL: 0x003701,
            CERTLIST_ENC_NPKI: 0x002401,
            CERTLIST_ENC_GPKI: 0x001701
        };
        /**
         *
         * Ubikey 사용자들 강제 업데이트를 위한 변수 추가 2017-06-21 DYLEE
         * Variable {Boolean} isUseUbikey : 유비키 사용자는 Version 1.3.8 이상인지 체크 플래그
         * Variable {Function} INVALID_VERSION_FOR_UBIKEYUSER : 에러 콜백을 위한 변수, 해당 변수는 init시 넘어오는 Error와 동일한 것으로 사용
         *
         */
        this.isUseUbikey = false;
        this.INVALID_VERSION_FOR_UBIKEYUSER = null;
				
        /* debug status */
        this.debug = false;
        /* Certificate Policies */
        this.certPolices = [];

        /* Identifier List */
        this.id = {
            dialog: {
                cert: "kc_dialog_default",
                viewCert: "kc_dialog_viewCert",
                pkcs11: "kc_dialog_pkcs11",
                pkcs12IE: "kc_dialog_pkcs12_ie",
                pkcs12Con: "kc_dialog_pkcs12_con",
                media: "kc_dialog_media",
                changePw: "kc_dialog_changePw",
                file: "kc_dialog_file",
                pw: "kc_dialog_pw",
                drive: "kc_dialog_drive",
                load: "kc_dialog_load",
                pin: "kc_dialog_pin",
                stpw: "kc_dialog_stoken_pw",
                saveToken: "kc_dialog_savetoken",
                issueCode: "kc_dialog_issuecode",
                createPw: "kc_dialog_createPw",
                reason: "kc_dialog_reason",
                permitCode: "kc_dialog_permit_code",
                vid: "kc_dialog_vid"
            },
            title: "kc_dialog_title",
            certPosTable: "kc_cert_position",
            certList: "kc_cert_list",
            certType: "kc_cert_type",
            certCa: "kc_cert_ca",
            content: {
                cert: "kc_content_default",
                admin: "kc_content_admin"
            },
            tabList: "kc_viewverify_tablist",
            tabCommon: "kc_tab_common",
            tabDetail: "kc_tab_detail",
            p12Name: "pkcs12_file_name",
            sslCertPath: "ssl_cert_path",
            certKeyPath: "cert_key_path",
            p12Path: "pkcs12_file_path"
        };

        /* CSS Class Name */
        this.cs = {
            subDlgTitle: "kc-dialog-title",
            mainDlgTitle: "kc-dialog-title2",
            dlgClose: "kc-dialog-close",
            btnLayout: "kc-buttons-layout",
            pwBox: "kc-pw-box",
            btnPressed: "kc-rbg-pressed",
            btnNormal: "kc-rbg-normal",
            dropdownMenu: "kc-dropdown-menu",
            mediaSpan: "kc-media-span",
            dropdownGrp: "kc-dropdown-group",
            icoRemovable: "kc-ico-removable",
            rgbText: "kc-rbg-text",
            certSelectedRow: "kc-tableview-selected-row",
            certTableCell: "kc-tableview-cell",
            fontb: "kc-fontb",
            wrdNormal: "kc-wrd-normal",
            tableView: "kc-tableview",
            p11List: "kc-pkcs11-list",
            stList: "kc-savetoken-list",
            mediaList: "kc-medialist",
            fileList: "kc-filelist",
            widget: "kc-cert-widget",
            certExpired: "kc-expire-msg",
            certRenew: "kc-renew-msg"
        };

        /* Title Name */
        this.title = {
            cert: "인증서 입력 (전자서명)",
            admin: "인증서 관리",
            renewal: "인증서 갱신",
            keyRenewal: "인증서 키갱신",
            suspension: "인증서 효력정지",
            abolition: "인증서 폐지"
        };

        /* Strings */
        this.strings = {
            IS_LOADING: "",
            EXPIRED_SESSION: "세션이 만료되었습니다. 다시 접속해주십시오.",
            NOT_INIT: "보안모듈이 실행중이 아닙니다.",
            CONFIRM_INSTALL: "설치페이지로 이동하시겠습니까?",
            CONFIRM_DELETE: "인증서를 삭제할 경우 이 인증서로 암호화된 데이터를 해독할 수 없습니다.\r\n인증서 삭제는 서명용 인증서와 암호화용(키관리용) 인증서 그리고 개인키 모두를 삭제합니다.\r\n만약의 경우를 대비하여 인증서를 백업 후 삭제하시기를 권고해 드립니다.\r\n인증서 및 개인키를 영구히 삭제하시겠습니까?",
            CERT_VAL_SUCCESS: "이 인증서의 전자서명이 올바릅니다.",
            NOT_CONNECTED_PKCS11: "표준보안매체가 올바로 인식되지 않았습니다.\n표준보안매체를 다시 한 번 점검하십시오.",
            NOT_SELECTED_CERT: "인증서가 선택되지 않았습니다.",
            NOT_SELECTED_SAVETOKEN: "저장토큰이 선택되지 않았습니다.",
            NOT_SELECTED_PKCS11: "보안토큰이 선택되지 않았습니다.",
            NOT_SELECTED_FILE: "파일이 선택되지 않았습니다.",
            NO_INPUT_PASSWORD: "인증서 비밀번호를 입력해주십시오.",
            NO_KEYBOARD_SECURITY: "키보드 보안이 로드되지 않았습니다.",
            NO_INPUT_PIN: "보안토큰 PIN 번호를 입력해주십시오.",
            NO_INPUT_ST: "저장토큰 비밀번호를 입력해주십시오.",
            CERT_DELETE_SUCCESS: "인증서가 삭제되었습니다.",
            CERT_COPY_SUCCESS: "인증서가 복사 되었습니다.",
            CERT_CHANGE_PASSWORD: "비밀번호가 변경 되었습니다.",
            CERT_EXPORT_SUCCESS: "인증서 내보내기 성공",
            CERT_IMPORT_SUCCESS: "인증서 가져오기 성공",
            CERT_CONVERT_SUCCESS: "인증서 변환 성공",
            CERT_ISSUSE_SUCCESS: "인증서 발급 성공",
            CERT_RENEWAL_SUCCESS: "인증서 갱신 성공",
            CERT_KEYRENEWAL_SUCCESS: "인증서 키 갱신 성공",
            CERT_SUSPENSION_SUCCESS: "인증서 효력정지 성공",
            CERT_ABOLITION_SUCCESS: "인증서 폐지 성공",
            NOT_EXIST_DISK: "이동식 디스크가 없습니다.",
            VERSION_DIFF: "KCaseAgent 버전이 일치하지 않습니다."
        };

        /* Error Code */
        var errCode = this.errCode = {
            asn1: {
                INIT_FAILED: [0x1000, "OSS 초기화를 실패하였습니다."],
                INVALID_DATEFORMAT: [0x1001, "날짜 형식이 올바르지 않습니다."],
                EXTRACTRDN_FAILED: [0x1002, "인증서로부터 발급자 DN을 얻어올 수 없습니다."],
                EXTRACTEXTENSION_FAILED: [0x1003, "인증서로부터 확장필드를 얻어올 수 없습니다."],
                INVALID_CONTEXT: [0x1004, "라이브러리가 초기화되지 않았습니다."],
                INVALID_DATA: [0x1005, "입력값이 없거나 올바르지 않습니다."],
                ENC_FAILED: [0x1006,"ASN1 인코딩에 실패하였습니다."],
                DEC_FAILED: [0x1007,"인증서 비밀번호가 올바르지 않습니다."],  // ASN1 디코딩에 실패하였습니다.
                CPY_FAILED: [0x1008,"ASN1 복사에 실패하였습니다."],
                OSSERR_END: [0x1009,"OSS 에러가 발생하였씁니다."]
            },
            common: {
                FILE_OPEN_FAILED: [0x2000, "파일을 여는데 실패하였습니다."],
                FILE_READ_FAILED: [0x2001, "파일을 읽는데 실패하였습니다."],
                FILE_WRITE_FAILED: [0x2002, "파일을 쓰는데 실패하였습니다."],
                FILE_NOT_EXIST: [0x2003, "파일이 존재하지 않습니다."],
                FILE_NOT_CREATE: [0x2004, "파일을 생성할 수 없습니다."],
                MAKEDIR_ERROR: [0x2005, "디렉터리를 생성할 수 없습니다."],
                MEMORY_ALLOC_ERROR: [0x2006, "메모리 할당에 실패하였습니다."],
                INVALID_INPUTDATA: [0x2007, "입력값이 없거나 올바르지 않습니다."],
                //COMMON_LICENSE_TIME_EXPIRE: [0x2008, "라이브러리 사용 기한이 만료되었습니다."],
                BASE64ENC_ERROR: [0x2009, "Base64 인코딩에 실패하였습니다."],
                BASE64DEC_ERROR: [0x200A, "Base64 디코딩에 실패하였습니다."],
                PASSWD_COMBI_ERROR: [0x200B, "패스워드의 문자와 숫자조합이 올바르지 않습니다."],
                PASSWD_SAMENUM_ERRO: [0x200C, "패스워드에 같은 문자가 2자 이상입니다."],
                /*COMMON_LICENSE_NO_FILE: [0x200D, "라이센스 파일이 없습니다."],
                 COMMON_LICENSE_BAD: 0x200E,*/
                FILE_READ_PUBLICKEY_FAILED: [0x200F, "암호화용(키관리용)인증서의 공개키를 읽지 못했습니다."]
            },
            crypto: {
                INVALID_DATA: [0x3000, "입력값이 없거나 올바르지 않습니다."],
                //MEMORY_ERROR: [0x3001, "메모리 할당에 실패하였습니다."],
                KEYGEN_FAILED: [0x3002, "키 생성을 실패하였습니다."],
                KEYPAIRGEN_FAILED: [0x3003, "키쌍 생성을 실패하였습니다."],
                KEYENC_INVALID_MODE: [0x3004, "암호화 모드가 올바르지 않습니다."],
                ENC_INIT_FAILED: [0x3005, "암호화 Init을 실패하였습니다."],
                ENC_UPDATE_FAILED: [0x3006, "암호화 Update를 실패하였습니다."],
                ENC_FINAL_FAILED: [0x3007, "암호화 Final을 실패하였습니다."],
                ENC_UNKNOWN_ALGORITHM: [0x3008, "알 수 없는 암호화 알고리즘 입니다."],
                ENC_UNKNOWN_MODE: [0x3009, "알 수 없는 암호화 모드 입니다."],
                DEC_INIT_FAILED: [0x300A, "복호화 Init을 실패하였습니다."],
                DEC_UPDATE_FAILED: [0x300B, "복호화 Update를 실패하였습니다."],
                DEC_FINAL_FAILED: [0x300C, "복호화 Final을 실패하였습니다."],
                //DEC_UNKNOWN_ALGORITHM: 0x300D,
                //DEC_UNKNOWN_MODE: 0x300E,
                DIGEST_INIT_FAILED: [0x300F, "메시지 다이제스트 Init을 실패하였습니다."],
                DIGEST_UPDATE_FAILED: [0x3010, "메시지 다이제스트 Update를 실패하였습니다."],
                DIGEST_FINAL_FAILED: [0x3011, "메시지 다이제스트 Final을 실패하였습니다."],
                DIGEST_UNKNOWN_ALGORITHM: [0x3012, "알 수 없는 메시지 다이제스트 알고리즘 입니다."],
                MAC_INIT_FAILED: [0x3013, "MAC값 생성 Init을 실패하였습니다."],
                MAC_UPDATE_FAILED: [0x3014, "MAC값 생성 Update를 실패하였습니다."],
                MAC_FINAL_FAILED: [0x3015, "MAC값 생성 Final을 실패하였습니다."],
                MAC_UNKNOWN_ALGORITHM: [0x3016, "알 수 없는 MAC값 생성 알고리즘 입니다."],
                KEYENC_3DESCBC_FAILED: [0x3017, "키를 암호화하는데 실패하였습니다."],
                KEYDEC_3DESCBC_FAILED: [0x3018, "키를 복호화하는데 실패하였습니다."],
                KEYENC_RC2CBC_FAILED: [0x3019, "키를 암호화하는데 실패하였습니다."],
                KEYDEC_RC2CBC_FAILED: [0x301A, "키를 복호화하는데 실패하였습니다."],
                KEYDEC_BAD_KEYLENGTH: [0x301B, "키의 길이가 올바르지 않습니다."],
                PUB_ENC_FAILED: [0x301C, "공개키로 암호화 하는데 실패하였습니다."],
                PUB_DEC_FAILED: [0x301D, "공개키로 복호화 하는데 실패하였습니다."],
                PRI_ENC_FAILED: [0x301E, "비밀키로 암호화 하는데 실패하였습니다."],
                PRI_DEC_FAILED: [0x301F, "비밀키로 복호화 하는데 실패하였습니다."],
                ENCRYPTDATA_FAILED: [0x3020, "메시지에 대한 암호화를 실패했습니다."],
                DECRYPT_DATA_FAILED: [0x3021, "메시지에 대한 복호화를 실패했습니다."],
                GET_SESSIONKEY_FAILED: [0x3022, "세션키를 얻는데 실패했습니다."]
            },
            storage: {
                INVALID_CONTEXT: [0x4000, "라이브러리가 초기화되지 않았습니다."],
                INVALID_INPUTDATA: [0x4001, "입력값이 없거나 올바르지 않습니다."],
                INCORRECT_MEDIA: [0x4002, "매체 선택이 올바르지 않습니다."],
                INCORRECT_DATATYPE: [0x4003, "데이터 종류 선택이 올바르지 않습니다."],
                FILE_REMOVE_FAILED: [0x4004, "파일을 삭제하는데 실패하였습니다."],
                GET_USERINFO_SIGNPRIVKEY: [0x4005, "서명용 개인키를 읽는데 실패하였습니다."],
                GET_USERINFO_ENCPRIVKEY: [0x4006, "암호화용 개인키를 읽는데 실패하였습니다."],
                SET_USERINFO_DN: [0x4007, "사용자 DN 정보를 저장하는데 실패하였습니다."],
                SET_USERINFO_SIGNPRIVKEY: [0x4008, "서명용 개인키를 저장하는데 실패하였습니다."],
                SET_USERINFO_ENCPRIVKEY: [0x4009, "암호화용 개인키를 저장하는데 실패하였습니다."],
                GET_CERTINFO_SIGNCERT: [0x400A, "서명용 인증서를 읽는데 실패하였습니다."],
                GET_CERTINFO_ENCCERT: [0x400B, "암호화용 인증서를 읽는데 실패하였습니다."],
                GET_CERTINFO_CAPUBS: [0x400C, "인증경로를 읽는데 실패하였습니다."],
                SET_CERTINFO_SIGNCERT: [0x400D, "서명용 인증서 저장에 실패하였습니다."],
                SET_CERTINFO_ENCCERT: [0x400E, "암호화용 인증서 저장에 실패하였습니다."],
                SET_CERTINFO_CAPUBS: [0x400F, "인증경로를 저장하는데 실패하였습니다."],
                GET_COMMONINFO: [0x4010, "환경설정 정보를 가져오는데 실패하였습니다."],
                SET_COMMONINFO: [0x4011, "환경설정 정보를 저장하는데 실패하였습니다."],
                SET_REGISTRY: [0x4012, "레지스트리 값설정에 실패하였습니다."]
                /*INVALID_SC_PIN: 0x4013,
                 INVALID_SC_CONTEXT: 0x4014,
                 EXPIRED_SC_PIN: 0x4015,
                 SC_FAIL: 0x4016,
                 INVALID_USB_PIN: 0x4017,
                 INVALID_CRYPTOKI_PIN: 0x4018*/
            },
            validity: {
                INVALID_CONTEXT: [0x5000, "라이브러리가 초기화되지 않았습니다."],
                INVALID_INPUTDATA: [0x5001, "입력값이 없거나 올바르지 않습니다."],
                INVALID_CERTFORMAT: [0x5002, "인증서 형식이 올바르지 않습니다."],
                CERT_ENCODE_FAILED: [0x5003, "인증서 인코딩을 실패하였습니다."],
                CRL_ENCODE_FAILED: [0x5004, "인증서 폐지목록 인코딩을 실패하였습니다."],
                NOTEXIST_DP: [0x5005, "CRL 배포지점 정보가 없는 인증서입니다."],
                GET_DP_FAILED: [0x5006, "CRL 배포지점 정보를 가져오는데 실패하였습니다."],
                CERT_TIMEOUT: [0x5007, "인증서의 유효기간이 만료되었습니다."],
                CERT_SIGNATURE_ERROR: [0x5008, "인증서의 발급자 서명 검증에 실패했습니다."],
                CRL_SIGNATURE_ERROR: [0x5009, "인증서 폐지목록의 발급자 서명 검증에 실패했습니다."],
                CERT_REVOKED: [0x500A, "인증서가 폐지되었습니다."],
                INVALID_NAMECHAIN: [0x500B, "인증서 경로의 발급자, 피발급자 이름 체인이 잘못되었습니다."],
                NOTEXIST_POLICYCONSTRAINTSEX: [0x500C, "인증서 정책 제한 확장이 존재하지 않습니다."],
                POLICY_INCOMPATIBLE_WITHIPS: [0x500D, "인증서 정책이 초기 인증서 정책과 부합되지 않습니다."],
                POLICY_INCOMPATIBLE_WITHAPS: [0x500E, "정책이 허용가능 정책 집합에 부합되지 않습니다."],
                NOTEXIST_BASICCONSTRAINTEXT: [0x500F, "발급자 인증서에 기본 제한 확장이 없습니다."],
                NOT_CACERT: [0x5010, "발급자 인증서가 아닙니다."],
                CAPATHLEN_ERROR: [0x5011, "발급자 인증경로 길이 제약에 어긋납니다."],
                EKU_INCOMPATIBLE_WITHKU: [0x5012, "확장 키사용 용도와 키사용 용도가 일치하지 않습니다."],
                IPS_INCOMPATIBLE_WITHAPS: [0x5013, "허용가능 정책과 초기 정책이 부합되지 않습니다."],
                INCONSISTENT_WITHCS: [0x5014, "주체 이름과 주체대체이름 확장이 CS와 부합되지 않습니다."],
                INCONSISTENT_WITHES: [0x5015, "주체 이름과 주체대에이름 확장이 ES와 부합되지 않습니다."],
                NAME_ADJUST_ERROR: [0x5016, "인코딩된 이름 제약(Naming Constraint) 확장이 적합하지 않습니다."],
                KEYUSAGE_ERROR: [0x5017, "인증서의 키용도가 입력된 키용도와 부합되지 않습니다."],
                SIGNATURE_MISMATCHED: [0x5018, "서명값이 일치하지 않습니다."],
                NOTEXIST_CERTCRLLIST: [0x5019, "인증서/폐지목록 리스트의 입력이 없습니다."],
                INVALID_CRLFORMAT: [0x501A, "인증서 폐지목록 형식이 올바르지 않습니다."],
                CRL_TIMEOUT: [0x501B, "인증서 폐지목록의 유효 기간이 만료되었습니다."],
                ARL_TIMEOUT: [0x501C, "인증기관 인증서 폐지목록의 유효 기간이 만료 되었습니다."],
                GET_VALIDCRL_FAILED: [0x501D, "유효한 인증서 폐지목록이 존재하지 않습니다."],
                GET_CADSINFO_FAILED: [0x501E, "발급자 인증서의 디렉토리 서버 정보가 없습니다."],
                GET_DSINFO_FAILED: [0x501F, "디렉토리 서버 정보가 없습니다."],
                DS_NOTCONNECTED: [0x5020, "디렉토리 서버에 연결할 수 없습니다."],
                DS_NO_CERT: [0x5021, "디렉토리 서버에서 인증서를 검색할 수 없습니다."],
                DS_NO_ISSUERCERT: [0x5022, "디렉토리 서버에서 발급자 인증서를 검색할 수 없습니다."],
                DS_NO_CERTATTRIBUTE: [0x5023, "디렉토리 서버의 DN 엔트리에 인증서가 아직 올라가지 않았습니다."],
                DS_NO_ISSUERCERTATTRIBUTE: [0x5024, "디렉토리 서버의 DN 엔트리에 발급자 인증서가 아직 올라가지 않았습니다."],
                DS_NO_VALIDCERT: [0x5025, "디렉토리 서버에서 유효한 인증서를 검색할 수 없습니다."],
                DS_NO_VALIDISSUERCERT: [0x5026, "디렉토리 서버에서 유효한 발급자 인증서를 검색할 수 없습니다."],
                DS_NO_MATCHKEYUSAGE_CERT: [0x5027, "디렉토리 서버에서 키사용 용도에 맞는 인증서를 검색할 수 없습니다."],
                CTL_INVALID: [0x5028, "인증서 신뢰목록 형식이 올바르지 않습니다."],
                CTL_TIMEOUT: [0x5029, "인증서 신뢰목록의 유효기간이 시간이 올바르지 않습니다."],
                DS_NO_CTL: [0x502A, "디렉토리 서버에서 유효한 인증서 신뢰목록(CTL)을 검색하는데 실패하였습니다."],
                DS_NO_CTL_ATTRIBUTE: [0x502B, "디렉토리 서버에서 검색한 엔트리에 아직 인증서 신뢰목록(CTL) 필드가 올라가지 않습니다."],
                HASH_FAILED: [0x502C, "해쉬값 생성을 실패하였습니다."],
                NOTSET_INITIALPOLICY: [0x502D, "초기 허용 정책 설정이 없습니다."],
                UPDATECRL_FAILED: [0x502E, "인증서 폐기목록 갱신에 실패했습니다."],
                GENCAPUBS_NOTEXISTISSUER: [0x502F, "인증경로 생성에 필요한 발급자 인증서가 없습니다."],
                NOTEXIST_OIDDSMAPLIST: [0x5030, "환경 설정에 OID DS MAP 정보가 없습니다."],
                ROOT_CERT_INVALID: [0x5031, "인증서의 유효성 검증을 실패하였습니다. 신뢰된 최상위인증기관 인증서가 아닙니다."],
                CRITICAL_ALLCHECK_FAILED: [0x5032, "Critical 확장을 모두 검사하지 못하였습니다."],
                CERT_REVOKED_HOLD: [0x5033, "인증서가 효력정지 되었습니다."],
                CERT_REVOKED_KEYCOMPROMISE: [0x5034, "인증서가 개인키 신뢰 손상으로 폐지되었습니다."],
                CERT_REVOKED_AFFCHANGED: [0x5035, "인증서가 소속이나 이름 변경으로 폐지되었습니다."],
                CERT_REVOKED_CESSATIONOFOPER: [0x5036, "인증서가 사용 해지로 폐지되었습니다."],
                NO_CRL: [0x5037, "디렉토리 서버에 조건에 맞는 인증서 폐지목록(CRL)이 없습니다."],
                NO_ARL: [0x5038, "디렉토리 서버에 조건에 맞는 인증서 폐지목록(ARL)이 없습니다."],
                NO_VALID_CRL: [0x5039, "디렉토리 서버에서 유효한 인증서 폐지목록(CRL)을 검색하는데 실패하였습니다."],
                NO_VALID_ARL: [0x503A, "디렉토리 서버에서 유효한 인증서 폐지목록(ARL)을 검색하는데 실패하였습니다."],
                NO_CRL_ATTRIBUTE: [0x503B, "디렉토리 서버에서 검색한 엔트리에 아직 인증서 폐지목록(CRL) 필드가 올라가지 않습니다."],
                NO_ARL_ATTRIBUTE: [0x503C, "디렉토리 서버에서 검색한 엔트리에 아직 인증서 폐지목록(ARL) 필드가 올라가지 않습니다."],
                NO_EMAIL_ENTRY: [0x503D, "디렉토리 서버에 mail 엔트리가 존재하지 않습니다."],
                NO_CN_ENTRY: [0x503E, "디렉토리 서버에 cn 엔트리가 존재하지 않습니다."],
                INCORRECT_DN: [0x503F, "DN 형식이 올바르지 않습니다."],
                INCORRECT_DSTYPE: [0x5040, "디렉토리 서버 종류가 올바르지 않습니다."],
                OCSP_NOINPUT_ISSUERCERT: [0x5041, "발급자 인증서가 없습니다."],
                OCSP_NOTEXIST_SERVERINFO: [0x5042, "서버 정보가 없습니다."],
                OCSP_NOINPUT_GENSIGNINFO: [0x5043, "인증서 상태검증 요청 메시지를 서명할 인증서/비밀키 입력이 없습니다."],
                OCSP_NONCEERROR: [0x5044, "Nonce 값이 확인되지 않습니다."],
                OCSP_INVALID_SERIALNUM: [0x5045, "요청 메시지와 응답 메시지의 인증서 일련번호가 일치하지 않습니다."],
                OCSP_INVALID_RESPONSETYPE: [0x5046, "응답 메시지 형식이 올바르지 않습니다."],
                OCSP_VERSION_ERROR: [0x5047, "응답 메시지의 메시지 버전이 지원되지 않습니다."],
                OCSP_MALFORMED_REQUEST: [0x5048, "잘못된 요청 메시지 입니다."],
                OCSP_INTERNAL_ERROR: [0x5049, "서버 내부 에러로 작업을 진행할 수 없습니다."],
                OCSP_TRY_LATER: [0x504A, "서버 내부 에러로 작업을 진행할 수 없습니다."],
                OCSP_SIG_REQUIRED: [0x504B, "요청 메시지의 서명값을 검증할 수 없습니다."],
                OCSP_UNAUTHORIZED: [0x504C, "신뢰할 수 없는 사용자 입니다."],
                OCSP_FAILED: [0x504D, "상태 검증에 실패하였습니다."],
                OCSP_UNKNOWN_CHOSEN: [0x504E, "상태 검증에 실패하였습니다."],
                OCSP_NOINPUT_REQCERT: [0x504F, "요청 인증서가 없습니다."],
                OCSP_NO_AIAVALUE: [0x5050, "AIA 필드 값이 없습니다."],
                OCSP_EXIST_AIAVALUE: [0x5051, "AIA 필드 값이 있습니다."],
                OCSP_FAIL_CONFIG_ENVIRONMENT: [0x5052, "환경 설정 파일 읽을 수 없습니다."],
                OCSP_STATUS_GOOD: [0x5053, "인증서 상태는 유효합니다."],
                OCSP_STATUS_REVOKED: [0x5054, "인증서가 폐지 되었습니다."],
                OCSP_STATUS_UNKNOWN: [0x5055, "인증서 상태를 알 수 없습니다."],
                OCSP_SAMERESSRVRADDR: [0x5056, "요청 서버와 응답 서버가 동일합니다."],
                NOTEXIST_OCSPSVRLIST: [0x5057, "환경 설정에 OCSP 서버정보 리스트 설정이 없습니다."],
                NOTEXIST_TRUSTED_ROOTCA: [0x5058, "신뢰된 최상위 인증기관 인증서가 없습니다."],
                INVALIDFORMAT_TRUSTED_ROOTCA: [0x5059, "신뢰된 최상위 인증기관 인증서 형식이 올바르지 않습니다."],
                NO_AKI: [0x505A, "인증서의 AKI 필드가 없습니다."],
                NO_AKI_KI: [0x505B, "인증서의 AKI 필드에 KeyIdentifier가 없습니다."],
                NO_AKI_ACI: [0x505C, "인증서의 AKI 필드에 authorityCertIssuer가 없습니다."],
                NO_AKI_ACSN: [0x505D, "인증서의 AKI 필드에 authorityCertSerialNumber가 없습니다."],
                AKI_COMPARE_FAIL: [0x505E, "상위 인증서와 AKI 필드값 비교에 실패하였습니다."],
                CERT_REVOKED_HOLD_CA: [0x505F, "발급자 인증서가 효력정지 되었습니다."],
                CERT_REVOKED_KEYCOMPROMISE_CA: [0x5060, "발급자 인증서가 개인키 신뢰 손상으로 폐지되었습니다."],
                CERT_REVOKED_AFFCHANGED_CA: [0x5051, "발급자 인증서가 소속이나 이름 변경으로 폐지되었습니다."],
                CERT_REVOKED_CESSATIONOFOPER_CA: [0x5052, "발급자 인증서가 사용 해지로 폐지되었습니다."],
                CERT_REVOKED_CACOMPROMISE_CA: [0x5053, "발급자 인증서의 발급자 인증서의 전자서명키가 손상으로 폐지되었습니다."],
                CERT_REVOKED_SUPERSEDED_CA: [0x5054, "발급자 인증서의 키 손상없이 인증서가 폐지되었습니다."],
                CERT_REVOKED_UNSPECIFIED_CA: [0x5055, "발급자 인증서가 특별한 폐지사유 없이 폐지되었습니다."],
                CERT_REVOKED_REMOVEFROMCRL_CA: [0x5056, "발급자 인증서가 Delta CRL에서 제거 되었습니다."],
                CERT_REVOKED_CA: [0x5057, "발급자인증서가 폐지되었습니다."],
                CERT_REVOKED_CACOMPROMISE: [0x5058, "발급자 인증서의 전자서명키가 손상으로 폐지되었습니다."],
                CERT_REVOKED_SUPERSEDED: [0x5059, "키 손상없이 인증서가 폐지되었습니다."],
                CERT_REVOKED_UNSPECIFIED: [0x505A, "인증서가 특별한 폐지사유 없이 폐지되었습니다."],
                CERT_REVOKED_REMOVEFROMCRL: [0x505B, "인증서가 Delta CRL에서 제거 되었습니다."],
                KEYUSAGE_NOT_EXIST: [0x505C, "인증서의 KEYUSAGE 확장 필드가 존재하지 않습니다."],
                KEYUSAGE_NOT_EXIST_CA: [0x505D, "발급자 인증서의 KEYUSAGE 확장 필드가 존재하지 않습니다."],
                CRYPTOKI_FAIL_CONFIG_ENVIRONMENT: [0x505E, "환경 설정 파일 읽을 수 없습니다."],
                KCE_CV_CERT_REVOKED_SUPERSEDED: [0x5069, "키 손상없이 인증서가 폐지되었습니다."]
            },
            pkcs: {
                INVALID_CONTEXT: [0x6000, "라이브러리가 초기화되지 않았습니다."],
                INVALID_INPUTDATA: [0x6001, "입력값이 없거나 올바르지 않습니다."],
                INVALID_CAPUBSFORMAT: [0x6002, "인증서 경로 형식이 올바르지 않습니다."],
                INCORRECT_HASHALGORITHM: [0x6003, "해쉬 알고리즘 선택이 올바르지 않습니다."],
                INCORRECT_ALGOID: [0x6004, "정의되지 않은 알고리즘입니다."],
                TOOLONG_KEYSIZE: [0x6005, "키의 길이가 올바르지 않습니다."],
                HASH_FAILED: [0x6006, "해쉬값 생성을 실패하였습니다."],
                PBE_ENC_FAILED: [0x6007, "비밀키를 암호화하는데 실패하였습니다."],
                PBE_DEC_FAILED: [0x6008, "인증서 비밀번호가 올바르지 않습니다."],//"비밀키를 복호화하는데 실패하였습니다."],
                GEN_PKCS12BAGATTR_FAILED: [0x6009, "PKCS12 속성을 생성하는데 실패하였습니다."],
                VERIFY_PKCS12MAC_FAILED: [0x600B, "PKCS12 MAC값 검증을 실패하였습니다."],
                GEN_PKCS12MAC_FAILED: [0x600A, "PKCS12 MAC값을 생성하는데 실패하였습니다."],
                INCORRECT_CMSTYPE: [0x600C, "메시지 형식이 올바르지 않습니다."],
                UNKNOWN_CMSTYPE: [0x600D, "메시지 형식이 지원되지 않습니다."],
                INVALID_CAPUBS: [0x600E, "인증경로 입력이 없습니다."],
                NOTEXIST_SIGNERINFO: [0x600F, "서명 데이터에 서명자 정보가 없습니다."],
                NOINPUT_SIGNERCERT: [0x6010, "서명 검증을 위한 서명자의 인증서 입력이 없습니다."],
                NOINPUT_SIGNORIMSG: [0x6011, "서명 검증을 위한 원본 메시지 입력이 없습니다."],
                NOINPUT_DIGESTORIMSG: [0x6012, "메시지 축약(다이제스트) 검증을 위한 원본 메시지 입력이 없습니다."],
                NOTEXIST_DIGESTVALUE: [0x6013, "메시지 축약(다이제스트) 데이터에 축약 데이터(다이제스트)가 포함되어 있지 않습니다."],
                DIGESTVALUE_MISMATCHED: [0x6014, "메시지 축약(다이제스트)이 일치하지 않습니다."],
                NOTEXIST_DIGESTCONTENTS: [0x6015, "메시지 축약(다이제스트) 데이터에 원문 메시지가 포함되어 있지 않습니다."],
                GEN_MAC_FAILED: [0x6016, "MAC 값을 생성하는데 실패하였습니다."],
                VERIFY_MAC_FAILED: [0x6017, "MAC 값 검증을 실패하였습니다."],
                NOINPUT_AUTHORIMSG: [0x6018, "메시지 인증(MAC) 검증을 위한 원본 메시지 입력이 없습니다."],
                NOTEXIST_AUTHVALUE: [0x6019, "메시지 인증(MAC) 데이터에 메시지 인증(MAC)이 포함되어 있지 않습니다."],
                NOTEXIST_CONTENTS: [0x601A, "서명 데이터에 원문이 포함 되어있지 않습니다."],
                NOTEXIST_SIGNERCERT: [0x601B, "서명 데이터에 서명자의 인증서가 포함 되어있지 않습니다."],
                NOTEXIST_RECIPIENTINFO: [0x601C, "암호화 데이터에 수신자 정보가 포함 되어있지 않습니다."],
                INVALID_VERSION: [0x601D, "버전이 올바르지 않습니다."],
                // Password 오류 횟수 제한 관련 ErrMsg 추가
                INVALID_PASSWORD_EXCESS: [0x601E, "비밀번호 오류 횟수를 초과하였습니다. 브라우저 종료 후 일정시간 이후 다시 접속해주시길 바랍니다."]
            },
            cert: {
                INVALID_CONTEXT: [0x7000, "라이브러리가 초기화되지 않았습니다."],
                INVALID_INPUTDATA: [0x7001, "입력값이 없거나 올바르지 않습니다."],
                INCORRECT_CERTTYPE: [0x7002, "인증서 종류 선택이 올바르지 않습니다."],
                INCORRECT_KEYTYPE: [0x7003, "비밀키 종류 선택이 올바르지 않습니다."],
                READ_PRIVKEY_FAILED: [0x7004, "비밀키를 읽는데 실패했습니다."],
                WRITE_PRIVKEY_FAILED: [0x7005, "비밀키를 저장하는데 실패했습니다."],
                READ_CERT_FAILED: [0x7006, "인증서를 읽어오는데 실패하였습니다."],
                WRITE_CERT_FAILED: [0x7007, "인증서를 저장하는데 실패하였습니다."],
                WRITE_CERTPATH_FAILED: [0x7008, "인증서 경로를 저장하는데 실패하였습니다."],
                INCORRECT_MEDIA: [0x7009, "매체 선택이 올바르지 않습니다."],
                NOTEXIST_SET_CALIST: [0x700A, "환경 설정에 인증기관 리스트 설정이 없습니다."],
                NOTEXIST_SET_MEDIALIST: [0x700B, "환경 설정에 매체 리스트 설정이 없습니다."],
                NOTEXIST_MEDIAINFO: [0x700C, "매체 정보 설정이 없습니다."],
                NOTEXIST_CERTCRLLIST: [0x700D, "인증서/폐지목록 리스트의 입력이 없습니다."],
                NOTEXIST_DSINFO: [0x700E, "인증서를 검색하기 위한 디렉토리 서버 정보가 없습니다."],
                NOTEXIST_ROOTCA_INCAPUBS: [0x700F, "인증 경로에 최상위 인증기관 인증서가 포함되어 있지 않습니다."],
                NO_RANDOM_VALUE: [0x7010, "인증서 저장에 실패하였습니다. 고객센터로 문의해 주세요."],
                VID_MISMATCHED: [0x7011, "신원확인 정보가 일치하지 않습니다."],
                OCSP_CONF_ERROR: [0x7012, "환경설 파일(OCSP.conf)이 없습니다."],
                KCASE_CONF_ERROR: [0x7013, "환경설정파일(AxKCASE.ini)이 없습니다."],
                EXCEED_FILE_SIZE: [0x7014, "허용가능한 용량을 초과하였습니다"]                
            },
            agent: {
                INIT_CONTEXT_ERROR: [0x8000, "KCASE Context 초기화에 실패했습니다."],
                INPUT_UNKNOWN_FLAG: [0x8001, "옵션 FLAG 값이 올바르지 않습니다."],
                INPUT_DATA_ERROR: [0x8002, "입력값이 올바르지 않습니다."],
                INPUT_PW_ERROR: [0x8003, "인증서 패스워드 입력값이 올바르지 않습니다."],
                INPUT_DN_ERROR: [0x8004, "인증서 DN 입력값이 올바르지 않습니다."],
                INPUT_IDN_ERROR: [0x8005, "개인 식별번호 입력값이 올바르지 않습니다."],
                INPUT_CERTTYPE_ERROR: [0x8006, "인증서 타입이 올바르지 않습니다."],
                GET_CERT_ERROR: [0x8007, "인증서를 읽어오는데 실패했습니다."],
                GET_KEY_ERROR: [0x8008, "개인키를 읽어오는데 실패했습니다."],
                INPUT_SIGNDN_ERROR: [0x8009, "서명용 인증서 DN 입력값이 올바르지 않습니다."],
                INPUT_SIGNPW_ERROR: [0x800A, "서명용 인증서 비밀번호 입력값이 올바르지 않습니다."],
                INPUT_SIGNTYPE_ERROR: [0x800B, "서명 옵션(파일/문자열)이 올바르지 않습니다."],
                INPUT_SIGN_FILE_ERROR: [0x800C, "서명할 파일명이 올바르지 않습니다."],
                INPUT_SIGN_DATA_ERROR: [0x800D, "서명할 데이터(길이)가 올바르지 않습니다."],
                INPUT_VERIFY_FILE_ERROR: [0x800E, "검증할 파일명이 올바르지 않습니다."],
                INPUT_VERIFY_DATA_ERROR: [0x800F, "검증할 데이터(길이)가 올바르지 않습니다."],
                GET_SIGNER_CERT_ERROR: [0x8010, "서명 문서에서 서명자 인증서를 가져오는데 실패했습니다."],
                INPUT_ENCDN_ERROR: [0x8011, "암호화용(키관리용) 인증서 DN 입력값이 올바르지 않습니다."],
                INPUT_ENC_FILE_ERROR: [0x8012, "암호화할 파일명이 올바르지 않습니다."],
                INPUT_ENC_DATA_ERROR: [0x8013, "암호화할 데이터(길이)가 올바르지 않습니다."],
                INPUT_ENCTYPE_ERROR: [0x8014, "암호 옵션(파일/문자열)이 올바르지 않습니다."],
                INPUT_ENCPW_ERROR: [0x8015, "암호화용(키관리용) 인증서 비밀번호 입력값이 올바르지 않습니다."],
                INPUT_ENCDATA_ERROR: [0x8016, "복호화할 데이터의 입력값이 올바르지 않습니다."],
                INPUT_DEC_FILE_ERROR: [0x8017, "복호화할 파일명이 올바르지 않습니다."],
                INPUT_DEC_DATA_ERROR: [0x8018, "복호화할 데이터가 올바르지 않습니다."],
                INPUT_DECTYPE_ERROR: [0x8019, "복호화 옵션(파일/문자열)이 올바르지 않습니다."],
                CONFIG_PKITYPE_ERROR: [0x801A, "PKI Type 정보가 올바르지 않습니다."],
                CONFIG_ENCPRI_ALGO_ERROR: [0x801B, "개인키 암호 알고리즘 정보가 올바르지 않습니다."],
                HASH_DIFF_ERROR: [0x801C, "KCaseAgent 해시값이 일치하지 않습니다."],
                VERSION_DIFF_ERROR: [0x801D, "KCaseAgent 버전이 일치하지 않습니다."],
                NO_REMOVABLEDISK: [0x801E, "이동식 디스크가 존재하지 않습니다."],
                MOBILECERT_CANCEL: [0x8020, "휴대폰 인증서 서비스 진행을 취소하였습니다."],
                UNINITIALIZED_KEY: [0x8022, "키와 IV가 초기화되지 않았습니다."],
                NO_INSTALL: [0x8023, "KCaseAgent가 설치되어 있지 않습니다."],
                NOT_ESTABLISH_SECURITY_CHANNEL: [0x8024, "채널 보안이 형성되지 않았습니다"]
            },
            pkcs11: {
                DEVICE_ERROR: [0x9000, "보안토큰 매체에 알수 없는 문제점이 발생했습니다"],
                DEVICE_REMOVED: [0x9001, "보안토큰이 실행 도중 제거 되었습니다"],
                TOKEN_NOT_PRESENT: [0x9002, "보안토큰이 존재하지 않습니다"],
                NOT_INITIALIZED: [0x9003, "보안토큰이 초기화 되지 않았습니다"],
                KEY_HANDLE_INVALID: [0x9004, "보안토큰 키 핸들이 맞지 않습니다."],
                OBJECT_HANDLE_INVALID: [0x9005, "지정된 오브젝트 핸들이 맞지 않습니다."],
                PIN_INCORRECT: [0x9006, "핀번호가 맞지 않습니다"],
                PIN_LEN_RANGE: [0x9007, "보안토큰에서 지원하는 핀길이보다 길거나 짧습니다."],
                PIN_LOCKED: [0x9008, "핀번호 오류로 인하여 보안토큰이 잠겼습니다."],
                SESSION_NOT_SUPPORT: [0x9009, "보안토큰 세션이 올바르지 않습니다"],
                USER_NOT_LOGGED_IN: [0x900A, "보안토큰에 로그인 되지 않았습니다"]
            },
            pkimgr: {
                ISSUE_SERVER: [0xA001, ""],
                FILE_PERMISSION: [0xA002, "파일의 권한 또는 숨김여부 등으로 인하여 작업을 수행 할 수가 없습니다.\n해당파일의 권한을 확인하여 주시기 바랍니다.\n파일위치 : "],
                PASSOWRD_COMPLEXITY: [0xA003, "입력한 인증서 패스워드가 복잡도 권장사항에 부합되지 않습니다."],
                RENEW_ERROR: [0xA004, "인증서 갱신(또는 키갱신)에 실패하였습니다.\n다음 파일이 누락되었습니다. : "],
                SUSPENSION_ERROR: [0xA005, "인증서 효력정지에 실패하였습니다.\n다음 파일이 누락되었습니다. : "],
                ABOLITION_ERROR: [0xA006, "인증서 폐지에 실패하였습니다.\n다음 파일이 누락되었습니다. : "],
                OVERLAP_ERROR: [0xA007, "중복된 요청입니다. \n요청정보를 다시 확인 하여 주시기 바랍니다."],
                PRIKEY_ERROR: [0xB01F, "개인키 파일이 손상되었습니다."]
            }
        };

        var errTable = {};

        var objs = util.getOwnPropertyNames(errCode);
        for (var i in objs) {
            var props = errCode[objs[i]];
            for(var j in props) {
                errTable[props[j][0]] = props[j][1];
            }
        }

        this.getErrorMsg = function(errorCode) {
            var msg = errTable[errorCode];

            if(msg === undefined) {
                msg = "알 수 없는 에러가 발생했습니다.";
            }
            return msg;
        };
    }

    function initDialog() {
        var dialogObj = new Object();

        var _selectedCertPos = 0;

        /**
         * Class List
         */
        function _makeDialog(option) {
            var tempDialog, msg = "다이얼로그 ID가 없습니다.";

            if (option.id == undefined) {
                throw msg;
                return;
            }

            tempDialog = new Dialog(option);

            dialogObj[option.id] = tempDialog;

            return tempDialog;
        }

        function _getDialog(id) {
            return dialogObj[id];
        }

        var DialogBase = function (options) {
            var position;

            if (options.id != prop.id.dialog.cert && options.id != prop.id.dialog.viewCert)
            {
                position = {
                    my: "center",
                    at: "top",
                    of: kcaseQuery("#" + prop.id.dialog.cert)
                };
            }

            var dlg = kcaseQuery("#" + options.id).kcDialog({
                autoOpen: false,
                resizable: false,
                modal: true,
                mainTitle: options.mainTitle,
                width: options.width,
                height: options.height,
                position: position,
                close: options.close
            });
            return dlg;
        };

        var Dialog = function (option) {
            var dialog;

            var options = {
                id: undefined,
                width: 450,
                height: 585,
                mainTitle: false,
                position: undefined,
                open: function () {
                },
                close: function () {
                }
            };

            /* 옵션 파라미터 처리 */
            if (option !== undefined) {
                util.setOption(options, option);
            }

            dialog = new DialogBase(options);

            this.open = function (p) {
                options.open(p);
                dialog.kcDialog("open");
            };

            this.close = function () {
                dialog.kcDialog("close");
            };

            this.setPosition = function (p) {
                dialog.kcDialog({
                    position: p
                });
            };

            this.setTitle = function (title) {
                kcaseQuery(".kc-dialog-title2 h3").text(title);
            };

            this.setHeight = function (h) {
                dialog.kcDialog("option", "height", h);
            };

            this.setBottomBtns = function (btnNum, opt) {
                var opts = {
                    event: undefined,
                    show: true,
                    name: undefined
                };
                if (option !== undefined) {
                    util.setOption(opts, opt);
                }
                var selectedBtn = kcaseQuery("#" + options.id + " ." + prop.cs.btnLayout).find("button").eq(btnNum);
                if (opts.event != undefined) {
                    selectedBtn.off("click");
                    selectedBtn.click(opts.event);
                }
                if (opts.show == true) {
                    selectedBtn.css("display", "inline-block");
                } else {
                    selectedBtn.css("display", "none");
                }
                if (opts.name != undefined) {
                    selectedBtn.text(opts.name);
                }
            };
        };

        /**
         * Certificate Manager Base Class
         */
        function _CertListManagerBase() {
            var nowDate = new Date();
            var reqCertListInfo = {
                media: 0,
                drive: 0,
                optList: undefined,
                certPolicies: undefined,
                secTokProg: undefined,
                saveTokenPw: undefined
            };

            var certPosTableId = prop.id.certPosTable;
            var tdList = kcaseQuery("#" + certPosTableId).find("td");
/*
            if((prop.invisibleMedia & prop.enable.harddisk) == prop.enable.harddisk){
            	kcaseQuery(tdList[1]).find("button").remove();
            }
            if((prop.invisibleMedia & prop.enable.remdisk) == prop.enable.remdisk){
            	kcaseQuery(tdList[2]).find("button").remove();
            }
            if((prop.invisibleMedia & prop.enable.savetoken) == prop.enable.savetoken){
            	kcaseQuery(tdList[3]).find("button").remove();
            }
            if((prop.invisibleMedia & prop.enable.pkcs11) == prop.enable.pkcs11){
            	kcaseQuery(tdList[4]).find("button").remove();
            }
            if((prop.invisibleMedia & prop.enable.mobile) == prop.enable.mobile){
            	kcaseQuery(tdList[5]).find("button").remove();
            }
*/					
            if((prop.invisibleMedia & prop.enable.harddisk) == prop.enable.harddisk){
            	kcaseQuery(tdList[1]).remove();
            }
            if((prop.invisibleMedia & prop.enable.remdisk) == prop.enable.remdisk){
            	kcaseQuery(tdList[2]).remove();
            }
            if((prop.invisibleMedia & prop.enable.savetoken) == prop.enable.savetoken){
            	kcaseQuery(tdList[3]).remove();
            }
            if((prop.invisibleMedia & prop.enable.pkcs11) == prop.enable.pkcs11){
            	kcaseQuery(tdList[4]).remove();
            }
            if((prop.invisibleMedia & prop.enable.mobile) == prop.enable.mobile){
            	kcaseQuery(tdList[5]).remove();
            }
            var posBtnList = kcaseQuery("#" + certPosTableId).find("button");
            var adminBtnList = kcaseQuery("#" + prop.id.content.admin).find("button");
            var basicBtnList = kcaseQuery("#" + prop.id.content.cert).find("button");
            var certPwInput = kcaseQuery("#" + prop.id.dialog.cert + " ." + prop.cs.pwBox);
            var rbgNormalStr = ".kc-dialog .kc-rbg-normal";

            function _mediaClickProc(index) {
                kcaseQuery("#" + prop.id.dialog.cert).click();

                kcaseQuery("#" + prop.id.certList + " tbody").find("tr").remove();
                kcaseQuery(rbgNormalStr + " .kc-ico-hdd").css("background", "url('" + prop.ROOT_DIR + "/img/icon_hdd_off.png')");
                kcaseQuery(rbgNormalStr + " .kc-ico-removable").css("background", "url('" + prop.ROOT_DIR + "/img/icon_removable_off.png')");
                kcaseQuery(rbgNormalStr + " .kc-ico-save-pkcs").css("background", "url('" + prop.ROOT_DIR + "/img/icon_save_pkcs_off.png')");
                kcaseQuery(rbgNormalStr + " .kc-ico-hw-pkcs").css("background", "url('" + prop.ROOT_DIR + "/img/icon_hw_pkcs_off.png')");
                kcaseQuery(rbgNormalStr + " .kc-ico-mobile").css("background", "url('" + prop.ROOT_DIR + "/img/icon_mobile_off.png')");

                switch (index) {
                    case prop.media.hardDisk:
                        kcaseQuery(rbgNormalStr + " .kc-ico-hdd").css("background", "url('" + prop.ROOT_DIR + "/img/icon_hdd.png')");
                        break;
                    case prop.media.removableDisk:
                        kcaseQuery(rbgNormalStr + " .kc-ico-removable").css("background", "url('" + prop.ROOT_DIR + "/img/icon_removable.png')");
                        break;
                    case prop.media.pkcs11:	
                        kcaseQuery(rbgNormalStr + " .kc-ico-hw-pkcs").css("background", "url('" + prop.ROOT_DIR + "/img/icon_hw_pkcs.png')");
                        break;
                    case prop.media.mobile:
                        kcaseQuery(rbgNormalStr + " .kc-ico-mobile").css("background", "url('" + prop.ROOT_DIR + "/img/icon_mobile.png')");
                        break;
                    case prop.media.c:
                        kcaseQuery(rbgNormalStr + " .kc-ico-save-pkcs").css("background", "url('" + prop.ROOT_DIR + "/img/icon_save_pkcs.png')");
                        break;
                }
            }

            posBtnList.click(function() {
                certPwInput.attr("disabled", false);
                util.loadDefaultCertListSize();

                var clickIndex = posBtnList.index(kcaseQuery(this));

                function _enabledProcess(proc) {
                    posBtnList.removeClass("kc-rbg-pressed");
                    posBtnList.addClass("kc-rbg-normal");

                    proc();

                    posBtnList.eq(clickIndex).removeClass("kc-rbg-normal");
                    posBtnList.eq(clickIndex).addClass("kc-rbg-pressed");
                }

                switch (clickIndex) {
                    case 0:
                        if ((prop.mediaOpt & prop.enable.harddisk) == prop.enable.harddisk) {
                            _enabledProcess(function() {
                                _mediaClickProc(prop.media.hardDisk);

                                adminBtnList.attr("disabled", false);
                                adminBtnList.css("color", "black");

                                basicBtnList.attr("disabled", false);
                                basicBtnList.css("color", "black");

                                reqCertListInfo.media = prop.media.hardDisk;
                                reqCertListInfo.drive = 0;
                                _getCertList();
                            });
                        }
                        break;
                    case 1:
                        if ((prop.mediaOpt & prop.enable.remdisk) == prop.enable.remdisk) {
                            _enabledProcess(function() {
                                _mediaClickProc(prop.media.removableDisk);

                                /* DropDown Menu Init */
                                kcaseQuery("." + prop.cs.dropdownMenu).remove();

                                var ulElement = kcaseQuery('<ul tabindex="3"/>');
                                ulElement.addClass(prop.cs.dropdownMenu);

                                /* get removable disk list */
                                comm.reqRemovableDiskList(function (result) {
                                    if (result.DriveList.length > 0) {
                                        var selectRemDiskPos = -1;
                                        for (var i = 0; i < result.DriveList.length; i++) {
                                            result.DriveList[i] = util.decodeUtf8(util.decode64(result.DriveList[i]));

                                            var liElement = "<li tabindex='3'><a>"
                                                + result.DriveList[i].substr(1, result.DriveList[i].length) + " ("
                                                + result.DriveList[i].charAt(0) + ":)</a></li>";

                                            ulElement.append(liElement);
                                            kcaseQuery("#" + certPosTableId).find("td").eq(2).append(ulElement);

                                            ulElement.css("display", "block");

                                            ulElement.find("li:last").data("value", result.DriveList[i].charAt(0));

                                            ulElement.find("li:last").click(function () {
                                                adminBtnList.attr("disabled", false);
                                                adminBtnList.css("color", "black");

                                                basicBtnList.attr("disabled", false);
                                                basicBtnList.css("color", "black");

                                                reqCertListInfo.media = prop.media.removableDisk;
                                                reqCertListInfo.drive = kcaseQuery(this).data("value").charCodeAt(0);
                                                _getCertList();
                                                kcaseQuery("." + prop.cs.dropdownMenu).css("display", "none");
                                            });

                                            ulElement.find("li:last a").hover(function() {
                                                kcaseQuery(this).css({
                                                    "background-color": "#6c9cda",
                                                    "color": "white",
                                                    "font-size": "13px"
                                                });
                                            }, function() {
                                                kcaseQuery(this).css({
                                                    "background-color": "",
                                                    "color": "black",
                                                    "font-size": "13px"
                                                });
                                            });
                                        }
																				ulElement.find("li").eq(0).focus();
																				selectRemDiskPos = 0;
																				ulElement.find("li").css("background-color", "");
                                        ulElement.find("a").css("color", "black");
                                        ulElement.find("li").eq(selectRemDiskPos).css("background-color", "#6c9cda");
                                        ulElement.find("li").eq(selectRemDiskPos).find("a").css("color", "white");
                                        ulElement.keydown(function(event) {
                                            if (event.which == 38) {
                                                event.preventDefault();
                                                event.stopPropagation();
                                                if (selectRemDiskPos != 0) {
                                                console.log(selectRemDiskPos);
                                                    selectRemDiskPos--;
                                                }
                                            } else if (event.which == 40) {
                                                event.preventDefault();
                                                event.stopPropagation();
                                                if (selectRemDiskPos < (ulElement.find("li").length - 1)) {
                                                    selectRemDiskPos++;
                                                }
                                            } else if (event.which == 13 || event.which == 32) {
                                                event.stopPropagation();
                                                event.preventDefault();
                                                ulElement.find("li").eq(selectRemDiskPos).click();
                                            }
                                            else {
                                                return;
                                            }
                                            ulElement.find("li").css("background-color", "");
                                            ulElement.find("a").css("color", "black");
                                            ulElement.find("li").eq(selectRemDiskPos).css("background-color", "#6c9cda");
                                            ulElement.find("li").eq(selectRemDiskPos).find("a").css("color", "white");
                                            ulElement.find("li").eq(selectRemDiskPos).focus();
                                        });
                                        kcaseQuery(document).click(function (event) {
                                            var isRbgPressed = event.target.className != "kc-rbg-pressed";
                                            var isRemovableDisk = event.target.className != prop.cs.mediaSpan + " " + prop.cs.dropdownGrp + " " + prop.cs.icoRemovable;
                                            var isRbgText = event.target.className != prop.cs.dropdownGrp + " " + prop.cs.rgbText;
                                            if (isRemovableDisk && isRbgText && isRbgPressed) {
		                                            //kcaseQuery("." + prop.cs.dropdownMenu).css("display", "none");
	                                            	kcaseQuery("#" + certPosTableId).find("button").eq(1).focus();
	                                            	kcaseQuery("." + prop.cs.dropdownMenu).remove();
                                                kcaseQuery(document).off("click");
                                            } else {
                                            }
                                        });																					
                                  } else {
                                        // no removable disk
                                    }
                                });
                            });
                        }
                        break;
                    case 2:

                        if ((prop.mediaOpt & prop.enable.savetoken) == prop.enable.savetoken) {
                            _enabledProcess(function() {
                                _mediaClickProc(prop.media.savetoken);
                                stDialogManager.setConfirmBtn(function() {
                                    var stname = stDialogManager.getSelectedName();

                                    if (stname == undefined) {
                                        alert(prop.strings.NOT_SELECTED_SAVETOKEN);
                                        return;
                                    }

                                    stokenPwDlg.setConfirmBtn(function() {

                                        var stpw = stokenPwDlg.getPassword();
                                        if(!util.verifyInputPassword(stpw, prop.media.savetoken)) {
                                            return;
                                        }

                                        stokenPwDlg.close();
                                        stDialogManager.close();

                                        reqCertListInfo.media = prop.media.savetoken;
                                        reqCertListInfo.drive = -1;
                                        reqCertListInfo.secTokProg = stname;
                                        reqCertListInfo.saveTokenPw = stpw;

                                        _getCertList(function(errcode) {
                                            alert(prop.getErrorMsg(errcode));
                                        });
                                    });
                                    stokenPwDlg.open();
                                });
                                stDialogManager.open();

                                adminBtnList.eq(0).attr("disabled", true);
                                adminBtnList.eq(0).css("color", "gray");
                                adminBtnList.eq(1).attr("disabled", true);
                                adminBtnList.eq(1).css("color", "gray");
                                adminBtnList.eq(3).attr("disabled", true);
                                adminBtnList.eq(3).css("color", "gray");

                            });
                        }
                        else {
                        		//alert("서비스 되지 않는 기능입니다.");
                        }

                        break;
                    case 3:

                        if ((prop.mediaOpt & prop.enable.pkcs11) == prop.enable.pkcs11) {
                            _enabledProcess(function() {
                                _mediaClickProc(prop.media.pkcs11);
                                p11DlgManager.open();
                                p11DlgManager.setConfirmBtn(function() {
                                    var p11Name = p11DlgManager.getSelectedName();
                                    if (p11Name == undefined) {
                                        alert(prop.strings.NOT_SELECTED_PKCS11);
                                        return;
                                    }

                                    reqCertListInfo.media = prop.media.pkcs11;
                                    reqCertListInfo.drive = -1;
                                    reqCertListInfo.secTokProg = p11Name;

                                    _getCertList(function() {
                                        alert(prop.strings.NOT_CONNECTED_PKCS11);
                                    });

                                    p11DlgManager.close();
                                });

                                adminBtnList.eq(0).attr("disabled", true);
                                adminBtnList.eq(0).css("color", "gray");
                                adminBtnList.eq(1).attr("disabled", true);
                                adminBtnList.eq(1).css("color", "gray");
                                adminBtnList.eq(3).attr("disabled", true);
                                adminBtnList.eq(3).css("color", "gray");

                                certPwInput.attr("disabled", true);
                            });
                        }
                        else {
                        		//alert("서비스 되지 않는 기능입니다.");
                        }
                        break;
                    case 4:

						/**
						 * 하위버전 Agent 사용자 중 Ubikey 사용시 강제 업데이트 구문 추가 2017-06-21 DYLEE
						 *  인증서 창에서 휴대폰을 눌럿을 때 옵션(isUseUbikey)에 따라
						 * CheckInstallAgent 함수 호출
						 * 호출 후 성공이면 기존 방법과 동일한 함수를 타도록 설정
						 * 실패 시 Init시에 등록했던 함수 호출
						 *
						 */
                        if ((prop.mediaOpt & prop.enable.mobile) == prop.enable.mobile) {
                        	if(prop.isUseUbikey){
                        		kcaseagt.checkInstallAgent({
                        			isUseUbikey: true,
            						success: function() {
										_enabledProcess(function() {
		                                _mediaClickProc(prop.media.mobile);

		                                if (prop.NOT_INSTALLED_UBIKEY != null) {
		                                    adminBtnList.eq(0).attr("disabled", true);
		                                    adminBtnList.eq(0).css("color", "gray");
		                                    adminBtnList.eq(1).attr("disabled", true);
		                                    adminBtnList.eq(1).css("color", "gray");
		                                    adminBtnList.eq(2).attr("disabled", true);
		                                    adminBtnList.eq(2).css("color", "gray");
		                                    adminBtnList.eq(3).attr("disabled", true);
		                                    adminBtnList.eq(3).css("color", "gray");

		                                    basicBtnList.eq(2).attr("disabled", true);
		                                    basicBtnList.eq(2).css("color", "gray");

		                                    reqCertListInfo.media = prop.media.mobile;
		                                    reqCertListInfo.drive = 0;

		                                    kcaseQuery("#" + prop.id.certList + " tbody").find("tr").remove();

		                                    reqCertListInfo.certPolicies = prop.certPolices;

		                                    comm.reqOpenUbikey(function(result) {
			                                        var certInfo = [];

			                                        if(result.Status != prop.success) {
			                                            if (result.Status == 0x8021) {
			                                                prop.NOT_INSTALLED_UBIKEY();
			                                            } else {
			                                            	// 2017.07.11 NEIS 요청사항으로 Ubikey 사용 중 취소하거나 Ubikey 모듈에서 리턴되는 에러관련 메세지를 보여주는 부분 제거.
			                                                //alert(prop.getErrorMsg(result.Status));
			                                            }

			                                        } else {
			                                            for (var i = 0; i < result.CertList.length; i++) {
			                                                var tmpCertInfo = _certObjToCertInfo(kcaseQuery.parseJSON(util.decodeUtf8(util.decode64(result.CertList[i]))), result.CertStatus[i]);

			                                                certInfo[i] = tmpCertInfo;
			                                                certInfo[i].media = reqCertListInfo.media;
			                                                certInfo[i].drive = reqCertListInfo.drive;
			                                                certInfo[i].secTokProg = reqCertListInfo.secTokProg;
			                                                certInfo[i].certStatus = 0;

			                                                _insertCertList(certInfo[i], i);
			                                            }

			                                            kcaseQuery("#" + prop.id.certList + " tbody").find("tr").eq(0).click();
			                                            _selectedCertPos = 0;
			                                        }
		                                    	});
			                                } else {
			                                    alert("준비중입니다.");
			                                }
	            						});
	            					},
	            					error: function(errCode, errMsg){
	            						prop.INVALID_VERSION_FOR_UBIKEYUSER(errCode, errMsg);
	            					}
	            				});
                        	}
                        	else{
	                            _enabledProcess(function() {
	                                _mediaClickProc(prop.media.mobile);

	                                if (prop.NOT_INSTALLED_UBIKEY != null) {
	                                    adminBtnList.eq(0).attr("disabled", true);
	                                    adminBtnList.eq(0).css("color", "gray");
	                                    adminBtnList.eq(1).attr("disabled", true);
	                                    adminBtnList.eq(1).css("color", "gray");
	                                    adminBtnList.eq(2).attr("disabled", true);
	                                    adminBtnList.eq(2).css("color", "gray");
	                                    adminBtnList.eq(3).attr("disabled", true);
	                                    adminBtnList.eq(3).css("color", "gray");

	                                    basicBtnList.eq(2).attr("disabled", true);
	                                    basicBtnList.eq(2).css("color", "gray");

	                                    reqCertListInfo.media = prop.media.mobile;
	                                    reqCertListInfo.drive = 0;

	                                    kcaseQuery("#" + prop.id.certList + " tbody").find("tr").remove();

	                                    reqCertListInfo.certPolicies = prop.certPolices;

	                                    comm.reqOpenUbikey(function(result) {
	                                        var certInfo = [];

	                                        if(result.Status != prop.success) {
	                                            if (result.Status == 0x8021) {
	                                                prop.NOT_INSTALLED_UBIKEY();
	                                            } else {
	                                                alert(prop.getErrorMsg(result.Status));
	                                            }

	                                        } else {
	                                            for (var i = 0; i < result.CertList.length; i++) {
	                                                var tmpCertInfo = _certObjToCertInfo(kcaseQuery.parseJSON(util.decodeUtf8(util.decode64(result.CertList[i]))), result.CertStatus[i]);

	                                                certInfo[i] = tmpCertInfo;
	                                                certInfo[i].media = reqCertListInfo.media;
	                                                certInfo[i].drive = reqCertListInfo.drive;
	                                                certInfo[i].secTokProg = reqCertListInfo.secTokProg;
	                                                certInfo[i].certStatus = 0;

	                                                _insertCertList(certInfo[i], i);
	                                            }

	                                            kcaseQuery("#" + prop.id.certList + " tbody").find("tr").eq(0).click();
	                                            _selectedCertPos = 0;
	                                        }
	                                    });
	                                } else {
	                                    alert("준비중입니다.");
	                                }
	                            });
                          	}
                        }
                        break;
                }

            });

            function _getPolicyName(oid) {
                var map = {};

                // wide use
                map["1.2.410.200005.1.1.1"] = ["금융 개인", "금융결제원"];
                map["1.2.410.200005.1.1.5"] = ["범용 기업", "금융결제원"];
                map["1.2.410.200005.1.1.6.8"] = ["전자세금용", "금융결제원"];
                map["1.2.410.200012.1.1.1"] = ["전자거래서명용(개인)", "한국무역정보통신"];
                map["1.2.410.200012.1.1.3"] = ["전자거래서명용(법인)", "한국무역정보통신"];
                map["1.2.410.200004.5.1.1.5"] = ["범용 개인", "한국증권전산"];
                map["1.2.410.200004.5.1.1.7"] = ["범용 법인", "한국증권전산"];
                map["1.2.410.200004.5.2.1.1"] = ["범용 법인", "한국정보인증"];
                map["1.2.410.200004.5.2.1.2"] = ["범용 개인", "한국정보인증"];
                map["1.2.410.200004.5.3.1.1"] = ["법용 기관", "한국전산원"];
                map["1.2.410.200004.5.3.1.2"] = ["법용 법인", "한국전산원"];
                map["1.2.410.200004.5.3.1.9"] = ["범용 개인", "한국전산원"];
                map["1.2.410.200004.5.4.1.1"] = ["범용 개인", "한국 전자인증"];
                map["1.2.410.200004.5.4.1.2"] = ["범용 법인", "한국 전자인증"];
                map["1.2.410.200004.5.5.1.1"] = ["범용 개인", "이니텍(INIPASS)"];
                map["1.2.410.200004.5.5.1.2"] = ["범용 법인", "이니텍(INIPASS)"];
                map["1.2.410.200004.5.5.1.3.1"] = ["제휴기관용(개인)", "이니텍(INIPASS)"];
                map["1.2.410.200004.5.5.1.4.1"] = ["제휴기관용(기업)", "이니텍(INIPASS)"];
                map["1.2.410.200004.5.5.1.4.2"] = ["전자세금용(기업)", "이니텍(INIPASS)"];

                //NEIS
                map["1.2.410.200004.2.207"] = ["학생인증서", "한국정보인증"];
                map["1.2.410.200004.2.208"] = ["학부모인증서", "한국정보인증"];

                // HIRA
                map["1.2.410.200004.10.1.1"] = ["일반인증서", "한국정보인증"];
                map["1.2.410.200004.5.2.1.5.407"] = ["일반인증서", "한국정보인증"];

                map["1.2.410.200004.2.1"] = ["일반인증서", "공인인증기관"];
                map["1.2.410.200005.1.1.2"] = ["금융기업", "금융결제원"];
                map["1.2.410.200005.1.1.4"] = ["은행개인", "금융결제원"];
                map["1.2.410.200004.5.1.1.1"] = ["스페셜개인", "한국증권전산"];
                map["1.2.410.200004.5.1.1.2"] = ["스페셜개인서버", "한국증권전산"];
                map["1.2.410.200004.5.1.1.3"] = ["스페셜법인", "한국증권전산"];
                map["1.2.410.200004.5.1.1.4"] = ["스페셜서버", "한국증권전산"];
                map["1.2.410.200004.5.1.1.6"] = ["범용개인서버", "한국증권전산"];
                map["1.2.410.200004.5.1.1.8"] = ["범용서버", "한국증권전산"];
                map["1.2.410.200004.5.1.1.9"] = ["골드개인", "한국증권전산"];
                map["1.2.410.200004.5.1.1.10"] = ["골드개인서버", "한국증권전산"];
                map["1.2.410.200004.5.1.1.11"] = ["실버개인", "한국증권전산"];
                map["1.2.410.200004.5.1.1.12"] = ["실버법인", "한국증권전산"];
                map["1.2.410.200012.1.1.2"] = ["전자거래암호용(개인)", "한국무역정보통신"];
                map["1.2.410.200012.1.1.4"] = ["전자거래암호용(법인)", "한국무역정보통신"];
                map["1.2.410.200012.1.1.5"] = ["전자거래서명용(서버)", "한국무역정보통신"];
                map["1.2.410.200012.1.1.6"] = ["전자거래암호용(서버)", "한국무역정보통신"];
                map["1.2.410.200012.1.1.7"] = ["전자무역서명용(개인)", "한국무역정보통신"];
                map["1.2.410.200012.1.1.8"] = ["전자무역암호용(개인)", "한국무역정보통신"];
                map["1.2.410.200012.1.1.9"] = ["전자무역서명용(법인)", "한국무역정보통신"];
                map["1.2.410.200012.1.1.10"] = ["전자무역암호용(법인)", "한국무역정보통신"];
                map["1.2.410.200012.1.1.11"] = ["전자무역서명용(서버)", "한국무역정보통신"];
                map["1.2.410.200012.1.1.12"] = ["전자무역암호용(서버)", "한국무역정보통신"];
                map["1.2.410.200004.5.4.1.3"] = ["범용(서버)", "한국 전자인증"];
                map["1.2.410.200004.5.4.1.4"] = ["특수목적용(개인)", "한국 전자인증"];
                map["1.2.410.200004.5.4.1.5"] = ["특수목적용(법인)", "한국 전자인증"];
                map["1.2.410.200004.5.2.1.3"] = ["특별등급(전자입찰)", "한국정보인증"];
                map["1.2.410.200004.5.2.1.4"] = ["1등급인증서(서버)", "한국정보인증"];
                map["1.2.410.200004.5.2.1.5"] = ["특별등급법인", "한국정보인증"];
                map["1.2.410.200004.5.3.1.3"] = ["1등급(서버)", "한국전산원"];
                map["1.2.410.200004.5.3.1.5"] = ["특수목적용(기관/단체)", "한국전산원"];
                map["1.2.410.200004.5.3.1.6"] = ["특수목적용(법인)", "한국전산원"];
                map["1.2.410.200004.5.3.1.7"] = ["특수목적용(서버)", "한국전산원"];
                map["1.2.410.200004.5.3.1.8"] = ["특수목적용(개인)", "한국전산원"];
                map["1.2.392.200132"] = ["일본상공회의소", "JCCI"];
                map["1.2.392.200132.1"] = ["일본 상공회의소 비지니스 인증 서비스(BCA 접속)", "JCCI"];
                map["1.2.392.200132.1.1"] = ["비지니스 인증 서비스 타입 1 업무 폴리시 및 운용 규정", "JCCI"];
                map["1.2.392.200132.1.1"] = ["비지니스 인증 서비스 타입 1 증명서 발행 폴리시", "JCCI"];
                map["2.5.29.32.0"] = ["일본상공회의소 any-policy", "JCCI"];

                // GPKI Policy
                map["1.2.410.100001.2.1.1"] = ["전자관인(기관용)", "행정자치부"];
                map["1.2.410.100001.2.1.2"] = ["서버용(컴퓨터용)", "행정자치부"];
                map["1.2.410.100001.2.1.3"] = ["특수목적용(업무용) ", "행정자치부"];
                map["1.2.410.100001.2.1.4"] = ["공공/민간 전자관인 ", "행정자치부"];
                map["1.2.410.100001.2.1.5"] = ["공공/민간 컴퓨터용 ", "행정자치부"];
                map["1.2.410.100001.2.1.6"] = ["공공/민간 특수목적용 ", "행정자치부"];
                map["1.2.410.100001.2.2.1"] = ["공무원 전자서명", "행정자치부"];
                map["1.2.410.100001.2.2.2"] = ["공공/민간 개인용 전자서명 ", "행정자치부"];
                map["1.2.410.100001.5.1"] = ["대통령비서실 ", "행정자치부"];
                map["1.2.410.100001.5.1.1"] = ["대통령비서실 인증서정책", ""];
                map["1.2.410.100001.5.2"] = ["국가정보원 ", "행정자치부"];
                map["1.2.410.100001.5.2.1"] = ["국가정보원 인증서정책", "행정자치부"];
                map["1.2.410.100001.5.3"] = ["교육부", "교육부"];
                map["1.2.410.100001.5.3.1"] = ["교육부 인증서정책", "교육부"];
                map["1.2.410.100001.5.3.1.1"] = ["전자관인", "교육부"];
                map["1.2.410.100001.5.3.1.3"] = ["일반인증서", "교육부"];
                map["1.2.410.100001.5.3.1.5"] = ["특수목적용", "교육부"];
                map["1.2.410.100001.5.3.1.7"] = ["컴퓨터용 ", "교육부"];
                map["1.2.410.100001.5.3.1.9"] = ["SSL용", "교육부"];
                map["1.2.410.100001.5.4"] = ["국방부 ", "국방부"];
                map["1.2.410.100001.5.4.1"] = ["국방부 인증서정책", "국방부"];
                map["1.2.410.100001.5.5"] = ["대검찰청 ", "대검찰청"];
                map["1.2.410.100001.5.5.1"] = ["대검찰청 인증서정책", "대검찰청"];
                map["1.2.410.100001.5.6"] = ["병무청 ", "병무청"];
                map["1.2.410.100001.5.6.1"] = ["병무청 인증서정책", "병무청"];
                map["1.2.410.100001.5.7"] = ["안전행정부 ", ""];
                map["1.2.410.100001.5.7.1"] = ["안전행정부 인증서정책", ""];
                map["1.2.410.100001.5.8"] = ["법원", "법원"];
                map["1.2.410.100001.5.8.1"] = ["법원", "법원"];
                
                // KSIGN Policy
                map["1.2.3.4.5"] = ["개인인증서", "사설인증기관"];
                return map[oid];
            }

            function _certObjToCertInfo(certObj, certStatus) {
                function expirationDateToDay() {
                    if (certStatus == -1) {
                        return -1;
                    }

                    var comDate = new Date(certObj.notAfter.replace(/-/g, "/"));
                    return Math.ceil((comDate - nowDate)/86400000); //24 * 60 * 60 * 1000
                }

                var policy = _getPolicyName(certObj.policy);

               if(policy == undefined) {
                    policy = ["", ""];
                }
				if(policy[1] == "사설인증기관"){
					var issuerCN = certObj.issuerDN.split(',');
					issuerCN = issuerCN[0].substring(3, issuerCN[0].length);
					policy[1] = issuerCN;
				}
                var certInfo = {
                    version: certObj.version,
                    serialNumber: certObj.serialNumber,
                    signAlgorithm: certObj.signAlgorithm,
                    issuerDN: certObj.issuerDN,
                    issuerName: policy[1],
                    issuerOrg: certObj.issuerOrg,
                    notBefore: certObj.notBefore,
                    notAfter: certObj.notAfter,
                    subjectCN: certObj.subjectCN,
                    subjectDN: certObj.subjectDN,
                    pubKey: certObj.pubKey,
                    pubKeyAlgo: certObj.pubKeyAlgo,
                    pubKeyLength: certObj.pubKeyLength,
                    authorityKeyId: certObj.authorityKeyId,
                    subjectKeyId: certObj.subjectKeyId,
                    policy: policy[0],
                    policyOid: certObj.policy,
                    cps: certObj.cps,
                    noti: certObj.noti,
                    subjectAltName: certObj.subjectAltName,
                    dp: certObj.dp,
                    authorityInfoAccessOCSP: certObj.authorityInfoAccessOCSP,
                    keyUsage: certObj.keyUsage,
                    authorityCertSerialNumber: certObj.authorityCertSerialNumber,
                    signautre: certObj.signautre,
                    certIndex: certObj.certIndex,
                    expirationDate: expirationDateToDay(),
                    keychangedate: certObj.keychangedate
                };
                return certInfo;
            }

            /* Set Certificate List to Dialog */
            function _insertCertList(certInfo, pos) {
                var img;

                if (certInfo.certStatus == -1) {
                    img = prop.ROOT_DIR + "/img/cert_inv_small.png";
                } else {
                    img = prop.ROOT_DIR + "/img/cert0.png";
                }

                var certListElement = kcaseQuery("#" + prop.id.certList);

                var rowElement = kcaseQuery("<tr></tr>");
                rowElement.attr("tabindex", 6);
                    
                    rowElement.attr("role", "row");                    
                rowElement.click(function() {
                    certListElement.find("tbody tr").removeData("selected");
                    certListElement.find("tbody tr").removeClass(prop.cs.certSelectedRow);
                    rowElement.addClass(prop.cs.certSelectedRow);
                    rowElement.data("selected", 1);
                    _selectedCertPos = pos;
                    //kcaseQuery("#" + prop.id.certList).focus();

                    kcaseQuery("#" + prop.id.dialog.cert + " ." + prop.cs.pwBox).val("");
                    kcaseQuery("." + prop.cs.widget).find("div").text("");
									  if(certInfo.keychangedate != null) {
									  	 var isBlockPwd = certInfo.keychangedate.substring(0, 1);									  	
									  	 if(isBlockPwd == 'N'){
									  	 		certInfo.keychangedate = certInfo.keychangedate.substring(1, certInfo.keychangedate.length);
									  	 		kcaseQuery("input[name=certPassword]").prop('disabled', true);
									  	 		certInfo.block = true;
									  	 } else if(isBlockPwd == 'Y'){
									  	 		certInfo.keychangedate = certInfo.keychangedate.substring(1, certInfo.keychangedate.length);
									  	 	  kcaseQuery("input[name=certPassword]").prop('disabled', false);
									  	 	  certInfo.block = false;
									  	 } else {
									  	 		if(certInfo.block){
									  	 			kcaseQuery("input[name=certPassword]").prop('disabled', true);
									  	 		} else {
									  	 			kcaseQuery("input[name=certPassword]").prop('disabled', false);
									  	 		}
									  	 }
									  	 	
									  	 if (certInfo.expirationDate < 0) {
	                        var msg = kcaseQuery("." + prop.cs.widget).find("div").eq(0);
	                        msg.text("선택된 인증서는 만료되어 재발급이 필요합니다.");
	                        kcaseQuery("." + prop.cs.widget).css("display", "block");
	                    } else if (certInfo.expirationDate <= 90) {
	                        var msg = kcaseQuery("." + prop.cs.widget).find("div").eq(1);
	                        if(certInfo.policyOid == "1.2.410.200004.2.207"){
	                        	msg.html("선택하신 인증서는 " + certInfo.notAfter + " 에 만료 예정입니다.<br>발급받으신 인증기관을 통해 인증서를 재발급하시기 바랍니다." + "<br>" + certInfo.keychangedate);
	                        } else if(certInfo.policyOid == "1.2.410.200004.2.208"){
	                        	msg.html("선택하신 인증서는 " + certInfo.notAfter + " 에 만료 예정입니다.<br>발급받으신 인증기관을 통해 인증서를 재발급하시기 바랍니다." + "<br>" + certInfo.keychangedate);
	                        } else {
	                        	msg.html("선택하신 인증서는 " + certInfo.notAfter + " 에 만료 예정입니다.<br>발급받으신 인증기관을 통해 인증서를 갱신하시기 바랍니다." + "<br>" + certInfo.keychangedate);
	                      	}
	                        kcaseQuery("." + prop.cs.widget).css("display", "block");
	                    } else {
	                    		var msg = kcaseQuery("." + prop.cs.widget).find("div").eq(1);
	                    	  msg.html(certInfo.keychangedate);
	                        kcaseQuery("." + prop.cs.widget).css("display", "block");
					            }					  	
									  } else {
		                    if (certInfo.expirationDate < 0) {
		                        var msg = kcaseQuery("." + prop.cs.widget).find("div").eq(0);
		                        msg.text("선택된 인증서는 만료되어 재발급이 필요합니다");
		                        kcaseQuery("." + prop.cs.widget).css("display", "block");
		                    } else if (certInfo.expirationDate <= 90) {
		                        var msg = kcaseQuery("." + prop.cs.widget).find("div").eq(1);
		                        if(certInfo.policyOid == "1.2.410.200004.2.207"){
		                        	msg.html("선택하신 인증서는 " + certInfo.notAfter + " 에 만료 예정입니다.<br>발급받으신 인증기관을 통해 인증서를 재발급하시기 바랍니다.");
		                        } else if(certInfo.policyOid == "1.2.410.200004.2.208"){
		                        	msg.html("선택하신 인증서는 " + certInfo.notAfter + " 에 만료 예정입니다.<br>발급받으신 인증기관을 통해 인증서를 재발급하시기 바랍니다.");
		                        } else {
		                        	msg.html("선택하신 인증서는 " + certInfo.notAfter + " 에 만료 예정입니다.<br>발급받으신 인증기관을 통해 인증서를 갱신하시기 바랍니다.");
		                      	}
		                        kcaseQuery("." + prop.cs.widget).css("display", "block");
		                    } else {
		                        kcaseQuery("." + prop.cs.widget).css("display", "none");
		                    }					  	
								  }
                });
                rowElement.dblclick(function() {
                    if (certInfo.expirationDate >= 0) {
                        _getDialog(prop.id.dialog.viewCert).open(certInfo);
                    }
                });

                var dateTokenIndex = certInfo.notAfter.indexOf(" ");
                var notAfterDate = certInfo.notAfter.substring(0, dateTokenIndex);

                //black307
                var tdElement = "<td><div class='" + prop.cs.certTableCell + "' style='font-size:11px;' title= '" + certInfo.policy + "'><img src='" + img + "'alt='" + certInfo.policy + "'/>" + certInfo.policy + "</div></td>"
                    + "<td><div title='" + certInfo.subjectCN + "' class='" + prop.cs.certTableCell + "' style='font-size:12px;'>" + certInfo.subjectCN + "</div></td>"
                    + "<td><div class='" + prop.cs.certTableCell + "' style='text-align: center;font-size:11px;'>" + notAfterDate + "</div></td>"
                    + "<td><div title='" + certInfo.issuerName + "' class='" + prop.cs.certTableCell + "' style='text-align: center;font-size:11px;'>" + certInfo.issuerName + "</div></td>";

                rowElement.append(tdElement);
                rowElement.data("certInfo", certInfo);
                rowElement.attr("title", certInfo.policy + certInfo.subjectCN + notAfterDate + certInfo.issuerName);
                certListElement.find("tbody").append(rowElement);
            }

            /* Get Certificate List */
            var _getCertList = this.getCertList = function (error) {
                nowDate = new Date();
                /* 인증서리스트를 먼저 삭제함 */
                kcaseQuery("#" + prop.id.certList + " tbody").find("tr").remove();

                reqCertListInfo.certPolicies = prop.certPolices;

                comm.reqCertList(reqCertListInfo, function (result) {
                    var certInfo = [];

                    if(result.Status != prop.success) {
                        if(error != undefined)
                            error(result.Status);
                    }

                    for (var i = 0; i < result.CertList.length; i++) {
                        var tmpCertInfo = _certObjToCertInfo(kcaseQuery.parseJSON(util.decodeUtf8(util.decode64(result.CertList[i]))), result.CertStatus[i]);

                        certInfo[i] = tmpCertInfo;
                        certInfo[i].media = reqCertListInfo.media;
                        certInfo[i].drive = reqCertListInfo.drive;
                        certInfo[i].secTokProg = reqCertListInfo.secTokProg;
                        certInfo[i].certStatus = result.CertStatus[i];

                        _insertCertList(certInfo[i], i);
                    }
                    
                    kcaseQuery("#" + prop.id.certList + " tbody").find("tr").eq(0).focus();
                    kcaseQuery("#" + prop.id.certList + " tbody").find("tr").eq(0).click();

                    //kcaseQuery("#" + prop.id.certList + " tbody").find("tr").eq(0).click();

                    _selectedCertPos = 0;
                });
            };

            /* Check Certificate Selected */
            this.checkSelectedCert = function () {
                var certInfo;
                var tempObject = util.getSelectedObject(prop.cs.certSelectedRow);

                if (tempObject == undefined) {
                    return undefined;
                } else {
                    certInfo = tempObject.data("certInfo");
                    return certInfo;
                }
            };

            /* Set Certificate List Option */
            this.setCertOption = function (option) {
                reqCertListInfo.optList = option;
            };
            /* Get Certificate List Option */
            this.getCertOption = function () {
                return reqCertListInfo.optList;
            };

            /* View Certficate */
            this.viewCertificate = function (certInfo) {
            		prop.isSubView = true;
                var commonTab = kcaseQuery("#" + prop.id.tabList).find("td").eq(0);
                var detailTab = kcaseQuery("#" + prop.id.tabList).find("td").eq(1);

                commonTab.click(function () {
                    kcaseQuery("#" + prop.id.tabCommon).css("display", "block");
                    kcaseQuery("#" + prop.id.tabDetail).css("display", "none");

                    commonTab.addClass("tabnav-selected");
                    commonTab.removeClass("tabnav-unselected");
                    detailTab.addClass("tabnav-unselected");
                    detailTab.removeClass("tabnav-selected");
                });

                detailTab.click(function () {
                    kcaseQuery("#" + prop.id.tabCommon).css("display", "none");
                    kcaseQuery("#" + prop.id.tabDetail).css("display", "block");

                    commonTab.addClass("tabnav-unselected");
                    commonTab.removeClass("tabnav-selected");
                    detailTab.addClass("tabnav-selected");
                    detailTab.removeClass("tabnav-unselected");
                });

                commonTab.click();

                comm.reqCertVerify(certInfo, function (result) {
                    var sigStatus;

                    /* Common Information */
                    if (result.Status == prop.success) {
                        sigStatus = prop.strings.CERT_VAL_SUCCESS;
                        kcaseQuery("#" + prop.id.tabCommon + " > div").find("div").remove();
                        kcaseQuery("#" + prop.id.tabCommon + " > div").append("<div><img src='" + prop.ROOT_DIR + "/img/verify1.png" + "'><span class='" + prop.cs.fontb + "' style='margin-left: 8px;'>인증서 정보</span></div>");
                    } else {
                        sigStatus = prop.getErrorMsg(result.Status);
                        kcaseQuery("#" + prop.id.tabCommon + " > div").find("div").remove();
                        kcaseQuery("#" + prop.id.tabCommon + " > div").append("<div><img src='" + prop.ROOT_DIR + "/img/cert_inv.png" + "'><span class='" + prop.cs.fontb + "' style='margin-left: 8px;'>인증서 정보</span></div>");
                    }

                    var certCommonInfoStr = sigStatus + "\r\n\r\n"
                        + "[발급대상]\r\n" + certInfo.subjectCN + "\r\n\r\n"
                        + "[발급자]\r\n" + certInfo.issuerName + "\r\n\r\n"
                        + "[구분]\r\n" + certInfo.policy + "\r\n\r\n"
                        + "[유효기간]\r\n" + certInfo.notBefore + " ~ " + certInfo.notAfter + "\r\n\r\n";
                    kcaseQuery("#" + prop.id.tabCommon + " textarea").text(certCommonInfoStr);

                    /* Detailed Information */
                    kcaseQuery("#" + prop.id.tabDetail + " tbody").find("tr").remove();
                    kcaseQuery("#" + prop.id.tabDetail + " textarea").val("");

                    _addDetailedCertInfo("버전", certInfo.version);
                    _addDetailedCertInfo("일련번호", certInfo.serialNumber);
                    _addDetailedCertInfo("서명알고리즘", certInfo.signAlgorithm);
                    _addDetailedCertInfo("발급자", certInfo.issuerDN);
                    _addDetailedCertInfo("유효 기간(시작)", certInfo.notBefore);
                    _addDetailedCertInfo("유효 기간(끝)", certInfo.notAfter);
                    _addDetailedCertInfo("주체", certInfo.subjectDN);
                    _addDetailedCertInfo("공개키", certInfo.pubKey);

                    _addDetailedCertInfo("기관 키 식별자", certInfo.authorityKeyId);
                    _addDetailedCertInfo("주체 키 식별자", certInfo.subjectKeyId);
                    _addDetailedCertInfo("주체 대체 이름", certInfo.subjectAltName);
                    /*_addDetailedCertInfo("발급자 대체 이름", certInfo.issuerOrg);*/
                    _addDetailedCertInfo("CRL 배포 지점", certInfo.dp);
                    _addDetailedCertInfo("기관 정보 엑세스", certInfo.authorityInfoAccessOCSP);
                    _addDetailedCertInfo("인증서 정책", certInfo.policyOid);
                    _addDetailedCertInfo("키 사용", certInfo.keyUsage);

                    /**********************************************/
                    /* 인증서 자세히 보기에 필드와 값을 추가하는 함수 */
                    /**********************************************/
                    function _addDetailedCertInfo(field, value) {
                        var rowElement = kcaseQuery("<tr />", {
                            click: function () {
                                kcaseQuery("#" + prop.id.tabDetail + " tbody").find("tr").removeClass(prop.cs.certSelectedRow);
                                kcaseQuery(this).addClass(prop.cs.certSelectedRow);

                                kcaseQuery("#" + prop.id.tabDetail + " textarea").val(kcaseQuery(this).find("td").eq(1).text());
                            }
                        });
                        var tdElement = "<td class='" + prop.cs.certTableCell + "'>"
                            + "<img src='" + prop.ROOT_DIR + "/img/itemimg.png'/>"
                            + field
                            + "</td><td class='" + prop.cs.wrdNormal + " "+ prop.cs.certTableCell + "'>"
                            + value
                            + "</td>";

                        rowElement.append(tdElement);

                        kcaseQuery("#" + prop.id.tabDetail + " tbody").append(rowElement);

                        rowElement.css("cursor", "pointer");
                    }
                });
            };
        }
        /* Cert Manager */
        var certManager = new _CertListManagerBase();

        /**
         * PKCS11 Dialog Manager Class
         */
        function _pkcs11DialogManager() {
            var tableElement = kcaseQuery("#" + prop.id.dialog.pkcs11 + " ." + prop.cs.tableView).find("table");
            var selectedName;
            var selectP11Pos;
            var pkcs11List;
            var p11Dlg = _makeDialog({            		
                id: prop.id.dialog.pkcs11,
                width: 400,
                height: 350,
                open: function () {
                		prop.isSubView = true;
                    selectP11Pos = 0;
                    comm.reqSecTokenList(function (result) {
                        kcaseQuery("." + prop.cs.p11List).remove();
                        for (var i = 0; i < result.SecTokList.length; i++) {
                            var row = kcaseQuery("<tr/>");
                            row.addClass(prop.cs.p11List);
                            row.css("cursor", "pointer");
                            var data = kcaseQuery("<td/>");

                            data.text(result.SecTokList[i]);
                            row.append(data);

                            row.click(function () {
                                kcaseQuery("." + prop.cs.p11List).removeClass(prop.cs.certSelectedRow);
                                kcaseQuery(this).addClass(prop.cs.certSelectedRow);
                                selectedName = kcaseQuery(this).text();

                                selectP11Pos = this.rowIndex - 1;
                            });

                            tableElement.append(row);
                        }
                        pkcs11List = kcaseQuery("#" + prop.id.dialog.pkcs11 + " ." + prop.cs.tableView);
                        pkcs11List.find("." + prop.cs.p11List).eq(0).click();

                        pkcs11List.keydown(function(event) {
                            var p11ListRow = kcaseQuery("." + prop.cs.p11List);

                            if (event.which == 38) {    // Up Arrow
                                event.preventDefault();
                                if (selectP11Pos != 0) {
                                    selectP11Pos--;
                                }
                            } else if (event.which == 40) { // Down Arrow
                                event.preventDefault();
                                if (selectP11Pos < (p11ListRow.length - 1)) {
                                    selectP11Pos++;
                                }
                            } else {
                                return;
                            }
                            p11ListRow.eq(selectP11Pos).click();
                        });

                    });
                },
                close: function () {
						pkcs11List.unbind();
                }
            });
            p11Dlg.setBottomBtns(0, {
                event: function () {
                    window.open(prop.SECURITY_TOKEN_INSTALL_URL);
                }
            });
            p11Dlg.setBottomBtns(2, {
                event: function () {
                    p11Dlg.close();
                    prop.CANCEL_SUB_DIALOG();
                    prop.isSubView = false;
                }
            });
            this.setPosition = function(p) {
                p11Dlg.setPosition(p);
            };
            this.getSelectedName = function() {
                return selectedName;
            };
            this.setConfirmBtn = function (event) {
                p11Dlg.setBottomBtns(1, {
                    event: event
                });
            };
            this.open = p11Dlg.open;
            this.close = p11Dlg.close;
        }

        /**
         * File Explorer Dialog Class
         */
        function _FileExplorerManager() {
            /* File Dialog */
            var dlg = _makeDialog({
                id: prop.id.dialog.file,
                width: 735,
                height: 480,
                open: function (o) {
                    _init(o);
                },
                close: function () {
                }
            });

            dlg.setBottomBtns(1, {
                event: function() {
                    dlg.close();
                }
            });

            this.Type = {
                array: 0,
                single: 1,
                directory: 2
            };

            var option;
            var curPath;
            var selectedFilePath;

            var dirMenu = kcaseQuery("#" + prop.id.dialog.file + " ." + prop.cs.mediaList).find("table");
            var dirTable = kcaseQuery("#" + prop.id.dialog.file + " ." + prop.cs.fileList).find("table");
            var curPathElement = kcaseQuery("#" + prop.id.dialog.file + " .txt-url");
            var changeDirBtn = kcaseQuery("#" + prop.id.dialog.file + " .file-url").find("button");
            var fileNameElement = kcaseQuery("#" + prop.id.dialog.file + " .filename-url").find("input");

            function FileListTable() {
                var table = [];

                var cnt = 0;

                this.get = function(n) {
                    return table[n];
                };

                this.add = function(f) {
                    table[cnt++] = f;
                };

                this.size = function() {
                    return cnt;
                };

                this.getTable = function() {
                    return table;
                };

                this.clear = function() {
                    cnt = 0;
                    table = [];
                };

                this.remove = function(index) {
                    var newTable = [];

                    for(var i = 0; i < cnt; i++) {
                        if (i != index) {
                            newTable.push(table[i]);
                        }
                    }

                    table = newTable;
                    cnt--;
                };
            }

            dlg.setBottomBtns(1, {
                event: function () {
                    kcaseQuery("#" + prop.id.p12Name).val("");
                    dlg.close();
                    prop.CANCEL_SUB_DIALOG();
                    prop.isSubView = false;
                }
            });

            this.setConfirmEvent = function(event){
                dlg.setBottomBtns(0, {
                    event: event
                });
            };

            function _setFileName() {
                var tempFileNames = "";
                for (var i = 0; i < selectedFilePath.size(); i++) {

                    if (i == 0) {
                        tempFileNames = selectedFilePath.get(i);
                    } else {
                        tempFileNames = tempFileNames + ", " + selectedFilePath.get(i);
                    }
                }
                fileNameElement.val(tempFileNames);
            }

            changeDirBtn.click(function () {
                var dirTable = kcaseQuery("#" + prop.id.dialog.file + " ." + prop.cs.fileList).find("table");
                var firstRow = dirTable.find("tr:first");
                var firstFile = firstRow.data("fileName");
                if (firstFile == "..") {
                    firstRow.click();
                }
            });

            var _init = function (o) {
            		prop.isSubView = true;
                curPathElement.val("");
                fileNameElement.val("");
                dirMenu.find("tr").remove();
                dirTable.find("tr").remove();

                var options = {
                    ext: ".*",
                    multi: false,
                    viewPath: false,
                    type: fileExplorerDlg.Type.array
                };

                if (o !== undefined) {
                    util.setOption(options, o);
                }

                option = options;

                if (option.success) {
                    fileExplorerDlg.setConfirmEvent(function() {
                        option.success(fileExplorerDlg.getSelectedFilePath().getTable());
                        dlg.close();
                    });
                }

                if (option.type == fileExplorerDlg.Type.array) {
                    selectedFilePath = new FileListTable();
                } else {
                    selectedFilePath = "";
                }
                _reqSelectList("내 문서", "icon_folder.png", "Documents");
                _reqSelectList("바탕 화면", "icon_folder.png", "Desktop");

                comm.reqRemovableDiskList(function (result) {
                    for (var i = 0; i < result.DriveList.length; i++) {
                        result.DriveList[i] = util.decodeUtf8(util.decode64(result.DriveList[i]));
                        var str = result.DriveList[i].substr(1, result.DriveList[i].length) + " (" + result.DriveList[i].charAt(0) + ":)";
                        _reqSelectList(str, "icon_removable_2.png", result.DriveList[i].charAt(0) + ":");
                    }
                });
            };

            var _reqSelectList = function (name, imgName, path) {
                var tr = kcaseQuery("<tr/>");
                var td = kcaseQuery("<td/>");
                var a = kcaseQuery("<a></a>");
                var span = kcaseQuery("<span></span>");
                span.css("background-image", "url(" + prop.ROOT_DIR + "/img/" + imgName + ")");

                if (selectedFilePath instanceof Object) {
                    selectedFilePath.clear();
                }

                tr.data("path", path);

                tr.click(function () {
                    dirMenu.find("tr").removeClass(prop.cs.certSelectedRow);
                    kcaseQuery(this).addClass(prop.cs.certSelectedRow);
                    var dirTable = kcaseQuery("#" + prop.id.dialog.file + " ." + prop.cs.fileList).find("table");
                    dirTable.find("tr").remove();
                    var reqPath = kcaseQuery(this).data("path");
                    reqPath = util.encode64(util.encodeUtf8(reqPath));
                    comm.reqDirectoryList(reqPath, option.ext, function (result) {

                        curPath = util.decodeUtf8(util.decode64(result.CurPath));
                        curPathElement.val(curPath);

                        for (var i = 0; i < result.DirList.length; i++) {
                            var fileName = util.decodeUtf8(util.decode64(result.DirList[i].FileName));
                            var isDir;

                            if (result.DirList[i].IsDir == 1) {
                                isDir = true;
                            } else {
                                isDir = false;
                            }

                            _appendDirList(isDir, fileName);
                        }

                        if (option.viewPath == true) {
                            selectedFilePath = curPath + "/";
                            fileNameElement.val(selectedFilePath);
                        }
                    });
                });

                a.append(span);
                a.append(name);
                td.append(a);
                tr.append(td);
                dirMenu.append(tr);
            };

            function _appendDirList(isDir, fileName) {
                var imgName;
                //var splitArray = fileName.split(".");

                if (isDir) {
                    imgName = "icon_folder.png";
                } else {
                    imgName = "itemimg.png";
                }

                if (selectedFilePath instanceof Object) {
                    selectedFilePath.clear();
                }

                fileNameElement.val("");

                /*if (splitArray[splitArray.length - 1] == "pfx") {
                 imgName = "itemimg.png";
                 isDir = false;
                 } else {
                 imgName = "icon_folder.png";
                 isDir = true;
                 }*/

                var tr = kcaseQuery("<tr/>");
                var td = kcaseQuery("<td/>");
                var a = kcaseQuery("<a></a>");
                var span = kcaseQuery("<span></span>");
                span.css("background-image", "url(" + prop.ROOT_DIR + "/img/" + imgName + ")");

                tr.data("fileName", fileName);
                tr.data("isDir", isDir);

                if (fileName == "..") {
                    tr.css("display", "none");
                }

                tr.click(function () {
                    dirTable.find("tr").removeClass(prop.cs.certSelectedRow);
                    kcaseQuery(this).addClass(prop.cs.certSelectedRow);

                    if (option.type == fileExplorerDlg.Type.array)  {
                        if (kcaseQuery(this).data("sel")) {
                            kcaseQuery(this).removeClass(prop.cs.certSelectedRow);
                            kcaseQuery(this).data("sel", false);
                            selectedFilePath.remove(kcaseQuery(this).data("Cnt"));

                            _setFileName();

                            return;
                        } else {
                            if (!option.multi) {
                                selectedFilePath.clear();
                                kcaseQuery(this).addClass(prop.cs.certSelectedRow);
                                kcaseQuery(this).data("sel", true);
                            } else {
                                if (selectedFilePath.size() > 4) {
                                    alert("파일은 5개까지 선택됩니다.");
                                    return;
                                }

                                kcaseQuery(this).addClass(prop.cs.certSelectedRow);
                                kcaseQuery(this).data("sel", true);
                            }
                        }
                    }

                    var selectedFileName = kcaseQuery(this).data("fileName");
                    var isDir = kcaseQuery(this).data("isDir");
                    var reqPath = curPath + "/" + selectedFileName;
                    if (isDir) {
                        reqPath = util.encode64(util.encodeUtf8(reqPath));
                        comm.reqDirectoryList(reqPath, option.ext, function (result) {
                            dirTable.find("tr").remove();
                            curPath = util.decodeUtf8(util.decode64(result.CurPath));
                            curPathElement.val(curPath);
                            for (var i = 0; i < result.DirList.length; i++) {
                                var fileName = util.decodeUtf8(util.decode64(result.DirList[i].FileName));
                                var isDir;

                                if (result.DirList[i].IsDir == 1) {
                                    isDir = true;
                                } else {
                                    isDir = false;
                                }

                                _appendDirList(isDir, fileName);
                            }

                            if (option.viewPath == true) {
                                selectedFilePath = curPath + "/";
                                fileNameElement.val(selectedFilePath);
                            }
                        });
                    } else {

                        if (option.type == fileExplorerDlg.Type.array) {
                            kcaseQuery(this).data("Cnt", selectedFilePath.size());
                            selectedFilePath.add(curPath + "/" + selectedFileName);

                            _setFileName();
                        } else if (option.type == fileExplorerDlg.Type.single) {
                            selectedFilePath = reqPath;
                            fileNameElement.val(selectedFilePath);
                        } else if (option.type == fileExplorerDlg.Type.directory) {
                            selectedFilePath = curPath + "/";
                            fileNameElement.val(selectedFilePath);
                        }
                    }
                });

                a.append(span);
                a.append(fileName);
                td.append(a);
                tr.append(td);
                dirTable.append(tr);
            }

            this.open = dlg.open;
            this.close = dlg.close;

            this.getSelectedFilePath = function() {
                return selectedFilePath;
            };
        }

        /**
         * Select Media Dialog Manager Base Class
         */
        function _SelectMediaDialogManagerBase() {
            var selMediaIdx = 0;
            var selectedMedia;
            var posBtnList = kcaseQuery("#" + prop.id.dialog.media).find("tbody button");
            var rbgNormalStr = "#" + prop.id.dialog.media + " .kc-rbg-normal";

            function _defaultMediaSet() {
            		prop.isSubView = true;
                posBtnList.removeClass("kc-rbg-pressed");
                posBtnList.addClass("kc-rbg-normal");

                kcaseQuery(rbgNormalStr + " .kc-ico-hdd").css("background", "url('" + prop.ROOT_DIR + "/img/icon_hdd_off.png')");
                kcaseQuery(rbgNormalStr + " .kc-ico-removable").css("background", "url('" + prop.ROOT_DIR + "/img/icon_removable_off.png')");
                kcaseQuery(rbgNormalStr + " .kc-ico-save-pkcs").css("background", "url('" + prop.ROOT_DIR + "/img/icon_save_pkcs_off.png')");
                kcaseQuery(rbgNormalStr + " .kc-ico-hw-pkcs").css("background", "url('" + prop.ROOT_DIR + "/img/icon_hw_pkcs_off.png')");
                kcaseQuery(rbgNormalStr + " .kc-ico-mobile").css("background", "url('" + prop.ROOT_DIR + "/img/icon_mobile_off.png')");
            }

            /* Select Media Dialog */
            var selMediaDlg = _makeDialog({
                id: prop.id.dialog.media,
                height: 250,
                open: function () {
                    _defaultMediaSet();
                },
                close: function () {
                }
            });
            posBtnList.click(function () {
                selMediaIdx = posBtnList.index(kcaseQuery(this));

                _defaultMediaSet();

                switch (selMediaIdx) {
                    case 0:
                        selectedMedia = prop.media.hardDisk;
                        kcaseQuery(rbgNormalStr + " .kc-ico-hdd").css("background", "url('" + prop.ROOT_DIR + "/img/icon_hdd.png')");
                        break;
                    case 1:
                        selectedMedia = prop.media.removableDisk;
                        kcaseQuery(rbgNormalStr + " .kc-ico-removable").css("background", "url('" + prop.ROOT_DIR + "/img/icon_removable.png')");
                        break;
                    case 2:
                        selectedMedia = prop.media.savetoken;
                        kcaseQuery(rbgNormalStr + " .kc-ico-save-pkcs").css("background", "url('" + prop.ROOT_DIR + "/img/icon_save_pkcs.png')");
                        break;
                    case 3:
                        selectedMedia = prop.media.pkcs11;
                        kcaseQuery(rbgNormalStr + " .kc-ico-hw-pkcs").css("background", "url('" + prop.ROOT_DIR + "/img/icon_hw_pkcs.png')");
                        break;
                    case 4:
                        selectedMedia = prop.media.mobile;
                        kcaseQuery(rbgNormalStr + " .kc-ico-mobile").css("background", "url('" + prop.ROOT_DIR + "/img/icon_mobile.png')");
                        break;
                }

                posBtnList.eq(selMediaIdx).removeClass("kc-rbg-normal");
                posBtnList.eq(selMediaIdx).addClass("kc-rbg-pressed");

            });
            selMediaDlg.setBottomBtns(1, {
                event: function () {
                    selMediaDlg.close();
                    prop.CANCEL_SUB_DIALOG();
                    prop.isSubView = false;
                }
            });
            this.getSelectedIdx = function () {
                return selectedMedia;
            };
            this.setConfirmBtn = function (event) {
                selMediaDlg.setBottomBtns(0, {
                    event: event
                });
            };
            this.open = function () {
                selMediaDlg.open();
            };
            this.close = function () {
                selMediaDlg.close();
            };
            this.setPosition = function(p) {
                selMediaDlg.setPosition(p);
            };
        }

        /**
         * Select Drive Manager Dialog Class
         */
        function _SelectDriveDialog() {
            var selDialog = _makeDialog({
                id: prop.id.dialog.drive,
                width: 400,
                height: 200,
                open: function (excludeDrive) {
                		prop.isSubView = true;
                    comm.reqRemovableDiskList(function (result) {
                        if (excludeDrive == undefined) excludeDrive = 0;
                        var i;
                        var sel = kcaseQuery("#" + prop.id.dialog.drive + " select");

                        sel.find("option").remove();

                        if (result.DriveList.length == 0) {
                            alert(prop.strings.NOT_EXIST_DISK);
                            selDriveDlg.close();
                        }

                        for (i = 0; i < result.DriveList.length; i++) {
                            result.DriveList[i] = util.decodeUtf8(util.decode64(result.DriveList[i]));
                            var drive = result.DriveList[i].charAt(0);
                            if (drive.charCodeAt(0) != excludeDrive) {
                                var optElement = kcaseQuery("<option/>");
                                optElement.text(result.DriveList[i].substr(1, result.DriveList[i].length) + " (" + result.DriveList[i].charAt(0) + ":)");
                                optElement.data("drive", result.DriveList[i].charAt(0));
                                sel.append(optElement);
                            }
                        }
                    });
                }
            });
            selDialog.setBottomBtns(1, {
                event: function () {
                    selDialog.close();
										prop.CANCEL_SUB_DIALOG();
										prop.isSubView = false;
                }
            });
            this.getSelectedDrive = function () {
                var sel = kcaseQuery("#" + prop.id.dialog.drive + " select");
                var selected = sel.find("option:selected");
                var drive = selected.data("drive");
                return drive.charCodeAt(0);
            };
            this.setConfirmBtn = function (event) {
                selDialog.setBottomBtns(0, {
                    event: event
                });
            };
            this.setPosition = function(p) {
                selDialog.setPosition(p);
            };
            this.open = function (ed) {
                selDialog.open(ed);
            };
            this.close = function () {
                selDialog.close();
            };
        }

        /**
         * Create Password Dialog Class
         */
        function _CreatePasswordDialog() {
            var pwList = kcaseQuery("#" + prop.id.dialog.createPw).find("input");
            var certPwDlg = _makeDialog({
                id: prop.id.dialog.createPw,
                width: 400,
                height: 400,
                open: function(option) {
                    _init(option);
                },close: function() {
                    pwList.val("");
                }
            });

            pwList.keydown(function(event) {
                if ( event.which == 13 ) {
                    event.preventDefault();
										event.stopPropagation();
                    kcaseQuery("#" + prop.id.dialog.createPw + " ." + prop.cs.btnLayout).find("button").eq(0).click();
                    return;
                }
            });

            var _service = undefined;

            function _init(option) {
            		prop.isSubView = true;
                if (option.service == "issue") {
                    _service = function () {
                        var certPw = util.getInputPassword(prop.id.dialog.createPw);
                        pwList.val("");
                        pwList.eq(0).focus();

                        comm.reqIssueCert(option, certPw, function (result) {
                            var status = result.Status;
                            if (status == prop.success) {
                                option.success(prop.strings.CERT_ISSUSE_SUCCESS);
                            } else {
                                var errMessage = prop.getErrorMsg(status);
                                if (result.ErrorMsg != undefined) {
                                    errMessage += util.decodeUtf8(result.ErrorMsg);
                                }
                                option.error(status, errMessage);
                            }

                            if (status != prop.errCode.pkimgr.PASSOWRD_COMPLEXITY[0]) {
                                certPwDlg.close();
                            }
                        });
                    }
                } else if (option.service == "issue_NT") {
                    _service = function () {
                        var certPw = util.getInputPassword(prop.id.dialog.createPw);
                        pwList.val("");
                        pwList.eq(0).focus();
												certPwDlg.close();
                        comm.reqIssueCert_NT(option, certPw, function (result) {
                            var status = result.Status;
                            if (status == prop.success) {
                                option.success(prop.strings.CERT_ISSUSE_SUCCESS);
                            } else {
                                var errMessage = prop.getErrorMsg(status);
                                if (result.ErrorMsg != undefined) {
                                    errMessage += util.decodeUtf8(result.ErrorMsg);
                                }
                                option.error(status, errMessage);
                            }

                            if (status != prop.errCode.pkimgr.PASSOWRD_COMPLEXITY[0]) {
                                //certPwDlg.close();
                            }
                        });
                    }
                }
            }

            certPwDlg.setBottomBtns(0, {
                event: function () {
                    var pw1Object, pw2Object;

                    if (!prop.usingNosAdapter) {
                        pw1Object = {
                            IsSec: 0,
                            Data: pwList.eq(0).val()
                        };
                        pw2Object = {
                            IsSec: 0,
                            Data: pwList.eq(1).val()
                        };
                    } else {
                        var pData1 = pwList.eq(0).attr("name");

                        pw1Object = {
                            IsSec: 1,
                            Table: npPfsCtrl.GetResultField(pData1+"form", pData1),
                            Data: npPfsCtrl.GetReplaceField(pData1+"form", pData1)
                        };
                        var pData2 = pwList.eq(1).attr("name");
                        pw2Object = {
                            IsSec: 1,
                            Table: npPfsCtrl.GetResultField(pData2+"form", pData2),
                            Data: npPfsCtrl.GetReplaceField(pData2+"form", pData2)
                        };
                    }

                    if (pw1Object.Data.length <= 0) {
                        alert("인증서 비밀번호를 입력해주십시오.");
                        pwList.eq(0).focus();
                        return;
                    } else if (pw2Object.Data.length <= 0) {
                        alert("비밀번호 재입력을 입력해주십시오.");
                        pwList.eq(1).focus();
                        return;
                    } else {
                        if (pw1Object.Data != pw2Object.Data) {
                            alert("비밀번호가 일치하지 않습니다.");
                            return;
                        }

                        if (_service != undefined) {
                            _service();
                        }
                    }
                }
            });
            certPwDlg.setBottomBtns(1, {
                event: function () {
                    certPwDlg.close();
                    selectMediaDlg.open();
                    prop.CANCEL_SUB_DIALOG();
                    prop.isSubView = false;
                }
            });

            this.getPassword = function () {
                return util.getInputPassword(prop.id.dialog.createPw);
            };
            this.setPosition = function(p) {
                certPwDlg.setPosition(p);
            };
            this.open = certPwDlg.open;
            this.close = certPwDlg.close;
        }

        /**
         * Input Permit Code Dialog Class
         */
        function _InputPermitCodeDialog() {
            var codes = kcaseQuery("#" + prop.id.dialog.permitCode).find("input");
            var dlg = _makeDialog({
                id: prop.id.dialog.permitCode,
                width: 360,
                height: 190,
                open: function(option) {
                    _init(option);
                },close: function() {
                    codes.val("");
                }
            });

            codes.keydown(function(event) {
                if (event.which == 13) {
                    event.preventDefault();
                    kcaseQuery("#" + prop.id.dialog.permitCode).find("button").click();
                }
            });

            function _init(option) {
                if (option == undefined) {
                    return;
                }

                if (option.service == "importInit") {
                    dlg.setPosition(option.position);

                    dlg.setBottomBtns(0, {
                        event: function() {
                            var code = codes.eq(0).val() + codes.eq(1).val();

                            comm.reqPermitCodeForMobile(option.peerCert, code, function(result) {
                                if (result.Status != prop.success) {
                                    option.error(status, prop.getErrorMsg(status));
                                } else {
                                    option.success(result.Output);
                                }

                                dlg.close();
                            });
                        }
                    });
                } else if (option.service == "import") {
                    dlg.setBottomBtns(0, {
                        event: function() {
                            dlg.close();

                            var reqOpt = new Object();
                            var mediaList = kcaseQuery("#" + prop.id.dialog.media + " tr").eq(1);
                            mediaList.find("td").find("button").attr("disabled", true);

                            mediaList.find("td").eq(0).find("button").attr("disabled", false);
                            mediaList.find("td").eq(1).find("button").attr("disabled", false);

                            selectMediaDlg.setPosition(option.position);
                            selectMediaDlg.setConfirmBtn(function () {
                                reqOpt.media = selectMediaDlg.getSelectedIdx();

                                pwDialog.setPosition(option.position);
                                pwDialog.setConfirmBtn(function () {
                                    var pw = pwDialog.getPassword();
                                    if(!util.verifyInputPassword(pw, prop.media.hardDisk)) {
                                        return;
                                    }

                                    reqOpt.pfx = option.pfx;
                                    reqOpt.peerCert = option.peerCert;
                                    comm.reqImportCertForMobile(reqOpt, pw, function(result) {
                                        if (result.Status != prop.success) {
                                            option.error(status, prop.getErrorMsg(status));
                                        } else {
                                            option.success(result.Output);
                                        }

                                        dlg.close();
                                    });
                                });

                                switch (reqOpt.media) {
                                    case prop.media.hardDisk:
                                        reqOpt.drive = reqOpt.media;
                                        selectMediaDlg.close();
                                        pwDialog.open();
                                        break;
                                    case prop.media.removableDisk:
                                        selDriveDlg.setPosition(option.position);
                                        selDriveDlg.open();
                                        selDriveDlg.setConfirmBtn(function () {
                                            reqOpt.drive = selDriveDlg.getSelectedDrive();
                                            selDriveDlg.close();
                                            selectMediaDlg.close();
                                            pwDialog.open();
                                        });
                                        break;
                                }
                            });
                            selectMediaDlg.open();
                        }
                    });
                }
            }

            this.setConfirmBtn = function (event) {
                dlg.setBottomBtns(0, {
                    event: event
                });
            };
            this.getCode = function() {
                return codes.eq(0).val() + codes.eq(1).val();
            };
            this.setPosition = function(p) {
                dlg.setPosition(p);
            };
            this.open = dlg.open;
            this.close = dlg.close;
        }

        /**
         * Input Password Dialog Class
         */
        function _InputPasswordDialog() {
            var pwBox = kcaseQuery("#" + prop.id.dialog.pw).find("input");
            /* Input Password Dialog */
            var pwDlg = _makeDialog({
                id: prop.id.dialog.pw,
                width: 360,
                height: 200,
                open: function() {
                },close: function() {
                    pwBox.val("");
                }
            });

            pwBox.keydown(function(event) {
                if (event.which == 13) {
                    event.preventDefault();
                    kcaseQuery("#" + prop.id.dialog.pw).find("button").click();
                }
            });

            this.getPassword = function () {
                return util.getInputPassword(prop.id.dialog.pw);
            };
            this.setConfirmBtn = function (event) {
                pwDlg.setBottomBtns(0, {
                    event: event
                });
            };
            this.setPosition = function(p) {
                pwDlg.setPosition(p);
            };
            this.open = pwDlg.open;
            this.close = pwDlg.close;
        }

        /**
         * Input Pin Dialog Class
         */
        function _InputPinDialog() {
            var pinBox = kcaseQuery("#" + prop.id.dialog.pin).find("input");

            /* Input Pin Dialog */
            var pinDlg = _makeDialog({
                id: prop.id.dialog.pin,
                width: 360,
                height: 200,
                open: function() {
                	prop.isSubView = true;
                },
                close: function () {
                    pinBox.val("");
                }
            });

            pinBox.keydown(function(event) {
                if (event.which == 13) {
                    event.preventDefault();
                    kcaseQuery("#" + prop.id.dialog.pin).find("button").click();
                }
            });

            this.getPassword = function () {
                return util.getInputPassword(prop.id.dialog.pin);
            };
            this.setConfirmBtn = function (event) {
                pinDlg.setBottomBtns(0, {
                    event: event
                });
            };
            pinDlg.setBottomBtns(1, {
                event: function() {
                    pinDlg.close();
                    prop.CANCEL_SUB_DIALOG();
                    prop.isSubView = false;
                }
            });
            this.open = pinDlg.open;
            this.close = pinDlg.close;
        }

        /**
         * Input SToken Password Class
         */
        function _InputSTokenPwDialog() {
            var pwBox = kcaseQuery("#" + prop.id.dialog.stpw).find("input");

            /* Input Pin Dialog */
            var dlg = _makeDialog({
                id: prop.id.dialog.stpw,
                width: 360,
                height: 200,
                open: function() {
                	prop.isSubView = true;
                },
                close: function () {
                    pwBox.val("");
                }
            });

            pwBox.keydown(function(event) {
                if (event.which == 13) {
                    event.preventDefault();
                    kcaseQuery("#" + prop.id.dialog.stpw).find("button").click();
                }
            });

            dlg.setBottomBtns(1, {
                event: function() {
                    dlg.close();
                    prop.CANCEL_SUB_DIALOG();
                    prop.isSubView = false;
                }
            });

            this.getPassword = function () {
                return util.getInputPassword(prop.id.dialog.stpw);
            };
            this.setConfirmBtn = function (event) {
                dlg.setBottomBtns(0, {
                    event: event
                });
            };
            this.open = dlg.open;
            this.close = dlg.close;
        }

        /**
         * Save Token Dialog Class
         */
        function _SaveTokenDialog() {
            var tableElement = kcaseQuery("#" + prop.id.dialog.saveToken + " ." + prop.cs.tableView).find("table");
            var pkcs11List;
            var selectedName;
            var selectP11Pos;

            var stDialog = _makeDialog({
                id: prop.id.dialog.saveToken,
                width: 360,
                height: 280,
                open: function() {
                		prop.isSubView = true;
                    selectP11Pos = 0;

                    comm.reqSaveTokenList(function (result) {
                        kcaseQuery("." + prop.cs.stList).remove();

                        for (var i = 0; i < result.Output.length; i++) {
                            var row = kcaseQuery("<tr/>");
                            row.addClass(prop.cs.stList);
                            row.css("cursor", "pointer");
                            var data = kcaseQuery("<td/>");

                            data.text(result.Output[i]);
                            row.append(data);

                            row.click(function () {
                                kcaseQuery("." + prop.cs.stList).removeClass(prop.cs.certSelectedRow);
                                kcaseQuery(this).addClass(prop.cs.certSelectedRow);
                                selectedName = kcaseQuery(this).text();
                            });

                            tableElement.append(row);
                        }
                        pkcs11List = kcaseQuery("#" + prop.id.dialog.saveToken + " ." + prop.cs.tableView);
                        pkcs11List.find("." + prop.cs.stList).eq(0).click();

                        pkcs11List.keydown(function(event) {
                            var p11ListRow = kcaseQuery("." + prop.cs.stList);

                            if (event.which == 38) {    // Up Arrow
                                event.preventDefault();
                                if (selectP11Pos != 0) {
                                    selectP11Pos--;
                                }
                            } else if (event.which == 40) { // Down Arrow
                                event.preventDefault();
                                if (selectP11Pos < (p11ListRow.length - 1)) {
                                    selectP11Pos++;
                                }
                            } else {
                                return;
                            }
                            p11ListRow.eq(selectP11Pos).click();
                        });
                    });
                },
                close: function () {
                	if(pkcs11List != null)
                    pkcs11List.unbind();
                }
            });

            this.setPosition = function(p) {
                stDialog.setPosition(p);
            };
            this.getSelectedName = function() {
                return selectedName;
            };
            this.setConfirmBtn = function (event) {
                stDialog.setBottomBtns(0, {
                    event: event
                });
            };
            stDialog.setBottomBtns(1, {
                event: function () {
                    stDialog.close();
                    prop.CANCEL_SUB_DIALOG();
                    prop.isSubView = false;
                }
            });
            this.open = stDialog.open;
            this.close = stDialog.close;
        }

        /**
         * Select Cert Abolition Reason Class
         */
        function _CertAbolitionReasonDialog() {
            var dlg = _makeDialog({
                id: prop.id.dialog.reason,
                width: 400,
                height: 250,
                open: function() {
                	prop.isSubView = true;
                },
                close: function () {
                }
            });

            kcaseQuery("#" + prop.id.dialog.reason).find("ul").keypress(function(event) {
                if ( event.which == 13 ) {
                    event.preventDefault();
                    kcaseQuery("#" + prop.id.dialog.reason + " ." + prop.cs.btnLayout).find("button").eq(0).click();
                    return;
                }
            });

            dlg.setBottomBtns(1, {
                event: function() {
                    dlg.close();
                    prop.CANCEL_SUB_DIALOG();
                    prop.isSubView = false;
                }
            });
            this.setConfirmBtn = function (event) {
                dlg.setBottomBtns(0, {
                    event: event
                });
            };
            this.open = dlg.open;
            this.close = dlg.close;
        }

        /**
         * Input Virtual Identification Dialog Class
         */
        function _InputVIDDialog() {
            var vid = kcaseQuery("#" + prop.id.dialog.vid).find("input");
            var dlg = _makeDialog({
                id: prop.id.dialog.vid,
                width: 360,
                height: 240,
                open: function() {
                },close: function() {
                    vid.val("");
                }
            });

            vid.keydown(function(event) {
                if (event.which == 13) {
                    event.preventDefault();
                    kcaseQuery("#" + prop.id.dialog.vid).find("button").click();
                }
            });

            this.setConfirmBtn = function (event) {
                dlg.setBottomBtns(0, {
                    event: event
                });
            };
            this.getVID = function() {
                return vid.val();
            };
            this.open = dlg.open;
            this.close = dlg.close;
        }

        /* Certificate Dialog*/
        new function() {
            var certList = kcaseQuery("#" + prop.id.certList);
            /* Cert Dialog */
            var certDlg = _makeDialog({
                id: prop.id.dialog.cert,
                mainTitle: true,
                width: 450,
                height: 600,
                open: function (options) {
                    util.loadDefaultCertListSize();

                    if (options.service == "admin") {
                        _setAdmin();
                    } else {
                        _setDefault(options);

                        certDlg.setBottomBtns(0, {
                            event: function() {
                                var certInfo = certManager.checkSelectedCert();

                                if (certInfo == undefined) {
                                    alert(prop.strings.NOT_SELECTED_CERT);
                                    return;
                                }
                                _certDialogServiceProc(certInfo, options);
                            },
                            show: true,
                            name: "확인"
                        });
                    }
                },
                close: function () {
                    kcaseQuery("#" + prop.id.dialog.cert + " ." + prop.cs.pwBox).val("");
                    kcaseQuery(".kc-dialog-titlebar").css("display", "block");
                }
            });
            certList.focusout(function () {
                kcaseQuery("." + prop.cs.widget).css("display", "none");
            });
            certDlg.getSelectedCertInfo = function() {
                return certManager.checkSelectedCert();
            };
            this.close = certDlg.close;

            function _certDialogServiceProc(certInfo, options) {
                var service = options.service;
                var pw;

                if (service == "sign") {
                    if (options.signedDN == true) {
                        options.input = certInfo.subjectDN;
                    }

                    if (certInfo.media == prop.media.pkcs11) {
                        pinDialog.setConfirmBtn(function() {
                            pw = pinDialog.getPassword();
                            if(!util.verifyInputPassword(pw, certInfo.media)) {
                                return;
                            }

                            var signObj = {
                                progName: p11DlgManager.getSelectedName(),
                                pinPw: pw,
                                input: util.encode64(util.encodeUtf8(options.input))
                            };
                            comm.reqSignDataPkcs11(certInfo, signObj, function(result) {
                                pinDialog.close();
                                _signResult(result);
                            });
                        });
                        pinDialog.open();
                    } else {
                        pw = util.getInputPassword(prop.id.dialog.cert);
                        if(!util.verifyInputPassword(pw, certInfo.media)) {
                            return;
                        }

                        var signObj = {
                            algorithm: options.algorithm,
                            keybit: options.keybit,
                            hash: options.hash,
                            input: util.encode64(util.encodeUtf8(options.input))
                        };

                        comm.reqGenSignData(certInfo, pw, signObj, function (result) {
                            _signResult(result);
                        });
                    }

                    function _signResult(result) {
                        var status = result.Status;
                        var output = result.Output;

                        if (status != prop.success) {
				                		if(status == prop.errCode.pkcs.INVALID_PASSWORD_EXCESS[0]){
                            		certDlg.close();
				                				prop.INVALID_PASSWORD_EXCESS(result.Status, prop.getErrorMsg(result.Status));
				                		}
				                		else {
                            	options.error(result.Status, prop.getErrorMsg(result.Status));
                            }
                        } else {
                            certDlg.close();

                            if (options.signedDN) {
                                output = {
                                    sign: result.Output,
                                    dn: util.encode64(util.encodeUtf8(certInfo.subjectDN))
                                };
                            }
                            options.success(output);
                        }
                    }
                } else if (service == "vid") {
                    if (certInfo.media == prop.media.pkcs11) {
                        pinDialog.setConfirmBtn(function() {
                            pw = pinDialog.getPassword();
                            if(!util.verifyInputPassword(pw, certInfo.media)) {
                                return;
                            }

                            _vidProcess();
                        });
                        pinDialog.open();
                    } else {
                        pw = util.getInputPassword(prop.id.dialog.cert);
                        if(!util.verifyInputPassword(pw, certInfo.media)) {
                            return;
                        }

                        _vidProcess();
                    }

                    function _vidProcess() {
                        if (!prop.isSaveServerCert) {
                            comm.setEnvCert(options.peerCert, function(response) {
                                if (response.Status == prop.success) {
                                    _callVidRequest();
                                    prop.isSaveServerCert = true;
                                } else {
                                    options.error(response.Status, prop.getErrorMsg(response.Status));
                                }
                            });
                        } else {
                            _callVidRequest();
                        }

                        function _callVidRequest() {
                            comm.reqVerifyVidInfo(certInfo, pw, options.vid, options.vidopt, function (result) {
                                _vidResult(result);
                            });
                        }

                        function _vidResult(result) {
                            var status = result.Status;

                            if (status != prop.success) {
					                		if(status == prop.errCode.pkcs.INVALID_PASSWORD_EXCESS[0]){
	                            		certDlg.close();
	                            		pinDialog.close();
					                				prop.INVALID_PASSWORD_EXCESS(result.Status, prop.getErrorMsg(result.Status));
					                		}
					                		else {
	                            	options.error(result.Status, prop.getErrorMsg(result.Status));
	                            }
                            } else {
                                certDlg.close();
                                pinDialog.close();
                                options.success(result.Output);
                            }
                        }
                    }
                } else if (service == "vidHira") {
                    if (certInfo.media == prop.media.pkcs11) {
                        pinDialog.setConfirmBtn(function() {
                            pw = pinDialog.getPassword();
                            if(!util.verifyInputPassword(pw, certInfo.media)) {
                                return;
                            }

                            _vidHiraProcess();
                        });
                        pinDialog.open();
                    } else {
                        pw = util.getInputPassword(prop.id.dialog.cert);
                        if(!util.verifyInputPassword(pw, certInfo.media)) {
                            return;
                        }

                        _vidHiraProcess();
                    }

                    function _vidHiraProcess() {

                        comm.reqVerifyVidInfoHira(certInfo, pw, options.vid, function (result) {
                                _vidHiraResult(result);
                            });

                        function _vidHiraResult(result) {
                            var status = result.Status;

                            if (status != prop.success) {
					                		if(status == prop.errCode.pkcs.INVALID_PASSWORD_EXCESS[0]){
	                            		certDlg.close();
	                            		pinDialog.close();
					                				prop.INVALID_PASSWORD_EXCESS(result.Status, prop.getErrorMsg(result.Status));
					                		}
					                		else {
	                            	options.error(result.Status, prop.getErrorMsg(result.Status));
	                            }
                            } else {
                                certDlg.close();
                                pinDialog.close();
                                options.success(result.Output);
                            }
                        }
                    }
                } else if (service == "vidASP") {
                    if (certInfo.media == prop.media.pkcs11) {
                        pinDialog.setConfirmBtn(function() {
                            pw = pinDialog.getPassword();
                            if(!util.verifyInputPassword(pw, certInfo.media)) {
                                return;
                            }

                            ASP_vidProcess();
                        });
                        pinDialog.open();
                    } else {
                        pw = util.getInputPassword(prop.id.dialog.cert);
                        if(!util.verifyInputPassword(pw, certInfo.media)) {
                            return;
                        }

                        ASP_vidProcess();
                    }

					// 2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix

                    function ASP_vidProcess() {
                        if (!prop.isSaveServerCert) {
                            comm.setEnvCert(options.peerCert, function(response) {
                                if (response.Status == prop.success) {
                                    ASP_callVidRequest();
                                    prop.isSaveServerCert = true;
                                } else {
                                    options.error(response.Status, prop.getErrorMsg(response.Status));
                                }
                            });
                        } else {
                            ASP_callVidRequest();
                        }

                        function ASP_callVidRequest() {
                            comm.ASP_reqVerifyVidInfo(certInfo, pw, options.vid, options.vidopt, function (result) {
                                ASP_vidResult(result);
                            });
                        }

						// 2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix

                        function ASP_vidResult(result) {
                            var status = result.Status;

                            if (status != prop.success) {
					                		if(status == prop.errCode.pkcs.INVALID_PASSWORD_EXCESS[0]){
	                            		certDlg.close();
	                            		pinDialog.close();
					                				prop.INVALID_PASSWORD_EXCESS(result.Status, prop.getErrorMsg(result.Status));
					                		}
					                		else {
	                            	options.error(result.Status, prop.getErrorMsg(result.Status));
	                            }
                            } else {
                                certDlg.close();
                                pinDialog.close();
                                options.success(result.Output);
                            }
                        }
                    }
                } else if (service == "login") {
                    if (certInfo.media == prop.media.pkcs11) {
                        pinDialog.setConfirmBtn(function() {
                            pw = pinDialog.getPassword();
                            if(!util.verifyInputPassword(pw, certInfo.media)) {
                                return;
                            }

                            _loginProcess();
                        });
                        pinDialog.open();
                    } else {
                        pw = util.getInputPassword(prop.id.dialog.cert);
                        if(!util.verifyInputPassword(pw, certInfo.media)) {
                            return;
                        }

                        _loginProcess();
                    }

                    function _loginProcess() {
                        var loginObj = {
                            vid: options.vid,
                            progName: p11DlgManager.getSelectedName()
                        };

                        if (!prop.isSaveServerCert) {
                            comm.setEnvCert(options.peerCert, function(response) {
                                if (response.Status == prop.success) {
                                    _callLoginRequest();
                                    prop.isSaveServerCert = true;
                                } else {
                                    options.error(response.Status, prop.getErrorMsg(response.Status));
                                }
                            });
                        } else {
                            _callLoginRequest();
                        }

                        function _callLoginRequest() {
                            comm.reqCertLogin(certInfo, pw, loginObj, function(result) {
                                var status = result.Status;

                                if(status == prop.success) {
                                    certDlg.close();
                                    pinDialog.close();
                                    options.success(result.Output);
                                } else {
							                		if(status == prop.errCode.pkcs.INVALID_PASSWORD_EXCESS[0]){
			                            		certDlg.close();
			                            		pinDialog.close();
							                				prop.INVALID_PASSWORD_EXCESS(result.Status, prop.getErrorMsg(result.Status));
							                		}
							                		else {
			                            	options.error(result.Status, prop.getErrorMsg(result.Status));
			                            }
                                }
                            });
                        }
                    }
                } else if (service == "loginASP") {
                    if (certInfo.media == prop.media.pkcs11) {
                        pinDialog.setConfirmBtn(function() {
                            pw = pinDialog.getPassword();
                            if(!util.verifyInputPassword(pw, certInfo.media)) {
                                return;
                            }

                            ASP_loginProcess();
                        });
                        pinDialog.open();
                    } else {
                        pw = util.getInputPassword(prop.id.dialog.cert);
                        if(!util.verifyInputPassword(pw, certInfo.media)) {
                            return;
                        }

                        ASP_loginProcess();
                    }

					// 2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix

                    function ASP_loginProcess() {
                        var loginObj = {
                            vid: options.vid,
                            progName: p11DlgManager.getSelectedName()
                        };

                        if (!prop.isSaveServerCert) {
                            comm.setEnvCert(options.peerCert, function(response) {
                                if (response.Status == prop.success) {
                                    ASP_callLoginRequest();
                                    prop.isSaveServerCert = true;
                                } else {
                                    options.error(response.Status, prop.getErrorMsg(response.Status));
                                }
                            });
                        } else {
                            ASP_callLoginRequest();
                        }

						// 2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix

                        function ASP_callLoginRequest() {
                            comm.ASP_reqCertLogin(certInfo, pw, loginObj, function(result) {
                                var status = result.Status;

                                if(status == prop.success) {
                                    certDlg.close();
                                    pinDialog.close();
                                    options.success(result.Output);
                                } else {
								                		if(status == prop.errCode.pkcs.INVALID_PASSWORD_EXCESS[0]){
				                            		certDlg.close();
				                            		pinDialog.close();
								                				prop.INVALID_PASSWORD_EXCESS(result.Status, prop.getErrorMsg(result.Status));
								                		}
								                		else {
				                            	options.error(status, prop.getErrorMsg(status));
				                            }
                                }
                            });
                        }
                    }
                } else if (service == "secLogin") {
                    if (certInfo.media == prop.media.pkcs11) {
                        pinDialog.setConfirmBtn(function() {
                            pw = pinDialog.getPassword();
                            if(!util.verifyInputPassword(pw, certInfo.media)) {
                                return;
                            }

                            _secLoginProcess();
                        });
                        pinDialog.open();
                    } else {
                        pw = util.getInputPassword(prop.id.dialog.cert);
                        if(!util.verifyInputPassword(pw, certInfo.media)) {
                            return;
                        }

                        _secLoginProcess();
                    }

                    function _secLoginProcess() {
                        if (!prop.isSaveServerCert) {
                            comm.setEnvCert(options.peerCert, function(response) {
                                if (response.Status == prop.success) {
                                    _callLoginProc();
                                    prop.isSaveServerCert = true;
                                } else {
                                    options.error(response.Status, prop.getErrorMsg(response.Status));
                                }
                            });
                        } else {
                            _callLoginProc();
                        }

                        function _callLoginProc() {
                            comm.reqSecChannelLogin(certInfo, pw, options.algorithm, function(result) {
                                var status = result.Status;

                                if(status == prop.success) {
                                    certDlg.close();
                                    pinDialog.close();
                                    options.success(result.Output);
                                } else {
                                    if(status == prop.errCode.pkcs.INVALID_PASSWORD_EXCESS[0]){
				                            		certDlg.close();
				                            		pinDialog.close();
								                				prop.INVALID_PASSWORD_EXCESS(result.Status, prop.getErrorMsg(result.Status));
								                		}
								                		else {
				                            	options.error(status, prop.getErrorMsg(status));
				                            }
                                }
                            });
                        }
                    }
                } else if (service == "secLoginASP") {
                    if (certInfo.media == prop.media.pkcs11) {
                        pinDialog.setConfirmBtn(function() {
                            pw = pinDialog.getPassword();
                            if(!util.verifyInputPassword(pw, certInfo.media)) {
                                return;
                            }

                            ASP_secLoginProcess();
                        });
                        pinDialog.open();
                    } else {
                        pw = util.getInputPassword(prop.id.dialog.cert);
                        if(!util.verifyInputPassword(pw, certInfo.media)) {
                            return;
                        }

                        ASP_secLoginProcess();
                    }

					// 2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix

                    function ASP_secLoginProcess() {
                        if (!prop.isSaveServerCert) {
                            comm.setEnvCert(options.peerCert, function(response) {
                                if (response.Status == prop.success) {
                                    ASP_callLoginProc();
                                    prop.isSaveServerCert = true;
                                } else {
                                    options.error(response.Status, prop.getErrorMsg(response.Status));
                                }
                            });
                        } else {
                            ASP_callLoginProc();
                        }

						// 2017-07-11 DYLEE ASP 함수명 변경 suffix -> prefix

                        function ASP_callLoginProc() {
                            comm.ASP_reqSecChannelLogin(certInfo, pw, options.algorithm, function(result) {
                                var status = result.Status;

                                if(status == prop.success) {
                                    certDlg.close();
                                    pinDialog.close();
                                    options.success(result.Output);
                                } else {
                                    if(status == prop.errCode.pkcs.INVALID_PASSWORD_EXCESS[0]){
				                            		certDlg.close();
				                            		pinDialog.close();
								                				prop.INVALID_PASSWORD_EXCESS(result.Status, prop.getErrorMsg(result.Status));
								                		}
								                		else {
				                            	options.error(status, prop.getErrorMsg(status));
				                            }
                                }
                            });
                        }
                    }
                } else if (service == "multiDev") {
                    pw = util.getInputPassword(prop.id.dialog.cert);
                    if(!util.verifyInputPassword(pw, certInfo.media)) {
                        return;
                    }

                    comm.reqDecryptMultiEnvelopedData(certInfo, pw, options.input, function (result) {
                        var status = result.Status;

                        if (status != prop.success) {
                            options.error(status, prop.getErrorMsg(status));
                        } else {
                            certDlg.close();
                            options.success(result.Output);
                        }
                    });
                } else if (service == "getCert") {
                    if (certInfo.media == prop.media.pkcs11) {
                        pinDialog.setConfirmBtn(function() {
                            pw = pinDialog.getPassword();
                            if(!util.verifyInputPassword(pw, certInfo.media)) {
                                return;
                            }

                            _getCertProcess();
                        });
                        pinDialog.open();
                    } else {
                        pw = util.getInputPassword(prop.id.dialog.cert);
                        if(!util.verifyInputPassword(pw, certInfo.media)) {
                            return;
                        }

                        _getCertProcess();
                    }

                    function _getCertProcess() {
                        comm.reqGetCertData(certInfo, pw, function(result) {
                            var status = result.Status;

                            if(status != prop.success) {
                                options.error(status, prop.getErrorMsg(status));
                            } else {
                                certDlg.close();
                                pinDialog.close();
                                options.success(result.Output);
                            }
                        });
                    }
                } else if (service == "pkiManager") {

                    function reqPKIManagerResult(result) {
                        var status = result.Status;
                        var successMsg = undefined;

                        switch (options.menu) {
                            case kcaseagt.pkiMode.RENEWAL:
                                successMsg = prop.strings.CERT_RENEWAL_SUCCESS;
                                break;
                            case kcaseagt.pkiMode.KEYRENEWAL:
                                successMsg = prop.strings.CERT_KEYRENEWAL_SUCCESS;
                                break;
                            case kcaseagt.pkiMode.SUSPENSION:
                                successMsg = prop.strings.CERT_SUSPENSION_SUCCESS;
                                break;
                            case kcaseagt.pkiMode.ABOLITION:
                                successMsg = prop.strings.CERT_ABOLITION_SUCCESS;
                                break;
                        }

                        if (status == prop.success) {
                            alert(successMsg);
                        } else {
                            var errMessage = prop.getErrorMsg(status);
                            if (result.ErrorMsg != undefined) {
                                errMessage += util.decodeUtf8(result.ErrorMsg);
                            }

                            alert(status + " : " + errMessage);
                        }
                        reasonDlg.close();
                        certDlg.close();
                    }

                    if (certInfo != undefined) {
                        if (certInfo.expirationDate < 0) {
                            var serviceStr = "";
                            if (options.menu == kcaseagt.pkiMode.SUSPENSION) {
                                serviceStr = "효력정지";
                            } else if (options.menu == kcaseagt.pkiMode.ABOLITION) {
                                serviceStr = "만료";
                            } else if (options.menu == kcaseagt.pkiMode.KEYRENEWAL) {
                                serviceStr = "키갱신";
                            } else if (options.menu == kcaseagt.pkiMode.RENEWAL) {
                                serviceStr = "갱신";
                            }

                            alert("만료된 인증서는 " + serviceStr + " 할 수 없습니다.\n해당 인증서는 " + certInfo.notAfter + "에 만료되었습니다.");
                            return;
                        }

                        pw = util.getInputPassword(prop.id.dialog.cert);
                        if(!util.verifyInputPassword(pw, certInfo.media)) {
                            return;
                        }

                        if (options.menu == kcaseagt.pkiMode.ABOLITION) {
                            if (confirm("선택된 인증서를 폐지하시겠습니까?")) {
                                reasonDlg.setConfirmBtn(function() {
                                    var reason = kcaseQuery("input[name=abolition_reason]:checked").val();

                                    comm.reqPKIManager(options, certInfo, pw, reason, reqPKIManagerResult);
                                });
                                reasonDlg.open();
                            }
                        } else {
                            comm.reqPKIManager(options, certInfo, pw, undefined, reqPKIManagerResult);
                        }
                    }
                } else if (service == "pkiManager_NT") {

                    function reqPKIManagerResult(result) {
                        var status = result.Status;
                        var successMsg = undefined;

                        switch (options.menu) {
                            case kcaseagt.pkiMode.RENEWAL:
                                successMsg = prop.strings.CERT_RENEWAL_SUCCESS;
                                break;
                            case kcaseagt.pkiMode.KEYRENEWAL:
                                successMsg = prop.strings.CERT_KEYRENEWAL_SUCCESS;
                                break;
                            case kcaseagt.pkiMode.SUSPENSION:
                                successMsg = prop.strings.CERT_SUSPENSION_SUCCESS;
                                break;
                            case kcaseagt.pkiMode.ABOLITION:
                                successMsg = prop.strings.CERT_ABOLITION_SUCCESS;
                                break;
                        }

                        if (status == prop.success) {
                            alert(successMsg);
                        } else {
                            var errMessage = prop.getErrorMsg(status);
                            if (result.ErrorMsg != undefined) {
                                errMessage += util.decodeUtf8(result.ErrorMsg);
                            }

                            alert(status + " : " + errMessage);
                        }
                        reasonDlg.close();
                        certDlg.close();
                    }

                    if (certInfo != undefined) {
                        if (certInfo.expirationDate < 0) {
                            var serviceStr = "";
                            if (options.menu == kcaseagt.pkiMode.SUSPENSION) {
                                serviceStr = "효력정지";
                            } else if (options.menu == kcaseagt.pkiMode.ABOLITION) {
                                serviceStr = "만료";
                            } else if (options.menu == kcaseagt.pkiMode.KEYRENEWAL) {
                                serviceStr = "키갱신";
                            } else if (options.menu == kcaseagt.pkiMode.RENEWAL) {
                                serviceStr = "갱신";
                            }

                            alert("만료된 인증서는 " + serviceStr + " 할 수 없습니다.\n해당 인증서는 " + certInfo.notAfter + "에 만료되었습니다.");
                            return;
                        }

                        pw = util.getInputPassword(prop.id.dialog.cert);
                        if(!util.verifyInputPassword(pw, certInfo.media)) {
                            return;
                        }

                        if (options.menu == kcaseagt.pkiMode.ABOLITION) {
                            if (confirm("선택된 인증서를 폐지하시겠습니까?")) {
                                reasonDlg.setConfirmBtn(function() {
                                    var reason = kcaseQuery("input[name=abolition_reason]:checked").val();

                                    comm.reqPKIManager_NT(options, certInfo, pw, reason, reqPKIManagerResult);
                                });
                                reasonDlg.open();
                            }
                        } else {
                            comm.reqPKIManager_NT(options, certInfo, pw, undefined, reqPKIManagerResult);
                        }
                    }
                } else if (service == "fHashSign") {
                    if (certInfo != undefined) {
                        pw = util.getInputPassword(prop.id.dialog.cert);
                        if(!util.verifyInputPassword(pw, certInfo.media)) {
                            return;
                        }

                        for (var i = 0; i < options.inputPath.length; i++) {
                            options.inputPath[i] = util.encode64(util.encodeUtf8(options.inputPath[i]));
                        }

                        comm.reqSignFileHash(options.inputPath, certInfo, pw, function (result) {
                            if (result.Status == prop.success) {
                                options.success(result.Output);
                            } else {
                                options.error(result.Status, prop.getErrorMsg(result.Status));
                            }
                            certDlg.close();
                        });
                    }
                } else if (service == "fFileSign") {
                    if (certInfo != undefined) {
                        pw = util.getInputPassword(prop.id.dialog.cert);
                        if(!util.verifyInputPassword(pw, certInfo.media)) {
                            return;
                        }

                        for (var i = 0; i < options.inputPath.length; i++) {
                            options.inputPath[i] = util.encode64(util.encodeUtf8(options.inputPath[i]));
                        }

						comm.reqFileSign(options.inputPath, certInfo, pw, function (result) {
                            if (result.Status == prop.success) {
                                options.success(result.Output);
                            } else {
																if(status == prop.errCode.pkcs.INVALID_PASSWORD_EXCESS[0]){
						                				prop.INVALID_PASSWORD_EXCESS(result.Status, prop.getErrorMsg(result.Status));
						                		}
						                		else {
		                            	options.error(result.Status, prop.getErrorMsg(result.Status));
		                            }
                            }
                            certDlg.close();
                        });
                    }
                } else if (service == "moveCert") {
                    if (certInfo != undefined) {
                        pw = util.getInputPassword(prop.id.dialog.cert);
                        if(!util.verifyInputPassword(pw, certInfo.media)) {
                            return;
                        }

                        permitCodeDlg.setConfirmBtn(function() {
                            comm.reqExportCertForMobile(options.peerCert, certInfo, pw, permitCodeDlg.getCode(), function (result) {
                                var status = result.Status;
                                if(status != prop.success) {
                                    options.error(status, prop.getErrorMsg(status));
                                } else {
                                    options.success(result.Output);
                                }

                                certDlg.close();
                                permitCodeDlg.close();
                            });
                        });
                        permitCodeDlg.open();
                    }
                } else if (service == "epkiVid") {

                    function _epkiVidProcess() {
                        vidDlg.open();
                        vidDlg.setConfirmBtn(function() {
                            var vid = vidDlg.getVID();

                            comm.reqVerifyVidInfo(certInfo, pw, vid, "Y", function (result) {
                                var status = result.Status;

                                if (status != prop.success || result.Output == "FAIL") {
                                    if (status == prop.errCode.pkcs.PBE_DEC_FAILED[0]) {
                                        vidDlg.close();
                                    }
                                    if (result.Output == "FAIL") {
                                        options.error(result.Status, result.Output);
                                    } else {
																				if(status == prop.errCode.pkcs.INVALID_PASSWORD_EXCESS[0]){
				                                    certDlg.close();
				                                    pinDialog.close();
				                                    vidDlg.close();
										                				prop.INVALID_PASSWORD_EXCESS(result.Status, prop.getErrorMsg(result.Status));
										                		}
										                		else {
						                            	options.error(result.Status, prop.getErrorMsg(result.Status));
						                            }
                                    }
                                } else {
                                    certDlg.close();
                                    pinDialog.close();
                                    vidDlg.close();
                                    options.success(result.Output);
                                }
                            });
                        });
                    }

                    if (certInfo.media == prop.media.pkcs11) {
                        pinDialog.setConfirmBtn(function() {
                            pw = pinDialog.getPassword();
                            if(!util.verifyInputPassword(pw, certInfo.media)) {
                                return;
                            }

                            _epkiVidProcess();
                        });
                        pinDialog.open();
                    } else {
                        pw = util.getInputPassword(prop.id.dialog.cert);
                        if(!util.verifyInputPassword(pw, certInfo.media)) {
                            return;
                        }

                        _epkiVidProcess();
                    }
                } else if (service == "validCertScvp") {

                      pw = util.getInputPassword(prop.id.dialog.cert);
                      if(!util.verifyInputPassword(pw, certInfo.media)) {
                          return;
                      }

                      var signObj = {
                          svrIp: options.svrIp,
                          svrPort: options.svrPort
                      };

                      comm.reqValidCertBySCVP(certInfo, pw, signObj, function (result) {
                          _validCertBySCVPResult(result);
                      });

                    function _validCertBySCVPResult(result) {
                        var status = result.Status;
                        var output = result.Output;

                        if (status != prop.success) {
														if(status == prop.errCode.pkcs.INVALID_PASSWORD_EXCESS[0]){
                                certDlg.close();
				                				prop.INVALID_PASSWORD_EXCESS(status, prop.getErrorMsg(status));
				                		}
				                		else {
                            	options.error(status, prop.getErrorMsg(status));
                            }

                        } else {
                            certDlg.close();
                            options.success(output);
                        }
                    }
                }
            }

            // dialog password input
            var certPwInput = kcaseQuery("#" + prop.id.dialog.cert + " ." + prop.cs.pwBox);
            certPwInput.keydown(function(event) {
                if ( event.which == 13 ) {
                    event.preventDefault();
                    event.stopPropagation();
                    kcaseQuery("#" + prop.id.dialog.cert + " ." + prop.cs.btnLayout).find("button").eq(0).click();
                    return;
                } else if(event.shiftKey && event.which == 9){
                		event.preventDefault();
                		event.stopPropagation();
                		var trList = kcaseQuery("#" + prop.id.certList + " tbody").find("tr");
                		if(trList.length == 0){
	                    var tdList = kcaseQuery("#" + prop.id.certPosTable).find("td");
	                    kcaseQuery(tdList[tdList.length - 2].childNodes[1]).focus();
                		}
                		else if(_selectedCertPos != -1){
	                		trList.eq(_selectedCertPos).focus();
	                		trList.eq(_selectedCertPos).click();
                		}
                		return;
                }
            });

            // Move Cert
            certList.keydown(function(event) {
                var certListRow = kcaseQuery("#" + prop.id.certList + " tbody").find("tr");
								
                if (event.which == 38) {    // Up Arrow
                    event.preventDefault();
										event.stopPropagation();
                    certList.scrollTop((_selectedCertPos - 2) * 20);
                    if (_selectedCertPos != 0) {
                        _selectedCertPos--;
                    }
                } else if (event.which == 40) { // Down Arrow
                    event.preventDefault();
										event.stopPropagation();
                    if (_selectedCertPos < (certListRow.length - 1)) {
                        _selectedCertPos++;
                        if (_selectedCertPos > 4) {
                            certList.scrollTop((_selectedCertPos - 3) * 20);
                        }
                    }
                } else if (event.shiftKey && event.which == 9) {    // Shift Tab
                    event.preventDefault();
										event.stopPropagation();
                    certListRow.eq(_selectedCertPos).click();
                    var tdList = kcaseQuery("#" + prop.id.certPosTable).find("td");
                    kcaseQuery(tdList[tdList.length - 2].childNodes[1]).focus();
                    return;
                } else if (event.which == 9) {    // Tab
                    event.preventDefault();
										event.stopPropagation();
                    certListRow.eq(_selectedCertPos).click();
                    kcaseQuery("input[name=certPassword]").focus();
                    return;
                } else {
                    return;
                }
                certListRow.eq(_selectedCertPos).focus();
                certListRow.eq(_selectedCertPos).click();
            });

            function _reqDeleteCert() {
                var certInfo = certManager.checkSelectedCert();

                if (certInfo == undefined) {
                    alert(prop.strings.NOT_SELECTED_CERT);
                } else {
                    if (confirm(prop.strings.CONFIRM_DELETE)) {
                        var pw = "";

                        function _tokenDeleteCertProc(pwDlg) {
                            pwDlg.setConfirmBtn(function() {
                                pw = pwDlg.getPassword();
                                if(!util.verifyInputPassword(pw, certInfo.media)) {
                                    return;
                                }

                                comm.reqDeleteCert(certInfo, pw, function (result) {
                                    var status = result.Status;
                                    if (status == prop.success) {
                                        alert(prop.strings.CERT_DELETE_SUCCESS);
                                        certManager.getCertList();
                                        pinDialog.close();
                                        stokenPwDlg.close();
                                        pwDialog.close();
                                    } else {
                                        var errMessage = prop.getErrorMsg(status);
                                        if (result.ErrorMsg != undefined) {
                                            errMessage += util.decodeUtf8(result.ErrorMsg);
                                        }

                                        alert(errMessage);
                                    }
                                });
                            });
                            pwDlg.open();
                        }

                        if(certInfo.media == prop.media.pkcs11) {
                            _tokenDeleteCertProc(pinDialog);
                        } else if (certInfo.media == prop.media.savetoken) {
                            _tokenDeleteCertProc(stokenPwDlg);
                        } else {
                            _tokenDeleteCertProc(pwDialog);
                        }
                    }
                }
            }

            /* Set event - default content */
            var contentBtnList = kcaseQuery("#" + prop.id.content.cert).find("button");
           	if((typeof(ksign_disableDelete) != "undefined") && (ksign_disableDelete == true)){
          		contentBtnList.eq(2).html("인증서 찾기");
           	}

            contentBtnList.off("click");
            contentBtnList.eq(0).click(function () {     // View Certificate
                var certInfo = certManager.checkSelectedCert();

                if (certInfo != undefined) {
                    _getDialog(prop.id.dialog.viewCert).open(certInfo);
                } else {
                    alert(prop.strings.NOT_SELECTED_CERT);
                }
            });
            contentBtnList.eq(1).click(function () {     // Validate Certificate
                var certInfo = certManager.checkSelectedCert();

                if (certInfo != undefined) {
                    comm.reqCertVerify(certInfo, function (result) {
                        if (result.Status == prop.success) {
                            alert(prop.strings.CERT_VAL_SUCCESS);
                        } else {
                            alert(prop.getErrorMsg(result.Status));
                        }
                    });
                } else {
                    alert(prop.strings.NOT_SELECTED_CERT);
                }
            });
            contentBtnList.eq(2).click(function () {     // Delete Certificate
            	if((typeof(ksign_disableDelete) != "undefined") && (ksign_disableDelete == true)){
            		_getDialog(prop.id.dialog.pkcs12IE).open();
            	}
            	else{
								_reqDeleteCert();
            	}
                
            });

            var isDrag = false, nowX, colIndex;
            var resizer = kcaseQuery(".kc-tableview-resizer");

            resizer.on("mousedown", function(e) {
                var index = resizer.index(kcaseQuery(this));
                if (index == 0) {
                    colIndex = "";
                } else if (index == 1) {
                    colIndex = "2";
                } else if (index == 2) {
                    colIndex = "3";
                } else if (index == 3) {
                    colIndex = "4";
                }
                isDrag = true;
                nowX = e.clientX;
            });

            kcaseQuery("#kc_cert_list").on("mousemove", function(e) {
                if (isDrag) {
                    var width = Number(kcaseQuery(".kc-mcert" + colIndex).css("width").replace(/[^-\d\.]/g, ''));
                    var offset, replaceWidth;
                    offset = e.clientX - nowX;
                    replaceWidth = width + offset;
                    if (replaceWidth > 50 && replaceWidth < 250) {
                        kcaseQuery(".kc-mcert" + colIndex).css("width", replaceWidth + "px");
                        nowX = e.clientX;
                    }

                }
            });

            kcaseQuery("#kc_cert_list").on("mouseup", function(e) {
                if (isDrag) {
                    isDrag = false;
                }
            });

            /**
             *  Set event - admin content
             */
            /* Cert Type */
            var certTypeSelect = kcaseQuery("#" + prop.id.certType).find("select");
            certTypeSelect.change(function () {
                var curCertOpt = certManager.getCertOption();
                if (certTypeSelect.val() === 'sign') {
                    certManager.setCertOption(curCertOpt + 0x0400);
                    certManager.getCertList();
                } else if (certTypeSelect.val() === 'enc') {
                    certManager.setCertOption(curCertOpt - 0x0400);
                    certManager.getCertList();
                }
            });
            /* Cert Authority */
            var certAuthority = kcaseQuery("#" + prop.id.certCa).find("select");
            certAuthority.change(function () {
                var caIndex = certAuthority.find("option").index(certAuthority.find("option:selected"));
                var opt = caIndex << 16;
                var curCertOpt = certManager.getCertOption();
                curCertOpt = curCertOpt & 0x00FFFF;
                certManager.setCertOption(curCertOpt | opt);
                certManager.getCertList();
            });
            /* Admin button event List */
            var adminBtnList = kcaseQuery("#" + prop.id.content.admin).find("button");
            adminBtnList.off("click");
            adminBtnList.eq(0).click(function () {     // Copy Certificate
                function _certificateCopy(media, drive) {
                    var copyMediaInfo = {
                        toMedia: media,
                        toDrive: drive
                    };

                    var certPw = pwDialog.getPassword();
                    if(!util.verifyInputPassword(certPw, prop.media.hardDisk)) {
                        return;
                    }

                    if (media == prop.media.pkcs11) {
                        _tokenCopyProc(p11DlgManager, pinDialog);
                    } else if (media == prop.media.savetoken) {
                        _tokenCopyProc(stDialogManager, stokenPwDlg);
                    } else {
                        comm.reqCopyCert(certInfo, copyMediaInfo, certPw, function (result) {
                            if (result.Status != prop.success) {
                                var errMessage = prop.getErrorMsg(result.Status);
                                if (result.ErrorMsg != undefined) {
                                    errMessage += util.decodeUtf8(result.ErrorMsg);
                                }

                                alert(errMessage);
                            } else {
                                alert(prop.strings.CERT_COPY_SUCCESS);
                                pwDialog.close();
                                selDriveDlg.close();
                                selectMediaDlg.close();
                            }
                            var mediaList = kcaseQuery("#" + prop.id.dialog.media + " tr").eq(1);
                            mediaList.find("td").find("button").attr("disabled", false);
                        });
                    }

                    function _tokenCopyProc(mgrDlg, pwDlg) {
                        var pin = pwDlg.getPassword();
                        if(!util.verifyInputPassword(pin, media)) {
                            return;
                        }

                        var copyObj = {
                            progName: mgrDlg.getSelectedName(),
                            certPw: certPw,
                            pinPw: pin,
                            toMedia: copyMediaInfo.toMedia
                        };

                        comm.reqCopyCertSecToken(certInfo, copyObj, function(result) {
                            if (result.Status != prop.success) {
                                var errMessage = prop.getErrorMsg(result.Status);
                                if (result.ErrorMsg != undefined) {
                                    errMessage += util.decodeUtf8(result.ErrorMsg);
                                }

                                alert(errMessage);
                            } else {
                                alert(prop.strings.CERT_COPY_SUCCESS);
                                mgrDlg.close();
                                pwDialog.close();
                                pwDlg.close();
                                selDriveDlg.close();
                                selectMediaDlg.close();
                            }
                            var mediaList = kcaseQuery("#" + prop.id.dialog.media + " tr").eq(1);
                            mediaList.find("td").find("button").attr("disabled", false);
                        });
                    }
                }

                var certInfo = undefined;
                certInfo = certManager.checkSelectedCert();
                if (certInfo != undefined) {

                    var mediaList = kcaseQuery("#" + prop.id.dialog.media + " tr").eq(1);
                    mediaList.find("td").find("button").attr("disabled", false);

                    if (certInfo.media == prop.media.hardDisk) {
                        mediaList.find("td").eq(0).find("button").attr("disabled", true);
                    }
                    else if (certInfo.media == prop.media.pkcs11) {
                        mediaList.find("td").eq(2).find("button").attr("disabled", true);
                    }

                    selectMediaDlg.open();
                    selectMediaDlg.setConfirmBtn(function () {
                        switch (selectMediaDlg.getSelectedIdx()) {
                            case prop.media.hardDisk:
                                pwDialog.open();
                                pwDialog.setConfirmBtn(function () {
                                    _certificateCopy(prop.media.hardDisk, 0);
                                });
                                break;
                            case prop.media.removableDisk:
                                selDriveDlg.setConfirmBtn(function () {
                                    pwDialog.open();
                                    pwDialog.setConfirmBtn(function () {
                                        _certificateCopy(prop.media.removableDisk, selDriveDlg.getSelectedDrive());
                                    });
                                });
                                selDriveDlg.open(certInfo.drive);
                                break;
                            case prop.media.pkcs11:
                                p11DlgManager.open();
                                p11DlgManager.setConfirmBtn(function () {
                                    if (p11DlgManager.getSelectedName() == undefined) {
                                        alert(prop.strings.NOT_SELECTED_PKCS11);
                                        return;
                                    }

                                    pwDialog.open();
                                    pwDialog.setConfirmBtn(function () {
                                        pinDialog.setConfirmBtn(function () {
                                            _certificateCopy(prop.media.pkcs11, -1);
                                        });
                                        pinDialog.open();
                                    });
                                });
                                break;
                            case prop.media.savetoken:
                                stDialogManager.setConfirmBtn(function () {
                                    if (stDialogManager.getSelectedName() == undefined) {
                                        alert(prop.strings.NOT_SELECTED_SAVETOKEN);
                                        return;
                                    }

                                    pwDialog.open();
                                    pwDialog.setConfirmBtn(function () {
                                        stokenPwDlg.setConfirmBtn(function () {
                                            _certificateCopy(prop.media.savetoken, -1);
                                        });
                                        stokenPwDlg.open();
                                    });
                                });
                                stDialogManager.open();
                                break;
                        }
                    });
                } else {
                    alert(prop.strings.NOT_SELECTED_CERT);
                }
            });
            adminBtnList.eq(1).click(function () {     // Change Password
                if (certManager.checkSelectedCert() != undefined) {
                    _getDialog(prop.id.dialog.changePw).open();
                } else {
                    alert(prop.strings.NOT_SELECTED_CERT);
                }
            });
            adminBtnList.eq(2).click(function () {     // Delete Certificate
                _reqDeleteCert();
            });
            adminBtnList.eq(3).click(function () {     // PKCS12 Import/Export
                _getDialog(prop.id.dialog.pkcs12IE).open();
            });
            adminBtnList.eq(4).click(function () {     // View & Verify Certificate
                var certInfo = certManager.checkSelectedCert();
                if (certInfo != undefined) {
                    _getDialog(prop.id.dialog.viewCert).open(certInfo);
                } else {
                    alert(prop.strings.NOT_SELECTED_CERT);
                }
            });
            adminBtnList.eq(5).click(function () {     // PKCS12 Convert
                _getDialog(prop.id.dialog.pkcs12Con).open();
            });

            function _modeSetting(option) {
                var options = {
                    title: "",
                    certOpt: prop.selectCertOpt.CERTLIST_ALL,
                    height: 580,
                    cert: false,
                    onlyPw: false,
                    admin: false,
                    certType: false,
                    certCa: false
                };

                /* Remove loaded Certificate List */
                kcaseQuery("#kc_cert_list tbody").find("tr").remove();

                /* 옵션 파라미터 처리 */
                if (option !== undefined) {
                    util.setOption(options, option);
                }

                /* Set Dialog Title */
                certDlg.setTitle(options.title);

                /* Set Certificate List mode option */
                certManager.setCertOption(options.certOpt);

                /* Set Dialog Height */
                certDlg.setHeight(options.height);

                /* Set Default Dialog Display Mode */
                kcaseQuery("#" + prop.id.content.cert).css("display", "none");
                kcaseQuery("#" + prop.id.content.admin).css("display", "none");
                kcaseQuery("#" + prop.id.certType).css("display", "none");
                kcaseQuery("#" + prop.id.certCa).css("display", "none");

                if (options.cert) {
                    kcaseQuery("#" + prop.id.content.cert).css("height", "");
                    kcaseQuery("#" + prop.id.content.cert).css("display", "block");
                    kcaseQuery("#" + prop.id.content.cert).find("button").css("display", "block");
                    kcaseQuery("#" + prop.id.content.cert).find("span").eq(0).css("display", "block");
                }
                if (option.onlyPw) {
                    kcaseQuery("#" + prop.id.content.cert).css("height", 75);
                    kcaseQuery("#" + prop.id.content.cert).find("button").css("display", "none");
                    kcaseQuery("#" + prop.id.content.cert).find("span").eq(0).css("display", "none");
                }
                if (options.admin) {
                    kcaseQuery("#" + prop.id.content.admin).css("display", "block");
                }
                if (options.certType) {
                    kcaseQuery("#" + prop.id.certType).css("display", "block");
                }
                if (options.certCa) {
                    kcaseQuery("#" + prop.id.certCa).css("display", "block");
                }
            }

            /* Cert Dialog Mode */
            var _setDefault = function (options) {
                _modeSetting({
                    title: (options.title == undefined) ? prop.title.cert : options.title,
                    certOpt: prop.selectCertOpt.ADMIN_CERTLIST_ALL,
                    height: (options.height == undefined) ? 580 : options.height,
                    cert: true,
                    admin: false,
                    certType: false,
                    certCa: false,
                    onlyPw: (options.onlyPw == undefined) ? false : options.onlyPw
                });

                certDlg.setBottomBtns(1, {
                    event: function () {
                        certDlg.close();
                        prop.CANCEL_DIALOG();
                    },
                    show: true,
                    name: "취소"
                });
            };

            /* Admin Dialog Mode */
            var _setAdmin = function () {
                _modeSetting({
                    title: prop.title.admin,
                    certOpt: prop.selectCertOpt.ADMIN_CERTLIST_ALL,
                    height: 540,
                    cert: false,
                    admin: true,
                    certType: true,
                    certCa: true
                });
                certDlg.setBottomBtns(0, {
                    show: false
                });
                certDlg.setBottomBtns(1, {
                    event: function () {
                        certDlg.close();
                        prop.CANCEL_DIALOG();
                    },
                    show: true,
                    name: "닫기"
                });
            };
        };

        /* Cert Infomation View Dialog */
        new function () {
            var certViewDlg = _makeDialog({
                id: prop.id.dialog.viewCert,
                width: 450,
                height: 580,
                open: function (certInfo) {
                    certManager.viewCertificate(certInfo);
                },
                close: function () {
                }
            });
            certViewDlg.setBottomBtns(0, {
                event: function () {
                    certViewDlg.close();
                },
                name: "닫기",
                show: true
            });
        };

        /* Change Certificate Password Dialog */
        new function () {
            var pwList = kcaseQuery("#" + prop.id.dialog.changePw).find("input");
            var dlg = _makeDialog({
                id: prop.id.dialog.changePw,
                width: 400,
                height: 420,
                open: function () {
                	prop.isSubView = true;
                },
                close: function () {
                    pwList.val("");
                }
            });

            pwList.keydown(function(event) {
                if (event.which == 13) {
                    event.preventDefault();
                    kcaseQuery("#" + prop.id.dialog.changePw).find("button").eq(0).click();
                }
            });

            dlg.setBottomBtns(0, {
                event: function () {
                    var pwInputList = kcaseQuery("#" + prop.id.dialog.changePw + " .pwList").find("input");

                    var certPw, pw1, pw2, passObject, pw1Object, pw2Object;

                    if (!prop.usingNosAdapter) {
                        passObject = {
                            IsSec: 0,
                            Data: pwInputList.eq(0).val()
                        };
                        pw1Object = {
                            IsSec: 0,
                            Data: pwInputList.eq(1).val()
                        };
                        pw2Object = {
                            IsSec: 0,
                            Data: pwInputList.eq(2).val()
                        };
                    } else {
                        var name = pwInputList.eq(0).attr("name");

                        passObject = {
                            IsSec: 1,
                            Table: npPfsCtrl.GetResultField(name + "form", name),
                            Data: npPfsCtrl.GetReplaceField(name + "form", name)
                        };
                        var name1 = pwInputList.eq(1).attr("name");
                        pw1Object = {
                            IsSec: 1,
                            Table: npPfsCtrl.GetResultField(name1 + "form", name1),
                            Data: npPfsCtrl.GetReplaceField(name1 + "form", name1)
                        };
                        var name2 = pwInputList.eq(2).attr("name");
                        pw2Object = {
                            IsSec: 1,
                            Table: npPfsCtrl.GetResultField(name2 + "form", name2),
                            Data: npPfsCtrl.GetReplaceField(name2 + "form", name2)
                        };
                    }

                    certPw = JSON.stringify(passObject);
                    pw1 = JSON.stringify(pw1Object);
                    pw2 = JSON.stringify(pw2Object);

                    if (passObject.Data.length <= 0) {
                        alert("현재 비밀번호를 입력해주십시오.");
                        pwInputList.eq(0).focus();
                        return;
                    } else if (pw1Object.Data.length <= 0) {
                        alert("새로운 비밀번호를 입력해주십시오.");
                        pwInputList.eq(1).focus();
                        return;
                    } else if (pw2Object.Data.length <= 0) {
                        alert("새로운 비밀번호 확인을 입력해주십시오.");
                        pwInputList.eq(2).focus();
                        return;
                    } else {

                        if (pw1Object.Data != pw2Object.Data) {
                            alert("새로운 비밀번호가 일치하지 않습니다.");
                            return;
                        }

                        var certInfo = certManager.checkSelectedCert();
                        comm.reqChangePassword(certInfo, certPw, pw1, function (result) {
                            if (result.Status == prop.success) {
                                alert(prop.strings.CERT_CHANGE_PASSWORD);
                                pwInputList.val("");
                                dlg.close();
                            } else {
                                var errMessage = prop.getErrorMsg(result.Status);
                                if (result.ErrorMsg != undefined) {
                                    errMessage += util.decodeUtf8(result.ErrorMsg);
                                }

                                alert(errMessage);
                            }
                        });
                    }
                },
                show: true
            });
            dlg.setBottomBtns(1, {
                event: function () {
                    dlg.close();
                    prop.CANCEL_SUB_DIALOG();
                    prop.isSubView = true;
                },
                show: true
            });
        };

        /* PKCS12 Import/Export Dialog */
        new function() {
            var dlg = _makeDialog({
                id: prop.id.dialog.pkcs12IE,
                width: 400,
                height: 285,
                open: function () {
                		prop.isSubView = true;
                    kcaseQuery("#" + prop.id.p12Name).val("");
                },
                close: function () {
                }
            });

            var seledctedMenu = kcaseQuery("input[name=pkcs12menu]");

            seledctedMenu.eq(0).click(function () {
                var certInfo = certManager.checkSelectedCert();
                if (certInfo == undefined) {
                    alert(prop.strings.NOT_SELECTED_CERT);
                    seledctedMenu.eq(1).click();
                }
            });
            dlg.setBottomBtns(0, {
                event: function () {
                    var seledctedMenu = kcaseQuery("input[name=pkcs12menu]");
                    var fileNameVal = kcaseQuery("#" + prop.id.p12Name).val();

                    if (fileNameVal.length <= 0 ) {
                        alert(prop.strings.NOT_SELECTED_FILE);
                        return;
                    }
                    var filePath = util.encode64(util.encodeUtf8(fileNameVal));

                    if (seledctedMenu.eq(0).prop("checked")) {   /* Export */
                        pwDialog.open();
                        pwDialog.setConfirmBtn(function () {
                            var pw = pwDialog.getPassword();
                            if(!util.verifyInputPassword(pw, prop.media.hardDisk)) {
                                return;
                            }

                            var certInfo = certManager.checkSelectedCert();
                            comm.reqExportCert(certInfo, filePath, pw, function (result) {
                                var status = result.Status;
                                if (status == prop.success) {
                                    alert(prop.strings.CERT_EXPORT_SUCCESS);
                                } else {
                                    var errMessage = prop.getErrorMsg(status);
                                    if (result.ErrorMsg != undefined) {
                                        errMessage += util.decodeUtf8(result.ErrorMsg);
                                    }

                                    alert(errMessage);
                                }
                                pwDialog.close();
                                dlg.close();
                            });
                        });
                    } else if (seledctedMenu.eq(1).prop("checked")) {    /* Import */
                        var media;
                        var drive;

                        var mediaList = kcaseQuery("#" + prop.id.dialog.media + " tr").eq(1);
                        mediaList.find("td").find("button").attr("disabled", false);

                        selectMediaDlg.open();
                        selectMediaDlg.setConfirmBtn(function () {
                            media = selectMediaDlg.getSelectedIdx();
                            switch (media) {
                                case prop.media.hardDisk:
                                    drive = media;
                                    _reqImport();
                                    break;
                                case prop.media.removableDisk:
                                    selDriveDlg.open();
                                    selDriveDlg.setConfirmBtn(function () {
                                        drive = selDriveDlg.getSelectedDrive();
                                        _reqImport();
                                    });
                                    break;
                                case prop.media.pkcs11:
                                    _tokenImportCertProc(p11DlgManager, pinDialog);
                                    break;
                                case prop.media.savetoken:
                                    _tokenImportCertProc(stDialogManager, stokenPwDlg);
                                    break;
                            }

                            function _tokenImportCertProc(mgrDlg, pinDlg) {
                                mgrDlg.setConfirmBtn(function () {
                                    pwDialog.open();
                                    pwDialog.setConfirmBtn(function () {
                                        var certPw = pwDialog.getPassword();
                                        if(!util.verifyInputPassword(certPw, prop.media.hardDisk)) {
                                            return;
                                        }

                                        pinDlg.open();
                                        pinDlg.setConfirmBtn(function () {
                                            var pinPw = pinDlg.getPassword();
                                            if(!util.verifyInputPassword(pinPw, prop.media.pkcs11)) {
                                                return;
                                            }

                                            var secTokenData = {
                                                progName: mgrDlg.getSelectedName(),
                                                certPw: certPw,
                                                pinPw: pinPw
                                            };

                                            comm.reqImportCertSecToken(filePath, secTokenData, function(result) {
                                                _reqImportResult(result);
                                            });
                                        });
                                    });
                                });
                                mgrDlg.open();
                            }

                            function _reqImportResult(result) {
                                var status = result.Status;
                                if (status == prop.success) {
                                    alert(prop.strings.CERT_IMPORT_SUCCESS);
                                    selectMediaDlg.close();
                                    selDriveDlg.close();
                                    pwDialog.close();
                                    pinDialog.close();
                                    dlg.close();
                                    p11DlgManager.close();
                                    stDialogManager.close();
                                    stokenPwDlg.close();
                                } else {
                                    var errMessage = prop.getErrorMsg(status);
                                    if (result.ErrorMsg != undefined) {
                                        errMessage += util.decodeUtf8(result.ErrorMsg);
                                    }

                                    alert(errMessage);
                                }
                            }

                            function _reqImport() {
                                pwDialog.open();
                                pwDialog.setConfirmBtn(function () {
                                    var certPw = pwDialog.getPassword();
                                    if(!util.verifyInputPassword(certPw, prop.media.hardDisk)) {
                                        return;
                                    }

                                    comm.reqImportCert(filePath, media, drive, certPw, function (result) {
                                        _reqImportResult(result);
                                    });
                                });
                            }
                        });
                    }
                }
            });
            dlg.setBottomBtns(1, {
                event: function () {
                    dlg.close();
                    prop.CANCEL_SUB_DIALOG();
                    prop.isSubView = false;
                }
            });
            kcaseQuery("#pkcs12_file_btn").click(function () {
                var seledctedMenu = kcaseQuery("input[name=pkcs12menu]");

                fileExplorerDlg.setConfirmEvent(function() {
                    var fileValue = fileExplorerDlg.getSelectedFilePath();

                    if (fileValue.length <= 0) {
                        alert(prop.strings.NOT_SELECTED_FILE);
                        return;
                    }

                    if (seledctedMenu.eq(0).prop("checked")) {   /* Export */
                        if (fileValue[fileValue.length - 1] == "/") {
                            var certInfo = certManager.checkSelectedCert();
                            fileValue = fileValue + certInfo.subjectCN + ".pfx";
                        }
                    }

                    kcaseQuery("#" + prop.id.p12Name).val(fileValue);
                    fileExplorerDlg.close();
                });

                var option = {
                    ext: ".pfx",
                    type: fileExplorerDlg.Type.single
                };

                if (seledctedMenu.eq(0).prop("checked")) {   /* Export */
                    option.viewPath = true;
                    fileExplorerDlg.open(option);
                } else if (seledctedMenu.eq(1).prop("checked")) {    /* Import */
                    fileExplorerDlg.open(option);
                }
            });
        };

        /* Input Issue Code Dialog */
        new function () {
            var codeInputList = kcaseQuery("#" + prop.id.dialog.issueCode).find("input");
            var option;
            var dlg = _makeDialog({
                id: prop.id.dialog.issueCode,
                width: 320,
                height: 250,
                open: function(o) {
                		prop.isSubView = true;
                    dlg.setPosition(o.position);
                    codeInputList.eq(0).val(o.refNo);
                    codeInputList.eq(1).val(o.authCode);

                    option = o;
                },close: function() {
                    codeInputList.val("");
                }
            });

            dlg.setBottomBtns(0, {
                event: function () {
                    if (codeInputList.eq(0).val().length <= 0) {
                        alert("참조번호를 입력해주십시오.");
                        codeInputList.eq(0).focus();
                        return;
                    } else if (codeInputList.eq(1).val().length <= 0) {
                        alert("인가코드를 입력해주십시오.");
                        codeInputList.eq(1).focus();
                        return;
                    }
                    option.refNo = codeInputList.eq(0).val();
                    option.authCode = codeInputList.eq(1).val();

                    dlg.close();

                    createPwDlg.setPosition(option.position);

                    var mediaList = kcaseQuery("#" + prop.id.dialog.media + " tr").eq(1);
                    mediaList.find("td").find("button").attr("disabled", true);

                    mediaList.find("td").eq(0).find("button").attr("disabled", false);
                    mediaList.find("td").eq(1).find("button").attr("disabled", false);

                    selectMediaDlg.setPosition(option.position);
                    selectMediaDlg.setConfirmBtn(function () {
                        option.media = selectMediaDlg.getSelectedIdx();
                        switch (option.media) {
                            case prop.media.hardDisk:
                                option.drive = option.media;
                                selectMediaDlg.close();
                                createPwDlg.open(option);
                                break;
                            case prop.media.removableDisk:
                                selDriveDlg.setPosition(option.position);
                                selDriveDlg.setConfirmBtn(function () {
                                    option.drive = selDriveDlg.getSelectedDrive();
                                    selDriveDlg.close();
                                    selectMediaDlg.close();
                                    createPwDlg.open(option);
                                });
                                selDriveDlg.open();
                                break;
                        }
                    });
                    selectMediaDlg.open();
                }
            });
            dlg.setBottomBtns(1, {
                event: function () {
                    dlg.close();
                    prop.CANCEL_SUB_DIALOG();
                    prop.isSubView = false;
                }
            });
        };

        /* SSL Cert to PKCS12 Convert Dialog */
        new function () {
            var inputs = kcaseQuery("#" + prop.id.dialog.pkcs12Con).find("input");
            var buttons = kcaseQuery("#" + prop.id.dialog.pkcs12Con + " .kc-btn-gray");
            var dlg = _makeDialog({
                id: prop.id.dialog.pkcs12Con,
                width: 400,
                height: 460,
                open: function () {
                		prop.isSubView = true;
                    inputs.val("");
                },
                close: function () {
                }
            });

            buttons.eq(0).click(function () {
                fileExplorerDlg.setConfirmEvent(function() {
                    var filePath = fileExplorerDlg.getSelectedFilePath();
                    if (filePath.length <= 0) {
                        alert(prop.strings.NOT_SELECTED_FILE);
                        return;
                    }

                    inputs.eq(0).val(filePath);
                    fileExplorerDlg.close();
                });

                var option = {
                    type: fileExplorerDlg.Type.single
                };
                fileExplorerDlg.open(option);
            });
            buttons.eq(1).click(function () {
                fileExplorerDlg.setConfirmEvent(function() {
                    var filePath = fileExplorerDlg.getSelectedFilePath();
                    if (filePath.length <= 0) {
                        alert(prop.strings.NOT_SELECTED_FILE);
                        return;
                    }

                    inputs.eq(1).val(filePath);
                    fileExplorerDlg.close();
                });

                var option = {
                    type: fileExplorerDlg.Type.single
                };
                fileExplorerDlg.open(option);
            });
            buttons.eq(2).click(function () {
                var _certName = inputs.eq(0).val();
                if (_certName == "") {
                    alert("인증서 경로를 선택하여주시기 바랍니다.");
                    return;
                }
                _certName = _certName.split("/");
                _certName = _certName[_certName.length - 1];
                _certName = _certName.split(".");

                var splitLen = (_certName.length - 1) ? _certName.length - 1 : 1;
                var sslCertName = "";

                for (var i = 0; i <  splitLen; i ++) {
                    sslCertName += _certName[i] + ".";
                }
                sslCertName += "pfx";

                fileExplorerDlg.setConfirmEvent(function() {
                    var filePath = fileExplorerDlg.getSelectedFilePath();
                    if (filePath.length <= 0) {
                        alert(prop.strings.NOT_SELECTED_FILE);
                        return;
                    }

                    inputs.eq(3).val(filePath + sslCertName);
                    fileExplorerDlg.close();
                });

                var option = {
                    type: fileExplorerDlg.Type.directory,
                    ext: ".",
                    viewPath: true
                };
                fileExplorerDlg.open(option);
            });

            dlg.setBottomBtns(0, {
                event: function () {
                    var certpath = inputs.eq(0).val();
                    var keyPath = inputs.eq(1).val();
			/**
             * SSL 변환 부분 키보드 보안 적용 2017-06-23 DYLEE
             */
                    var passObject = {};
                    if (!prop.usingNosAdapter) {
                    	passObject = {
	                        	IsSec: 0,
                        		Data: kcaseQuery("#" + prop.id.dialog.pkcs12Con + " ." + prop.cs.pwBox).val()
                        };
                    } else {
                        var name = kcaseQuery("#" + prop.id.dialog.pkcs12Con + " ." + prop.cs.pwBox).attr("name");
                        passObject = {
                            IsSec: 1,
                            Table: npPfsCtrl.GetResultField(name + "form", name),
                            Data: npPfsCtrl.GetReplaceField(name + "form", name)
                        };
                    }

                    var keyPw = JSON.stringify(passObject);
                    var savePath = inputs.eq(3).val();

                    if (certpath == "") {
                        alert("인증서 경로를 선택하여주시기 바랍니다.");
                        return;
                    } else if (keyPath== "") {
                        alert("키 경로를 선택하여주시기 바랍니다.");
                        return;
                    } else if (savePath == "") {
                        alert("저장할 경로를 선택하여주시기 바랍니다.");
                        return;
                    }

                    if (JSON.parse(keyPw).Data.length <= 0) {
                        alert("키 비밀번호를 입력하여 주시기 바랍니다.");
                        return;
                    }

                    comm.reqConvertCert(certpath, keyPath, keyPw, savePath, function (result) {
                        if (result.Status == prop.success) {
                            alert(prop.strings.CERT_CONVERT_SUCCESS);
                        } else {
                            alert(prop.getErrorMsg(result.Status));
                        }
                        dlg.close();
                    });
                }
            });
            dlg.setBottomBtns(1, {
                event: function () {
                    dlg.close();
                    prop.CANCEL_SUB_DIALOG();
                    prop.isSubView = false;
                }
            });
        };

        /* File Explorer Dialog */
        var fileExplorerDlg = new _FileExplorerManager();

        /* Select Media Dialog */
        var selectMediaDlg = new _SelectMediaDialogManagerBase();

        /* PKCS11 Dialog */
        var p11DlgManager = new _pkcs11DialogManager();

        var stDialogManager = new _SaveTokenDialog();

        /* Select Drive Dialog */
        var selDriveDlg = new _SelectDriveDialog();

        /* Create Password Dialog */
        var createPwDlg = new _CreatePasswordDialog();

        /* input Permit Code Dialog */
        var permitCodeDlg = new _InputPermitCodeDialog();

        /* Input Virtual Identification Dialog */
        var vidDlg = new _InputVIDDialog();

        /* Input Password Dialog */
        var pwDialog = new _InputPasswordDialog();

        /* Input Pin Dialog */
        var pinDialog = new _InputPinDialog();

        /* Input SToken PW Dialog */
        var stokenPwDlg = new _InputSTokenPwDialog();

        /* Input SToken PW Dialog */
        var reasonDlg = new _CertAbolitionReasonDialog();

        return dialogObj;
    }

    function initLog() {
        var prefixName = "KCASE";
        //var logEncKey = undefined;

        /*this.d = function(m) {
         try {
         var encData = rsa.encrypt(toLogMessage(m), logEncKey);
         console.log(util.encode64(encData));
         } catch(e) {
         alert(e);
         }

         };*/

        this.d = function(m) {
            try {
                console.log(toLogMessage(m));
            } catch(e) {
                //alert(toLogMessage(m));
            }
        };

        /*this.setLogEncKey = function(k) {
         logEncKey = k;
         };*/

        function toLogMessage(m) {
            var d = new Date();
            var date = d.getFullYear() +"-" + d.getMonth() + "-" + d.getDay();
            var time = d.getHours() + ":" + d.getMinutes() + ":" + d.getSeconds();

            return prefixName + "(" + date + " " + time  + ") -> " + m;
        }
    }

    function initAsn1() {
        /**
         * ASN.1 classes.
         */
        this.Class = {
            UNIVERSAL: 0x00,
            APPLICATION: 0x40,
            CONTEXT_SPECIFIC: 0x80,
            PRIVATE: 0xC0
        };

        /**
         * ASN.1 types. Not all types are supported by this implementation, only
         * those necessary to implement a simple PKI are implemented.
         */
        this.Type = {
            NONE: 0,
            BOOLEAN: 1,
            INTEGER: 2,
            BITSTRING: 3,
            OCTETSTRING: 4,
            NULL: 5,
            OID: 6,
            ODESC: 7,
            EXTERNAL: 8,
            REAL: 9,
            ENUMERATED: 10,
            EMBEDDED: 11,
            UTF8: 12,
            ROID: 13,
            SEQUENCE: 16,
            SET: 17,
            PRINTABLESTRING: 19,
            IA5STRING: 22,
            UTCTIME: 23,
            GENERALIZEDTIME: 24,
            BMPSTRING: 30
        };

        /**
         * Creates a new asn1 object.
         *
         * @param tagClass the tag class for the object.
         * @param type the data type (tag number) for the object.
         * @param constructed true if the asn1 object is in constructed form.
         * @param value the value for the object, if it is not constructed.
         *
         * @return the asn1 object.
         */
        this.create = function (tagClass, type, constructed, value) {
            /* An asn1 object has a tagClass, a type, a constructed flag, and a
             value. The value's type depends on the constructed flag. If
             constructed, it will contain a list of other asn1 objects. If not,
             it will contain the ASN.1 value as an array of bytes formatted
             according to the ASN.1 data type. */

            // remove undefined values
            if (util.isArray(value)) {
                var tmp = [];
                for (var i = 0; i < value.length; ++i) {
                    if (value[i] !== undefined) {
                        tmp.push(value[i]);
                    }
                }
                value = tmp;
            }

            return {
                tagClass: tagClass,
                type: type,
                constructed: constructed,
                composed: constructed || util.isArray(value),
                value: value
            };
        };

        /**
         * Gets the length of an ASN.1 value.
         *
         * In case the length is not specified, undefined is returned.
         *
         * @param b the ASN.1 byte buffer.
         *
         * @return the length of the ASN.1 value.
         */
        var _getValueLength = function (b) {
            var b2 = b.getByte();
            if (b2 === 0x80) {
                return undefined;
            }

            // see if the length is "short form" or "long form" (bit 8 set)
            var length;
            var longForm = b2 & 0x80;
            if (!longForm) {
                // length is just the first byte
                length = b2;
            } else {
                // the number of bytes the length is specified in bits 7 through 1
                // and each length byte is in big-endian base-256
                length = b.getInt((b2 & 0x7F) << 3);
            }
            return length;
        };

        /**
         * Parses an asn1 object from a byte buffer in DER format.
         *
         * @param bytes the byte buffer to parse from.
         * @param strict true to be strict when checking value lengths, false to
         *          allow truncated values (default: true).
         *
         * @return the parsed asn1 object.
         */
        this.fromDer = function (bytes, strict) {
            if (strict === undefined) {
                strict = true;
            }

            // wrap in buffer if needed
            if (typeof bytes === 'string') {
                bytes = util.createBuffer(bytes);
            }

            // minimum length for ASN.1 DER structure is 2
            if (bytes.length() < 2) {
                var error = new Error('Too few bytes to parse DER.');
                error.bytes = bytes.length();
                throw error;
            }

            // get the first byte
            var b1 = bytes.getByte();

            // get the tag class
            var tagClass = (b1 & 0xC0);

            // get the type (bits 1-5)
            var type = b1 & 0x1F;

            // get the value length
            var length = _getValueLength(bytes);

            // ensure there are enough bytes to get the value
            if (bytes.length() < length) {
                if (strict) {
                    var error = new Error('Too few bytes to read ASN.1 value.');
                    error.detail = bytes.length() + ' < ' + length;
                    throw error;
                }
                // Note: be lenient with truncated values
                length = bytes.length();
            }

            // prepare to get value
            var value;

            // constructed flag is bit 6 (32 = 0x20) of the first byte
            var constructed = ((b1 & 0x20) === 0x20);

            // determine if the value is composed of other ASN.1 objects (if its
            // constructed it will be and if its a BITSTRING it may be)
            var composed = constructed;
            if (!composed && tagClass === asn1.Class.UNIVERSAL &&
                type === asn1.Type.BITSTRING && length > 1) {
                /* The first octet gives the number of bits by which the length of the
                 bit string is less than the next multiple of eight (this is called
                 the "number of unused bits").

                 The second and following octets give the value of the bit string
                 converted to an octet string. */
                // if there are no unused bits, maybe the bitstring holds ASN.1 objs
                var read = bytes.read;
                var unused = bytes.getByte();
                if (unused === 0) {
                    // if the first byte indicates UNIVERSAL or CONTEXT_SPECIFIC,
                    // and the length is valid, assume we've got an ASN.1 object
                    b1 = bytes.getByte();
                    var tc = (b1 & 0xC0);
                    if (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC) {
                        try {
                            var len = _getValueLength(bytes);
                            composed = (len === length - (bytes.read - read));
                            if (composed) {
                                // adjust read/length to account for unused bits byte
                                ++read;
                                --length;
                            }
                        } catch (ex) {
                        }
                    }
                }
                // restore read pointer
                bytes.read = read;
            }

            if (composed) {
                // parse child asn1 objects from the value
                value = [];
                if (length === undefined) {
                    // asn1 object of indefinite length, read until end tag
                    for (; ;) {
                        if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
                            bytes.getBytes(2);
                            break;
                        }
                        value.push(asn1.fromDer(bytes, strict));
                    }
                } else {
                    // parsing asn1 object of definite length
                    var start = bytes.length();
                    while (length > 0) {
                        value.push(asn1.fromDer(bytes, strict));
                        length -= start - bytes.length();
                        start = bytes.length();
                    }
                }
            } else {
                // asn1 not composed, get raw value
                // TODO: do DER to OID conversion and vice-versa in .toDer?

                if (length === undefined) {
                    if (strict) {
                        throw new Error('Non-constructed ASN.1 object of indefinite length.');
                    }
                    // be lenient and use remaining bytes
                    length = bytes.length();
                }

                if (type === asn1.Type.BMPSTRING) {
                    value = '';
                    for (var i = 0; i < length; i += 2) {
                        value += String.fromCharCode(bytes.getInt16());
                    }
                } else {
                    value = bytes.getBytes(length);
                }
            }

            // create and return asn1 object
            return asn1.create(tagClass, type, constructed, value);
        };

        /**
         * Converts the given asn1 object to a buffer of bytes in DER format.
         *
         * @param asn1 the asn1 object to convert to bytes.
         *
         * @return the buffer of bytes.
         */
        this.toDer = function (obj) {
            var bytes = util.createBuffer();

            // build the first byte
            var b1 = obj.tagClass | obj.type;

            // for storing the ASN.1 value
            var value = util.createBuffer();

            // if composed, use each child asn1 object's DER bytes as value
            if (obj.composed) {
                // turn on 6th bit (0x20 = 32) to indicate asn1 is constructed
                // from other asn1 objects
                if (obj.constructed) {
                    b1 |= 0x20;
                } else {
                    // type is a bit string, add unused bits of 0x00
                    value.putByte(0x00);
                }

                // add all of the child DER bytes together
                for (var i = 0; i < obj.value.length; ++i) {
                    if (obj.value[i] !== undefined) {
                        value.putBuffer(asn1.toDer(obj.value[i]));
                    }
                }
            } else {
                // use asn1.value directly
                if (obj.type === asn1.Type.BMPSTRING) {
                    for (var i = 0; i < obj.value.length; ++i) {
                        value.putInt16(obj.value.charCodeAt(i));
                    }
                } else {
                    value.putBytes(obj.value);
                }
            }

            // add tag byte
            bytes.putByte(b1);

            // use "short form" encoding
            if (value.length() <= 127) {
                // one byte describes the length
                // bit 8 = 0 and bits 7-1 = length
                bytes.putByte(value.length() & 0x7F);
            } else {
                // use "long form" encoding
                // 2 to 127 bytes describe the length
                // first byte: bit 8 = 1 and bits 7-1 = # of additional bytes
                // other bytes: length in base 256, big-endian
                var len = value.length();
                var lenBytes = '';
                do {
                    lenBytes += String.fromCharCode(len & 0xFF);
                    len = len >>> 8;
                } while (len > 0);

                // set first byte to # bytes used to store the length and turn on
                // bit 8 to indicate long-form length is used
                bytes.putByte(lenBytes.length | 0x80);

                // concatenate length bytes in reverse since they were generated
                // little endian and we need big endian
                for (var i = lenBytes.length - 1; i >= 0; --i) {
                    bytes.putByte(lenBytes.charCodeAt(i));
                }
            }

            // concatenate value bytes
            bytes.putBuffer(value);
            return bytes;
        };

        /**
         * Converts an OID dot-separated string to a byte buffer. The byte buffer
         * contains only the DER-encoded value, not any tag or length bytes.
         *
         * @param oid the OID dot-separated string.
         *
         * @return the byte buffer.
         */
        this.oidToDer = function (oid) {
            // split OID into individual values
            var values = oid.split('.');
            var bytes = util.createBuffer();

            // first byte is 40 * value1 + value2
            bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
            // other bytes are each value in base 128 with 8th bit set except for
            // the last byte for each value
            var last, valueBytes, value, b;
            for (var i = 2; i < values.length; ++i) {
                // produce value bytes in reverse because we don't know how many
                // bytes it will take to store the value
                last = true;
                valueBytes = [];
                value = parseInt(values[i], 10);
                do {
                    b = value & 0x7F;
                    value = value >>> 7;
                    // if value is not last, then turn on 8th bit
                    if (!last) {
                        b |= 0x80;
                    }
                    valueBytes.push(b);
                    last = false;
                } while (value > 0);

                // add value bytes in reverse (needs to be in big endian)
                for (var n = valueBytes.length - 1; n >= 0; --n) {
                    bytes.putByte(valueBytes[n]);
                }
            }

            return bytes;
        };

        /**
         * Converts a DER-encoded byte buffer to an OID dot-separated string. The
         * byte buffer should contain only the DER-encoded value, not any tag or
         * length bytes.
         *
         * @param bytes the byte buffer.
         *
         * @return the OID dot-separated string.
         */
        this.derToOid = function (bytes) {
            var oid;

            // wrap in buffer if needed
            if (typeof bytes === 'string') {
                bytes = util.createBuffer(bytes);
            }

            // first byte is 40 * value1 + value2
            var b = bytes.getByte();
            oid = Math.floor(b / 40) + '.' + (b % 40);

            // other bytes are each value in base 128 with 8th bit set except for
            // the last byte for each value
            var value = 0;
            while (bytes.length() > 0) {
                b = bytes.getByte();
                value = value << 7;
                // not the last byte for the value
                if (b & 0x80) {
                    value += b & 0x7F;
                } else {
                    // last byte
                    oid += '.' + (value + b);
                    value = 0;
                }
            }

            return oid;
        };

        /**
         * Converts a UTCTime value to a date.
         *
         * Note: GeneralizedTime has 4 digits for the year and is used for X.509
         * dates passed 2049. Parsing that structure hasn't been implemented yet.
         *
         * @param utc the UTCTime value to convert.
         *
         * @return the date.
         */
        this.utcTimeToDate = function (utc) {
            /* The following formats can be used:

             YYMMDDhhmmZ
             YYMMDDhhmm+hh'mm'
             YYMMDDhhmm-hh'mm'
             YYMMDDhhmmssZ
             YYMMDDhhmmss+hh'mm'
             YYMMDDhhmmss-hh'mm'

             Where:

             YY is the least significant two digits of the year
             MM is the month (01 to 12)
             DD is the day (01 to 31)
             hh is the hour (00 to 23)
             mm are the minutes (00 to 59)
             ss are the seconds (00 to 59)
             Z indicates that local time is GMT, + indicates that local time is
             later than GMT, and - indicates that local time is earlier than GMT
             hh' is the absolute value of the offset from GMT in hours
             mm' is the absolute value of the offset from GMT in minutes */
            var date = new Date();

            // if YY >= 50 use 19xx, if YY < 50 use 20xx
            var year = parseInt(utc.substr(0, 2), 10);
            year = (year >= 50) ? 1900 + year : 2000 + year;
            var MM = parseInt(utc.substr(2, 2), 10) - 1; // use 0-11 for month
            var DD = parseInt(utc.substr(4, 2), 10);
            var hh = parseInt(utc.substr(6, 2), 10);
            var mm = parseInt(utc.substr(8, 2), 10);
            var ss = 0;

            // not just YYMMDDhhmmZ
            if (utc.length > 11) {
                // get character after minutes
                var c = utc.charAt(10);
                var end = 10;

                // see if seconds are present
                if (c !== '+' && c !== '-') {
                    // get seconds
                    ss = parseInt(utc.substr(10, 2), 10);
                    end += 2;
                }
            }

            // update date
            date.setUTCFullYear(year, MM, DD);
            date.setUTCHours(hh, mm, ss, 0);

            if (end) {
                // get +/- after end of time
                c = utc.charAt(end);
                if (c === '+' || c === '-') {
                    // get hours+minutes offset
                    var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
                    var mmoffset = parseInt(utc.substr(end + 4, 2), 10);

                    // calculate offset in milliseconds
                    var offset = hhoffset * 60 + mmoffset;
                    offset *= 60000;

                    // apply offset
                    if (c === '+') {
                        date.setTime(+date - offset);
                    } else {
                        date.setTime(+date + offset);
                    }
                }
            }

            return date;
        };

        /**
         * Converts a GeneralizedTime value to a date.
         *
         * @param gentime the GeneralizedTime value to convert.
         *
         * @return the date.
         */
        this.generalizedTimeToDate = function (gentime) {
            /* The following formats can be used:

             YYYYMMDDHHMMSS
             YYYYMMDDHHMMSS.fff
             YYYYMMDDHHMMSSZ
             YYYYMMDDHHMMSS.fffZ
             YYYYMMDDHHMMSS+hh'mm'
             YYYYMMDDHHMMSS.fff+hh'mm'
             YYYYMMDDHHMMSS-hh'mm'
             YYYYMMDDHHMMSS.fff-hh'mm'

             Where:

             YYYY is the year
             MM is the month (01 to 12)
             DD is the day (01 to 31)
             hh is the hour (00 to 23)
             mm are the minutes (00 to 59)
             ss are the seconds (00 to 59)
             .fff is the second fraction, accurate to three decimal places
             Z indicates that local time is GMT, + indicates that local time is
             later than GMT, and - indicates that local time is earlier than GMT
             hh' is the absolute value of the offset from GMT in hours
             mm' is the absolute value of the offset from GMT in minutes */
            var date = new Date();

            var YYYY = parseInt(gentime.substr(0, 4), 10);
            var MM = parseInt(gentime.substr(4, 2), 10) - 1; // use 0-11 for month
            var DD = parseInt(gentime.substr(6, 2), 10);
            var hh = parseInt(gentime.substr(8, 2), 10);
            var mm = parseInt(gentime.substr(10, 2), 10);
            var ss = parseInt(gentime.substr(12, 2), 10);
            var fff = 0;
            var offset = 0;
            var isUTC = false;

            if (gentime.charAt(gentime.length - 1) === 'Z') {
                isUTC = true;
            }

            var end = gentime.length - 5, c = gentime.charAt(end);
            if (c === '+' || c === '-') {
                // get hours+minutes offset
                var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
                var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);

                // calculate offset in milliseconds
                offset = hhoffset * 60 + mmoffset;
                offset *= 60000;

                // apply offset
                if (c === '+') {
                    offset *= -1;
                }

                isUTC = true;
            }

            // check for second fraction
            if (gentime.charAt(14) === '.') {
                fff = parseFloat(gentime.substr(14), 10) * 1000;
            }

            if (isUTC) {
                date.setUTCFullYear(YYYY, MM, DD);
                date.setUTCHours(hh, mm, ss, fff);

                // apply offset
                date.setTime(+date + offset);
            } else {
                date.setFullYear(YYYY, MM, DD);
                date.setHours(hh, mm, ss, fff);
            }

            return date;
        };


        /**
         * Converts a date to a UTCTime value.
         *
         * Note: GeneralizedTime has 4 digits for the year and is used for X.509
         * dates passed 2049. Converting to a GeneralizedTime hasn't been
         * implemented yet.
         *
         * @param date the date to convert.
         *
         * @return the UTCTime value.
         */
        this.dateToUtcTime = function (date) {
            var rval = '';

            // create format YYMMDDhhmmssZ
            var format = [];
            format.push(('' + date.getUTCFullYear()).substr(2));
            format.push('' + (date.getUTCMonth() + 1));
            format.push('' + date.getUTCDate());
            format.push('' + date.getUTCHours());
            format.push('' + date.getUTCMinutes());
            format.push('' + date.getUTCSeconds());

            // ensure 2 digits are used for each format entry
            for (var i = 0; i < format.length; ++i) {
                if (format[i].length < 2) {
                    rval += '0';
                }
                rval += format[i];
            }
            rval += 'Z';

            return rval;
        };

        /**
         * Converts a javascript integer to a DER-encoded byte buffer to be used
         * as the value for an INTEGER type.
         *
         * @param x the integer.
         *
         * @return the byte buffer.
         */
        this.integerToDer = function (x) {
            var rval = util.createBuffer();
            if (x >= -0x80 && x < 0x80) {
                return rval.putSignedInt(x, 8);
            }
            if (x >= -0x8000 && x < 0x8000) {
                return rval.putSignedInt(x, 16);
            }
            if (x >= -0x800000 && x < 0x800000) {
                return rval.putSignedInt(x, 24);
            }
            if (x >= -0x80000000 && x < 0x80000000) {
                return rval.putSignedInt(x, 32);
            }
            var error = new Error('Integer too large; max is 32-bits.');
            error.integer = x;
            throw error;
        };

        /**
         * Converts a DER-encoded byte buffer to a javascript integer. This is
         * typically used to decode the value of an INTEGER type.
         *
         * @param bytes the byte buffer.
         *
         * @return the integer.
         */
        this.derToInteger = function (bytes) {
            // wrap in buffer if needed
            if (typeof bytes === 'string') {
                bytes = util.createBuffer(bytes);
            }

            var n = bytes.length() * 8;
            if (n > 32) {
                throw new Error('Integer too large; max is 32-bits.');
            }
            return bytes.getSignedInt(n);
        };

        /**
         * Validates the that given ASN.1 object is at least a super set of the
         * given ASN.1 structure. Only tag classes and types are checked. An
         * optional map may also be provided to capture ASN.1 values while the
         * structure is checked.
         *
         * To capture an ASN.1 value, set an object in the validator's 'capture'
         * parameter to the key to use in the capture map. To capture the full
         * ASN.1 object, specify 'captureAsn1'.
         *
         * Objects in the validator may set a field 'optional' to true to indicate
         * that it isn't necessary to pass validation.
         *
         * @param obj the ASN.1 object to validate.
         * @param v the ASN.1 structure validator.
         * @param capture an optional map to capture values in.
         * @param errors an optional array for storing validation errors.
         *
         * @return true on success, false on failure.
         */
        this.validate = function (obj, v, capture, errors) {
            var rval = false;

            // ensure tag class and type are the same if specified
            if ((obj.tagClass === v.tagClass || typeof(v.tagClass) === 'undefined') &&
                (obj.type === v.type || typeof(v.type) === 'undefined')) {
                // ensure constructed flag is the same if specified
                if (obj.constructed === v.constructed ||
                    typeof(v.constructed) === 'undefined') {
                    rval = true;

                    // handle sub values
                    if (v.value && util.isArray(v.value)) {
                        var j = 0;
                        for (var i = 0; rval && i < v.value.length; ++i) {
                            rval = v.value[i].optional || false;
                            if (obj.value[j]) {
                                rval = asn1.validate(obj.value[j], v.value[i], capture, errors);
                                if (rval) {
                                    ++j;
                                } else if (v.value[i].optional) {
                                    rval = true;
                                }
                            }
                            if (!rval && errors) {
                                errors.push(
                                    '[' + v.name + '] ' +
                                    'Tag class "' + v.tagClass + '", type "' +
                                    v.type + '" expected value length "' +
                                    v.value.length + '", got "' +
                                    obj.value.length + '"');
                            }
                        }
                    }

                    if (rval && capture) {
                        if (v.capture) {
                            capture[v.capture] = obj.value;
                        }
                        if (v.captureAsn1) {
                            capture[v.captureAsn1] = obj;
                        }
                    }
                } else if (errors) {
                    errors.push(
                        '[' + v.name + '] ' +
                        'Expected constructed "' + v.constructed + '", got "' +
                        obj.constructed + '"');
                }
            } else if (errors) {
                if (obj.tagClass !== v.tagClass) {
                    errors.push(
                        '[' + v.name + '] ' +
                        'Expected tag class "' + v.tagClass + '", got "' +
                        obj.tagClass + '"');
                }
                if (obj.type !== v.type) {
                    errors.push(
                        '[' + v.name + '] ' +
                        'Expected type "' + v.type + '", got "' + obj.type + '"');
                }
            }
            return rval;
        };

// regex for testing for non-latin characters
        var _nonLatinRegex = /[^\\u0000-\\u00ff]/;

        /**
         * Pretty prints an ASN.1 object to a string.
         *
         * @param obj the object to write out.
         * @param level the level in the tree.
         * @param indentation the indentation to use.
         *
         * @return the string.
         */
        this.prettyPrint = function (obj, level, indentation) {
            var rval = '';

            // set default level and indentation
            level = level || 0;
            indentation = indentation || 2;

            // start new line for deep levels
            if (level > 0) {
                rval += '\n';
            }

            // create indent
            var indent = '';
            for (var i = 0; i < level * indentation; ++i) {
                indent += ' ';
            }

            // print class:type
            rval += indent + 'Tag: ';
            switch (obj.tagClass) {
                case asn1.Class.UNIVERSAL:
                    rval += 'Universal:';
                    break;
                case asn1.Class.APPLICATION:
                    rval += 'Application:';
                    break;
                case asn1.Class.CONTEXT_SPECIFIC:
                    rval += 'Context-Specific:';
                    break;
                case asn1.Class.PRIVATE:
                    rval += 'Private:';
                    break;
            }

            if (obj.tagClass === asn1.Class.UNIVERSAL) {
                rval += obj.type;

                // known types
                switch (obj.type) {
                    case asn1.Type.NONE:
                        rval += ' (None)';
                        break;
                    case asn1.Type.BOOLEAN:
                        rval += ' (Boolean)';
                        break;
                    case asn1.Type.BITSTRING:
                        rval += ' (Bit string)';
                        break;
                    case asn1.Type.INTEGER:
                        rval += ' (Integer)';
                        break;
                    case asn1.Type.OCTETSTRING:
                        rval += ' (Octet string)';
                        break;
                    case asn1.Type.NULL:
                        rval += ' (Null)';
                        break;
                    case asn1.Type.OID:
                        rval += ' (Object Identifier)';
                        break;
                    case asn1.Type.ODESC:
                        rval += ' (Object Descriptor)';
                        break;
                    case asn1.Type.EXTERNAL:
                        rval += ' (External or Instance of)';
                        break;
                    case asn1.Type.REAL:
                        rval += ' (Real)';
                        break;
                    case asn1.Type.ENUMERATED:
                        rval += ' (Enumerated)';
                        break;
                    case asn1.Type.EMBEDDED:
                        rval += ' (Embedded PDV)';
                        break;
                    case asn1.Type.UTF8:
                        rval += ' (UTF8)';
                        break;
                    case asn1.Type.ROID:
                        rval += ' (Relative Object Identifier)';
                        break;
                    case asn1.Type.SEQUENCE:
                        rval += ' (Sequence)';
                        break;
                    case asn1.Type.SET:
                        rval += ' (Set)';
                        break;
                    case asn1.Type.PRINTABLESTRING:
                        rval += ' (Printable String)';
                        break;
                    case asn1.Type.IA5String:
                        rval += ' (IA5String (ASCII))';
                        break;
                    case asn1.Type.UTCTIME:
                        rval += ' (UTC time)';
                        break;
                    case asn1.Type.GENERALIZEDTIME:
                        rval += ' (Generalized time)';
                        break;
                    case asn1.Type.BMPSTRING:
                        rval += ' (BMP String)';
                        break;
                }
            } else {
                rval += obj.type;
            }

            rval += '\n';
            rval += indent + 'Constructed: ' + obj.constructed + '\n';

            if (obj.composed) {
                var subvalues = 0;
                var sub = '';
                for (var i = 0; i < obj.value.length; ++i) {
                    if (obj.value[i] !== undefined) {
                        subvalues += 1;
                        sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);
                        if ((i + 1) < obj.value.length) {
                            sub += ',';
                        }
                    }
                }
                rval += indent + 'Sub values: ' + subvalues + sub;
            } else {
                rval += indent + 'Value: ';
                if (obj.type === asn1.Type.OID) {
                    var oid = asn1.derToOid(obj.value);
                    rval += oid;
                    if (kcaseagt.pki && kcaseagt.pki.oids) {
                        if (oid in kcaseagt.pki.oids) {
                            rval += ' (' + kcaseagt.pki.oids[oid] + ') ';
                        }
                    }
                }
                if (obj.type === asn1.Type.INTEGER) {
                    try {
                        rval += asn1.derToInteger(obj.value);
                    } catch (ex) {
                        rval += '0x' + util.bytesToHex(obj.value);
                    }
                } else if (obj.type === asn1.Type.OCTETSTRING) {
                    if (!_nonLatinRegex.test(obj.value)) {
                        rval += '(' + obj.value + ') ';
                    }
                    rval += '0x' + util.bytesToHex(obj.value);
                } else if (obj.type === asn1.Type.UTF8) {
                    rval += util.decodeUtf8(obj.value);
                } else if (obj.type === asn1.Type.PRINTABLESTRING ||
                    obj.type === asn1.Type.IA5String) {
                    rval += obj.value;
                } else if (_nonLatinRegex.test(obj.value)) {
                    rval += '0x' + util.bytesToHex(obj.value);
                } else if (obj.value.length === 0) {
                    rval += '[null]';
                } else {
                    rval += obj.value;
                }
            }

            return rval;
        };
    }

    function initBignum() {
        // Bits per digit
        var dbits;

// JavaScript engine analysis
        var canary = 0xdeadbeefcafe;
        var j_lm = ((canary & 0xffffff) == 0xefcafe);

// (public) Constructor
        function BigInteger(a, b, c) {
            this.data = [];
            if (a != null)
                if ("number" == typeof a) this.fromNumber(a, b, c);
                else if (b == null && "string" != typeof a) this.fromString(a, 256);
                else this.fromString(a, b);
        }

// return new, unset BigInteger
        function nbi() {
            return new BigInteger(null);
        }

// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.

// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
        function am1(i, x, w, j, c, n) {
            while (--n >= 0) {
                var v = x * this.data[i++] + w.data[j] + c;
                c = Math.floor(v / 0x4000000);
                w.data[j++] = v & 0x3ffffff;
            }
            return c;
        }

// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
        function am2(i, x, w, j, c, n) {
            var xl = x & 0x7fff, xh = x >> 15;
            while (--n >= 0) {
                var l = this.data[i] & 0x7fff;
                var h = this.data[i++] >> 15;
                var m = xh * l + h * xl;
                l = xl * l + ((m & 0x7fff) << 15) + w.data[j] + (c & 0x3fffffff);
                c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
                w.data[j++] = l & 0x3fffffff;
            }
            return c;
        }

// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
        function am3(i, x, w, j, c, n) {
            var xl = x & 0x3fff, xh = x >> 14;
            while (--n >= 0) {
                var l = this.data[i] & 0x3fff;
                var h = this.data[i++] >> 14;
                var m = xh * l + h * xl;
                l = xl * l + ((m & 0x3fff) << 14) + w.data[j] + c;
                c = (l >> 28) + (m >> 14) + xh * h;
                w.data[j++] = l & 0xfffffff;
            }
            return c;
        }

// node.js (no browser)
        if (typeof(navigator) === 'undefined') {
            BigInteger.prototype.am = am3;
            dbits = 28;
        } else if (j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
            BigInteger.prototype.am = am2;
            dbits = 30;
        } else if (j_lm && (navigator.appName != "Netscape")) {
            BigInteger.prototype.am = am1;
            dbits = 26;
        } else { // Mozilla/Netscape seems to prefer am3
            BigInteger.prototype.am = am3;
            dbits = 28;
        }

        BigInteger.prototype.DB = dbits;
        BigInteger.prototype.DM = ((1 << dbits) - 1);
        BigInteger.prototype.DV = (1 << dbits);

        var BI_FP = 52;
        BigInteger.prototype.FV = Math.pow(2, BI_FP);
        BigInteger.prototype.F1 = BI_FP - dbits;
        BigInteger.prototype.F2 = 2 * dbits - BI_FP;

// Digit conversions
        var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
        var BI_RC = new Array();
        var rr, vv;
        rr = "0".charCodeAt(0);
        for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
        rr = "a".charCodeAt(0);
        for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
        rr = "A".charCodeAt(0);
        for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

        function int2char(n) {
            return BI_RM.charAt(n);
        }

        function intAt(s, i) {
            var c = BI_RC[s.charCodeAt(i)];
            return (c == null) ? -1 : c;
        }

// (protected) copy this to r
        function bnpCopyTo(r) {
            for (var i = this.t - 1; i >= 0; --i) r.data[i] = this.data[i];
            r.t = this.t;
            r.s = this.s;
        }

// (protected) set from integer value x, -DV <= x < DV
        function bnpFromInt(x) {
            this.t = 1;
            this.s = (x < 0) ? -1 : 0;
            if (x > 0) this.data[0] = x;
            else if (x < -1) this.data[0] = x + this.DV;
            else this.t = 0;
        }

// return bigint initialized to value
        function nbv(i) {
            var r = nbi();
            r.fromInt(i);
            return r;
        }

// (protected) set from string and radix
        function bnpFromString(s, b) {
            var k;
            if (b == 16) k = 4;
            else if (b == 8) k = 3;
            else if (b == 256) k = 8; // byte array
            else if (b == 2) k = 1;
            else if (b == 32) k = 5;
            else if (b == 4) k = 2;
            else {
                this.fromRadix(s, b);
                return;
            }
            this.t = 0;
            this.s = 0;
            var i = s.length, mi = false, sh = 0;
            while (--i >= 0) {
                var x = (k == 8) ? s[i] & 0xff : intAt(s, i);
                if (x < 0) {
                    if (s.charAt(i) == "-") mi = true;
                    continue;
                }
                mi = false;
                if (sh == 0)
                    this.data[this.t++] = x;
                else if (sh + k > this.DB) {
                    this.data[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
                    this.data[this.t++] = (x >> (this.DB - sh));
                } else
                    this.data[this.t - 1] |= x << sh;
                sh += k;
                if (sh >= this.DB) sh -= this.DB;
            }
            if (k == 8 && (s[0] & 0x80) != 0) {
                this.s = -1;
                if (sh > 0) this.data[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
            }
            this.clamp();
            if (mi) BigInteger.ZERO.subTo(this, this);
        }

// (protected) clamp off excess high words
        function bnpClamp() {
            var c = this.s & this.DM;
            while (this.t > 0 && this.data[this.t - 1] == c) --this.t;
        }

// (public) return string representation in given radix
        function bnToString(b) {
            if (this.s < 0) return "-" + this.negate().toString(b);
            var k;
            if (b == 16) k = 4;
            else if (b == 8) k = 3;
            else if (b == 2) k = 1;
            else if (b == 32) k = 5;
            else if (b == 4) k = 2;
            else return this.toRadix(b);
            var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
            var p = this.DB - (i * this.DB) % k;
            if (i-- > 0) {
                if (p < this.DB && (d = this.data[i] >> p) > 0) {
                    m = true;
                    r = int2char(d);
                }
                while (i >= 0) {
                    if (p < k) {
                        d = (this.data[i] & ((1 << p) - 1)) << (k - p);
                        d |= this.data[--i] >> (p += this.DB - k);
                    } else {
                        d = (this.data[i] >> (p -= k)) & km;
                        if (p <= 0) {
                            p += this.DB;
                            --i;
                        }
                    }
                    if (d > 0) m = true;
                    if (m) r += int2char(d);
                }
            }
            return m ? r : "0";
        }

// (public) -this
        function bnNegate() {
            var r = nbi();
            BigInteger.ZERO.subTo(this, r);
            return r;
        }

// (public) |this|
        function bnAbs() {
            return (this.s < 0) ? this.negate() : this;
        }

// (public) return + if this > a, - if this < a, 0 if equal
        function bnCompareTo(a) {
            var r = this.s - a.s;
            if (r != 0) return r;
            var i = this.t;
            r = i - a.t;
            if (r != 0) return (this.s < 0) ? -r : r;
            while (--i >= 0) if ((r = this.data[i] - a.data[i]) != 0) return r;
            return 0;
        }

// returns bit length of the integer x
        function nbits(x) {
            var r = 1, t;
            if ((t = x >>> 16) != 0) {
                x = t;
                r += 16;
            }
            if ((t = x >> 8) != 0) {
                x = t;
                r += 8;
            }
            if ((t = x >> 4) != 0) {
                x = t;
                r += 4;
            }
            if ((t = x >> 2) != 0) {
                x = t;
                r += 2;
            }
            if ((t = x >> 1) != 0) {
                x = t;
                r += 1;
            }
            return r;
        }

// (public) return the number of bits in "this"
        function bnBitLength() {
            if (this.t <= 0) return 0;
            return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ (this.s & this.DM));
        }

// (protected) r = this << n*DB
        function bnpDLShiftTo(n, r) {
            var i;
            for (i = this.t - 1; i >= 0; --i) r.data[i + n] = this.data[i];
            for (i = n - 1; i >= 0; --i) r.data[i] = 0;
            r.t = this.t + n;
            r.s = this.s;
        }

// (protected) r = this >> n*DB
        function bnpDRShiftTo(n, r) {
            for (var i = n; i < this.t; ++i) r.data[i - n] = this.data[i];
            r.t = Math.max(this.t - n, 0);
            r.s = this.s;
        }

// (protected) r = this << n
        function bnpLShiftTo(n, r) {
            var bs = n % this.DB;
            var cbs = this.DB - bs;
            var bm = (1 << cbs) - 1;
            var ds = Math.floor(n / this.DB), c = (this.s << bs) & this.DM, i;
            for (i = this.t - 1; i >= 0; --i) {
                r.data[i + ds + 1] = (this.data[i] >> cbs) | c;
                c = (this.data[i] & bm) << bs;
            }
            for (i = ds - 1; i >= 0; --i) r.data[i] = 0;
            r.data[ds] = c;
            r.t = this.t + ds + 1;
            r.s = this.s;
            r.clamp();
        }

// (protected) r = this >> n
        function bnpRShiftTo(n, r) {
            r.s = this.s;
            var ds = Math.floor(n / this.DB);
            if (ds >= this.t) {
                r.t = 0;
                return;
            }
            var bs = n % this.DB;
            var cbs = this.DB - bs;
            var bm = (1 << bs) - 1;
            r.data[0] = this.data[ds] >> bs;
            for (var i = ds + 1; i < this.t; ++i) {
                r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
                r.data[i - ds] = this.data[i] >> bs;
            }
            if (bs > 0) r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
            r.t = this.t - ds;
            r.clamp();
        }

// (protected) r = this - a
        function bnpSubTo(a, r) {
            var i = 0, c = 0, m = Math.min(a.t, this.t);
            while (i < m) {
                c += this.data[i] - a.data[i];
                r.data[i++] = c & this.DM;
                c >>= this.DB;
            }
            if (a.t < this.t) {
                c -= a.s;
                while (i < this.t) {
                    c += this.data[i];
                    r.data[i++] = c & this.DM;
                    c >>= this.DB;
                }
                c += this.s;
            } else {
                c += this.s;
                while (i < a.t) {
                    c -= a.data[i];
                    r.data[i++] = c & this.DM;
                    c >>= this.DB;
                }
                c -= a.s;
            }
            r.s = (c < 0) ? -1 : 0;
            if (c < -1) r.data[i++] = this.DV + c;
            else if (c > 0) r.data[i++] = c;
            r.t = i;
            r.clamp();
        }

// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
        function bnpMultiplyTo(a, r) {
            var x = this.abs(), y = a.abs();
            var i = x.t;
            r.t = i + y.t;
            while (--i >= 0) r.data[i] = 0;
            for (i = 0; i < y.t; ++i) r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
            r.s = 0;
            r.clamp();
            if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
        }

// (protected) r = this^2, r != this (HAC 14.16)
        function bnpSquareTo(r) {
            var x = this.abs();
            var i = r.t = 2 * x.t;
            while (--i >= 0) r.data[i] = 0;
            for (i = 0; i < x.t - 1; ++i) {
                var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
                if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
                    r.data[i + x.t] -= x.DV;
                    r.data[i + x.t + 1] = 1;
                }
            }
            if (r.t > 0) r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
            r.s = 0;
            r.clamp();
        }

// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
        function bnpDivRemTo(m, q, r) {
            var pm = m.abs();
            if (pm.t <= 0) return;
            var pt = this.abs();
            if (pt.t < pm.t) {
                if (q != null) q.fromInt(0);
                if (r != null) this.copyTo(r);
                return;
            }
            if (r == null) r = nbi();
            var y = nbi(), ts = this.s, ms = m.s;
            var nsh = this.DB - nbits(pm.data[pm.t - 1]);	// normalize modulus
            if (nsh > 0) {
                pm.lShiftTo(nsh, y);
                pt.lShiftTo(nsh, r);
            } else {
                pm.copyTo(y);
                pt.copyTo(r);
            }
            var ys = y.t;
            var y0 = y.data[ys - 1];
            if (y0 == 0) return;
            var yt = y0 * (1 << this.F1) + ((ys > 1) ? y.data[ys - 2] >> this.F2 : 0);
            var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
            var i = r.t, j = i - ys, t = (q == null) ? nbi() : q;
            y.dlShiftTo(j, t);
            if (r.compareTo(t) >= 0) {
                r.data[r.t++] = 1;
                r.subTo(t, r);
            }
            BigInteger.ONE.dlShiftTo(ys, t);
            t.subTo(y, y);	// "negative" y so we can replace sub with am later
            while (y.t < ys) y.data[y.t++] = 0;
            while (--j >= 0) {
                // Estimate quotient digit
                var qd = (r.data[--i] == y0) ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
                if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {	// Try it out
                    y.dlShiftTo(j, t);
                    r.subTo(t, r);
                    while (r.data[i] < --qd) r.subTo(t, r);
                }
            }
            if (q != null) {
                r.drShiftTo(ys, q);
                if (ts != ms) BigInteger.ZERO.subTo(q, q);
            }
            r.t = ys;
            r.clamp();
            if (nsh > 0) r.rShiftTo(nsh, r);	// Denormalize remainder
            if (ts < 0) BigInteger.ZERO.subTo(r, r);
        }

// (public) this mod a
        function bnMod(a) {
            var r = nbi();
            this.abs().divRemTo(a, null, r);
            if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
            return r;
        }

// Modular reduction using "classic" algorithm
        function Classic(m) {
            this.m = m;
        }

        function cConvert(x) {
            if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
            else return x;
        }

        function cRevert(x) {
            return x;
        }

        function cReduce(x) {
            x.divRemTo(this.m, null, x);
        }

        function cMulTo(x, y, r) {
            x.multiplyTo(y, r);
            this.reduce(r);
        }

        function cSqrTo(x, r) {
            x.squareTo(r);
            this.reduce(r);
        }

        Classic.prototype.convert = cConvert;
        Classic.prototype.revert = cRevert;
        Classic.prototype.reduce = cReduce;
        Classic.prototype.mulTo = cMulTo;
        Classic.prototype.sqrTo = cSqrTo;

// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
        function bnpInvDigit() {
            if (this.t < 1) return 0;
            var x = this.data[0];
            if ((x & 1) == 0) return 0;
            var y = x & 3;		// y == 1/x mod 2^2
            y = (y * (2 - (x & 0xf) * y)) & 0xf;	// y == 1/x mod 2^4
            y = (y * (2 - (x & 0xff) * y)) & 0xff;	// y == 1/x mod 2^8
            y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff;	// y == 1/x mod 2^16
            // last step - calculate inverse mod DV directly;
            // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
            y = (y * (2 - x * y % this.DV)) % this.DV;		// y == 1/x mod 2^dbits
            // we really want the negative inverse, and -DV < y < DV
            return (y > 0) ? this.DV - y : -y;
        }

// Montgomery reduction
        function Montgomery(m) {
            this.m = m;
            this.mp = m.invDigit();
            this.mpl = this.mp & 0x7fff;
            this.mph = this.mp >> 15;
            this.um = (1 << (m.DB - 15)) - 1;
            this.mt2 = 2 * m.t;
        }

// xR mod m
        function montConvert(x) {
            var r = nbi();
            x.abs().dlShiftTo(this.m.t, r);
            r.divRemTo(this.m, null, r);
            if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
            return r;
        }

// x/R mod m
        function montRevert(x) {
            var r = nbi();
            x.copyTo(r);
            this.reduce(r);
            return r;
        }

// x = x/R mod m (HAC 14.32)
        function montReduce(x) {
            while (x.t <= this.mt2)	// pad x so am has enough room later
                x.data[x.t++] = 0;
            for (var i = 0; i < this.m.t; ++i) {
                // faster way of calculating u0 = x.data[i]*mp mod DV
                var j = x.data[i] & 0x7fff;
                var u0 = (j * this.mpl + (((j * this.mph + (x.data[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
                // use am to combine the multiply-shift-add into one call
                j = i + this.m.t;
                x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
                // propagate carry
                while (x.data[j] >= x.DV) {
                    x.data[j] -= x.DV;
                    x.data[++j]++;
                }
            }
            x.clamp();
            x.drShiftTo(this.m.t, x);
            if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
        }

// r = "x^2/R mod m"; x != r
        function montSqrTo(x, r) {
            x.squareTo(r);
            this.reduce(r);
        }

// r = "xy/R mod m"; x,y != r
        function montMulTo(x, y, r) {
            x.multiplyTo(y, r);
            this.reduce(r);
        }

        Montgomery.prototype.convert = montConvert;
        Montgomery.prototype.revert = montRevert;
        Montgomery.prototype.reduce = montReduce;
        Montgomery.prototype.mulTo = montMulTo;
        Montgomery.prototype.sqrTo = montSqrTo;

// (protected) true iff this is even
        function bnpIsEven() {
            return ((this.t > 0) ? (this.data[0] & 1) : this.s) == 0;
        }

// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
        function bnpExp(e, z) {
            if (e > 0xffffffff || e < 1) return BigInteger.ONE;
            var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
            g.copyTo(r);
            while (--i >= 0) {
                z.sqrTo(r, r2);
                if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);
                else {
                    var t = r;
                    r = r2;
                    r2 = t;
                }
            }
            return z.revert(r);
        }

// (public) this^e % m, 0 <= e < 2^32
        function bnModPowInt(e, m) {
            var z;
            if (e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
            return this.exp(e, z);
        }

// protected
        BigInteger.prototype.copyTo = bnpCopyTo;
        BigInteger.prototype.fromInt = bnpFromInt;
        BigInteger.prototype.fromString = bnpFromString;
        BigInteger.prototype.clamp = bnpClamp;
        BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
        BigInteger.prototype.drShiftTo = bnpDRShiftTo;
        BigInteger.prototype.lShiftTo = bnpLShiftTo;
        BigInteger.prototype.rShiftTo = bnpRShiftTo;
        BigInteger.prototype.subTo = bnpSubTo;
        BigInteger.prototype.multiplyTo = bnpMultiplyTo;
        BigInteger.prototype.squareTo = bnpSquareTo;
        BigInteger.prototype.divRemTo = bnpDivRemTo;
        BigInteger.prototype.invDigit = bnpInvDigit;
        BigInteger.prototype.isEven = bnpIsEven;
        BigInteger.prototype.exp = bnpExp;

// public
        BigInteger.prototype.toString = bnToString;
        BigInteger.prototype.negate = bnNegate;
        BigInteger.prototype.abs = bnAbs;
        BigInteger.prototype.compareTo = bnCompareTo;
        BigInteger.prototype.bitLength = bnBitLength;
        BigInteger.prototype.mod = bnMod;
        BigInteger.prototype.modPowInt = bnModPowInt;

// "constants"
        BigInteger.ZERO = nbv(0);
        BigInteger.ONE = nbv(1);

// jsbn2 lib

//Copyright (c) 2005-2009  Tom Wu
//All Rights Reserved.
//See "LICENSE" for details (See jsbn.js for LICENSE).

//Extended JavaScript BN functions, required for RSA private ops.

//Version 1.1: new BigInteger("0", 10) returns "proper" zero

//(public)
        function bnClone() {
            var r = nbi();
            this.copyTo(r);
            return r;
        }

//(public) return value as integer
        function bnIntValue() {
            if (this.s < 0) {
                if (this.t == 1) return this.data[0] - this.DV;
                else if (this.t == 0) return -1;
            } else if (this.t == 1) return this.data[0];
            else if (this.t == 0) return 0;
// assumes 16 < DB < 32
            return ((this.data[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this.data[0];
        }

//(public) return value as byte
        function bnByteValue() {
            return (this.t == 0) ? this.s : (this.data[0] << 24) >> 24;
        }

//(public) return value as short (assumes DB>=16)
        function bnShortValue() {
            return (this.t == 0) ? this.s : (this.data[0] << 16) >> 16;
        }

//(protected) return x s.t. r^x < DV
        function bnpChunkSize(r) {
            return Math.floor(Math.LN2 * this.DB / Math.log(r));
        }

//(public) 0 if this == 0, 1 if this > 0
        function bnSigNum() {
            if (this.s < 0) return -1;
            else if (this.t <= 0 || (this.t == 1 && this.data[0] <= 0)) return 0;
            else return 1;
        }

//(protected) convert to radix string
        function bnpToRadix(b) {
            if (b == null) b = 10;
            if (this.signum() == 0 || b < 2 || b > 36) return "0";
            var cs = this.chunkSize(b);
            var a = Math.pow(b, cs);
            var d = nbv(a), y = nbi(), z = nbi(), r = "";
            this.divRemTo(d, y, z);
            while (y.signum() > 0) {
                r = (a + z.intValue()).toString(b).substr(1) + r;
                y.divRemTo(d, y, z);
            }
            return z.intValue().toString(b) + r;
        }

//(protected) convert from radix string
        function bnpFromRadix(s, b) {
            this.fromInt(0);
            if (b == null) b = 10;
            var cs = this.chunkSize(b);
            var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
            for (var i = 0; i < s.length; ++i) {
                var x = intAt(s, i);
                if (x < 0) {
                    if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
                    continue;
                }
                w = b * w + x;
                if (++j >= cs) {
                    this.dMultiply(d);
                    this.dAddOffset(w, 0);
                    j = 0;
                    w = 0;
                }
            }
            if (j > 0) {
                this.dMultiply(Math.pow(b, j));
                this.dAddOffset(w, 0);
            }
            if (mi) BigInteger.ZERO.subTo(this, this);
        }

//(protected) alternate constructor
        function bnpFromNumber(a, b, c) {
            if ("number" == typeof b) {
                // new BigInteger(int,int,RNG)
                if (a < 2) this.fromInt(1);
                else {
                    this.fromNumber(a, c);
                    if (!this.testBit(a - 1))  // force MSB set
                        this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                    if (this.isEven()) this.dAddOffset(1, 0); // force odd
                    while (!this.isProbablePrime(b)) {
                        this.dAddOffset(2, 0);
                        if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
                    }
                }
            } else {
                // new BigInteger(int,RNG)
                var x = new Array(), t = a & 7;
                x.length = (a >> 3) + 1;
                b.nextBytes(x);
                if (t > 0) x[0] &= ((1 << t) - 1); else x[0] = 0;
                this.fromString(x, 256);
            }
        }

//(public) convert to bigendian byte array
        function bnToByteArray() {
            var i = this.t, r = new Array();
            r[0] = this.s;
            var p = this.DB - (i * this.DB) % 8, d, k = 0;
            if (i-- > 0) {
                if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p)
                    r[k++] = d | (this.s << (this.DB - p));
                while (i >= 0) {
                    if (p < 8) {
                        d = (this.data[i] & ((1 << p) - 1)) << (8 - p);
                        d |= this.data[--i] >> (p += this.DB - 8);
                    } else {
                        d = (this.data[i] >> (p -= 8)) & 0xff;
                        if (p <= 0) {
                            p += this.DB;
                            --i;
                        }
                    }
                    if ((d & 0x80) != 0) d |= -256;
                    if (k == 0 && (this.s & 0x80) != (d & 0x80)) ++k;
                    if (k > 0 || d != this.s) r[k++] = d;
                }
            }
            return r;
        }

        function bnEquals(a) {
            return (this.compareTo(a) == 0);
        }

        function bnMin(a) {
            return (this.compareTo(a) < 0) ? this : a;
        }

        function bnMax(a) {
            return (this.compareTo(a) > 0) ? this : a;
        }

//(protected) r = this op a (bitwise)
        function bnpBitwiseTo(a, op, r) {
            var i, f, m = Math.min(a.t, this.t);
            for (i = 0; i < m; ++i) r.data[i] = op(this.data[i], a.data[i]);
            if (a.t < this.t) {
                f = a.s & this.DM;
                for (i = m; i < this.t; ++i) r.data[i] = op(this.data[i], f);
                r.t = this.t;
            } else {
                f = this.s & this.DM;
                for (i = m; i < a.t; ++i) r.data[i] = op(f, a.data[i]);
                r.t = a.t;
            }
            r.s = op(this.s, a.s);
            r.clamp();
        }

//(public) this & a
        function op_and(x, y) {
            return x & y;
        }

        function bnAnd(a) {
            var r = nbi();
            this.bitwiseTo(a, op_and, r);
            return r;
        }

//(public) this | a
        function op_or(x, y) {
            return x | y;
        }

        function bnOr(a) {
            var r = nbi();
            this.bitwiseTo(a, op_or, r);
            return r;
        }

//(public) this ^ a
        function op_xor(x, y) {
            return x ^ y;
        }

        function bnXor(a) {
            var r = nbi();
            this.bitwiseTo(a, op_xor, r);
            return r;
        }

//(public) this & ~a
        function op_andnot(x, y) {
            return x & ~y;
        }

        function bnAndNot(a) {
            var r = nbi();
            this.bitwiseTo(a, op_andnot, r);
            return r;
        }

//(public) ~this
        function bnNot() {
            var r = nbi();
            for (var i = 0; i < this.t; ++i) r.data[i] = this.DM & ~this.data[i];
            r.t = this.t;
            r.s = ~this.s;
            return r;
        }

//(public) this << n
        function bnShiftLeft(n) {
            var r = nbi();
            if (n < 0) this.rShiftTo(-n, r); else this.lShiftTo(n, r);
            return r;
        }

//(public) this >> n
        function bnShiftRight(n) {
            var r = nbi();
            if (n < 0) this.lShiftTo(-n, r); else this.rShiftTo(n, r);
            return r;
        }

//return index of lowest 1-bit in x, x < 2^31
        function lbit(x) {
            if (x == 0) return -1;
            var r = 0;
            if ((x & 0xffff) == 0) {
                x >>= 16;
                r += 16;
            }
            if ((x & 0xff) == 0) {
                x >>= 8;
                r += 8;
            }
            if ((x & 0xf) == 0) {
                x >>= 4;
                r += 4;
            }
            if ((x & 3) == 0) {
                x >>= 2;
                r += 2;
            }
            if ((x & 1) == 0) ++r;
            return r;
        }

//(public) returns index of lowest 1-bit (or -1 if none)
        function bnGetLowestSetBit() {
            for (var i = 0; i < this.t; ++i)
                if (this.data[i] != 0) return i * this.DB + lbit(this.data[i]);
            if (this.s < 0) return this.t * this.DB;
            return -1;
        }

//return number of 1 bits in x
        function cbit(x) {
            var r = 0;
            while (x != 0) {
                x &= x - 1;
                ++r;
            }
            return r;
        }

//(public) return number of set bits
        function bnBitCount() {
            var r = 0, x = this.s & this.DM;
            for (var i = 0; i < this.t; ++i) r += cbit(this.data[i] ^ x);
            return r;
        }

//(public) true iff nth bit is set
        function bnTestBit(n) {
            var j = Math.floor(n / this.DB);
            if (j >= this.t) return (this.s != 0);
            return ((this.data[j] & (1 << (n % this.DB))) != 0);
        }

//(protected) this op (1<<n)
        function bnpChangeBit(n, op) {
            var r = BigInteger.ONE.shiftLeft(n);
            this.bitwiseTo(r, op, r);
            return r;
        }

//(public) this | (1<<n)
        function bnSetBit(n) {
            return this.changeBit(n, op_or);
        }

//(public) this & ~(1<<n)
        function bnClearBit(n) {
            return this.changeBit(n, op_andnot);
        }

//(public) this ^ (1<<n)
        function bnFlipBit(n) {
            return this.changeBit(n, op_xor);
        }

//(protected) r = this + a
        function bnpAddTo(a, r) {
            var i = 0, c = 0, m = Math.min(a.t, this.t);
            while (i < m) {
                c += this.data[i] + a.data[i];
                r.data[i++] = c & this.DM;
                c >>= this.DB;
            }
            if (a.t < this.t) {
                c += a.s;
                while (i < this.t) {
                    c += this.data[i];
                    r.data[i++] = c & this.DM;
                    c >>= this.DB;
                }
                c += this.s;
            } else {
                c += this.s;
                while (i < a.t) {
                    c += a.data[i];
                    r.data[i++] = c & this.DM;
                    c >>= this.DB;
                }
                c += a.s;
            }
            r.s = (c < 0) ? -1 : 0;
            if (c > 0) r.data[i++] = c;
            else if (c < -1) r.data[i++] = this.DV + c;
            r.t = i;
            r.clamp();
        }

//(public) this + a
        function bnAdd(a) {
            var r = nbi();
            this.addTo(a, r);
            return r;
        }

//(public) this - a
        function bnSubtract(a) {
            var r = nbi();
            this.subTo(a, r);
            return r;
        }

//(public) this * a
        function bnMultiply(a) {
            var r = nbi();
            this.multiplyTo(a, r);
            return r;
        }

//(public) this / a
        function bnDivide(a) {
            var r = nbi();
            this.divRemTo(a, r, null);
            return r;
        }

//(public) this % a
        function bnRemainder(a) {
            var r = nbi();
            this.divRemTo(a, null, r);
            return r;
        }

//(public) [this/a,this%a]
        function bnDivideAndRemainder(a) {
            var q = nbi(), r = nbi();
            this.divRemTo(a, q, r);
            return new Array(q, r);
        }

//(protected) this *= n, this >= 0, 1 < n < DV
        function bnpDMultiply(n) {
            this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
            ++this.t;
            this.clamp();
        }

//(protected) this += n << w words, this >= 0
        function bnpDAddOffset(n, w) {
            if (n == 0) return;
            while (this.t <= w) this.data[this.t++] = 0;
            this.data[w] += n;
            while (this.data[w] >= this.DV) {
                this.data[w] -= this.DV;
                if (++w >= this.t) this.data[this.t++] = 0;
                ++this.data[w];
            }
        }

//A "null" reducer
        function NullExp() {
        }

        function nNop(x) {
            return x;
        }

        function nMulTo(x, y, r) {
            x.multiplyTo(y, r);
        }

        function nSqrTo(x, r) {
            x.squareTo(r);
        }

        NullExp.prototype.convert = nNop;
        NullExp.prototype.revert = nNop;
        NullExp.prototype.mulTo = nMulTo;
        NullExp.prototype.sqrTo = nSqrTo;

//(public) this^e
        function bnPow(e) {
            return this.exp(e, new NullExp());
        }

//(protected) r = lower n words of "this * a", a.t <= n
//"this" should be the larger one if appropriate.
        function bnpMultiplyLowerTo(a, n, r) {
            var i = Math.min(this.t + a.t, n);
            r.s = 0; // assumes a,this >= 0
            r.t = i;
            while (i > 0) r.data[--i] = 0;
            var j;
            for (j = r.t - this.t; i < j; ++i) r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
            for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a.data[i], r, i, 0, n - i);
            r.clamp();
        }

//(protected) r = "this * a" without lower n words, n > 0
//"this" should be the larger one if appropriate.
        function bnpMultiplyUpperTo(a, n, r) {
            --n;
            var i = r.t = this.t + a.t - n;
            r.s = 0; // assumes a,this >= 0
            while (--i >= 0) r.data[i] = 0;
            for (i = Math.max(n - this.t, 0); i < a.t; ++i)
                r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
            r.clamp();
            r.drShiftTo(1, r);
        }

//Barrett modular reduction
        function Barrett(m) {
// setup Barrett
            this.r2 = nbi();
            this.q3 = nbi();
            BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
            this.mu = this.r2.divide(m);
            this.m = m;
        }

        function barrettConvert(x) {
            if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
            else if (x.compareTo(this.m) < 0) return x;
            else {
                var r = nbi();
                x.copyTo(r);
                this.reduce(r);
                return r;
            }
        }

        function barrettRevert(x) {
            return x;
        }

//x = x mod m (HAC 14.42)
        function barrettReduce(x) {
            x.drShiftTo(this.m.t - 1, this.r2);
            if (x.t > this.m.t + 1) {
                x.t = this.m.t + 1;
                x.clamp();
            }
            this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
            this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
            while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
            x.subTo(this.r2, x);
            while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
        }

//r = x^2 mod m; x != r
        function barrettSqrTo(x, r) {
            x.squareTo(r);
            this.reduce(r);
        }

//r = x*y mod m; x,y != r
        function barrettMulTo(x, y, r) {
            x.multiplyTo(y, r);
            this.reduce(r);
        }

        Barrett.prototype.convert = barrettConvert;
        Barrett.prototype.revert = barrettRevert;
        Barrett.prototype.reduce = barrettReduce;
        Barrett.prototype.mulTo = barrettMulTo;
        Barrett.prototype.sqrTo = barrettSqrTo;

//(public) this^e % m (HAC 14.85)
        function bnModPow(e, m) {
            var i = e.bitLength(), k, r = nbv(1), z;
            if (i <= 0) return r;
            else if (i < 18) k = 1;
            else if (i < 48) k = 3;
            else if (i < 144) k = 4;
            else if (i < 768) k = 5;
            else k = 6;
            if (i < 8)
                z = new Classic(m);
            else if (m.isEven())
                z = new Barrett(m);
            else
                z = new Montgomery(m);

// precomputation
            var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
            g[1] = z.convert(this);
            if (k > 1) {
                var g2 = nbi();
                z.sqrTo(g[1], g2);
                while (n <= km) {
                    g[n] = nbi();
                    z.mulTo(g2, g[n - 2], g[n]);
                    n += 2;
                }
            }

            var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
            i = nbits(e.data[j]) - 1;
            while (j >= 0) {
                if (i >= k1) w = (e.data[j] >> (i - k1)) & km;
                else {
                    w = (e.data[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
                    if (j > 0) w |= e.data[j - 1] >> (this.DB + i - k1);
                }

                n = k;
                while ((w & 1) == 0) {
                    w >>= 1;
                    --n;
                }
                if ((i -= n) < 0) {
                    i += this.DB;
                    --j;
                }
                if (is1) {  // ret == 1, don't bother squaring or multiplying it
                    g[w].copyTo(r);
                    is1 = false;
                } else {
                    while (n > 1) {
                        z.sqrTo(r, r2);
                        z.sqrTo(r2, r);
                        n -= 2;
                    }
                    if (n > 0) z.sqrTo(r, r2); else {
                        t = r;
                        r = r2;
                        r2 = t;
                    }
                    z.mulTo(r2, g[w], r);
                }

                while (j >= 0 && (e.data[j] & (1 << i)) == 0) {
                    z.sqrTo(r, r2);
                    t = r;
                    r = r2;
                    r2 = t;
                    if (--i < 0) {
                        i = this.DB - 1;
                        --j;
                    }
                }
            }
            return z.revert(r);
        }

//(public) gcd(this,a) (HAC 14.54)
        function bnGCD(a) {
            var x = (this.s < 0) ? this.negate() : this.clone();
            var y = (a.s < 0) ? a.negate() : a.clone();
            if (x.compareTo(y) < 0) {
                var t = x;
                x = y;
                y = t;
            }
            var i = x.getLowestSetBit(), g = y.getLowestSetBit();
            if (g < 0) return x;
            if (i < g) g = i;
            if (g > 0) {
                x.rShiftTo(g, x);
                y.rShiftTo(g, y);
            }
            while (x.signum() > 0) {
                if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
                if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
                if (x.compareTo(y) >= 0) {
                    x.subTo(y, x);
                    x.rShiftTo(1, x);
                } else {
                    y.subTo(x, y);
                    y.rShiftTo(1, y);
                }
            }
            if (g > 0) y.lShiftTo(g, y);
            return y;
        }

//(protected) this % n, n < 2^26
        function bnpModInt(n) {
            if (n <= 0) return 0;
            var d = this.DV % n, r = (this.s < 0) ? n - 1 : 0;
            if (this.t > 0)
                if (d == 0) r = this.data[0] % n;
                else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this.data[i]) % n;
            return r;
        }

//(public) 1/this % m (HAC 14.61)
        function bnModInverse(m) {
            var ac = m.isEven();
            if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
            var u = m.clone(), v = this.clone();
            var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
            while (u.signum() != 0) {
                while (u.isEven()) {
                    u.rShiftTo(1, u);
                    if (ac) {
                        if (!a.isEven() || !b.isEven()) {
                            a.addTo(this, a);
                            b.subTo(m, b);
                        }
                        a.rShiftTo(1, a);
                    } else if (!b.isEven()) b.subTo(m, b);
                    b.rShiftTo(1, b);
                }
                while (v.isEven()) {
                    v.rShiftTo(1, v);
                    if (ac) {
                        if (!c.isEven() || !d.isEven()) {
                            c.addTo(this, c);
                            d.subTo(m, d);
                        }
                        c.rShiftTo(1, c);
                    } else if (!d.isEven()) d.subTo(m, d);
                    d.rShiftTo(1, d);
                }
                if (u.compareTo(v) >= 0) {
                    u.subTo(v, u);
                    if (ac) a.subTo(c, a);
                    b.subTo(d, b);
                } else {
                    v.subTo(u, v);
                    if (ac) c.subTo(a, c);
                    d.subTo(b, d);
                }
            }
            if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
            if (d.compareTo(m) >= 0) return d.subtract(m);
            if (d.signum() < 0) d.addTo(m, d); else return d;
            if (d.signum() < 0) return d.add(m); else return d;
        }

        var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
        var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];

//(public) test primality with certainty >= 1-.5^t
        function bnIsProbablePrime(t) {
            var i, x = this.abs();
            if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
                for (i = 0; i < lowprimes.length; ++i)
                    if (x.data[0] == lowprimes[i]) return true;
                return false;
            }
            if (x.isEven()) return false;
            i = 1;
            while (i < lowprimes.length) {
                var m = lowprimes[i], j = i + 1;
                while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
                m = x.modInt(m);
                while (i < j) if (m % lowprimes[i++] == 0) return false;
            }
            return x.millerRabin(t);
        }

//(protected) true if probably prime (HAC 4.24, Miller-Rabin)
        function bnpMillerRabin(t) {
            var n1 = this.subtract(BigInteger.ONE);
            var k = n1.getLowestSetBit();
            if (k <= 0) return false;
            var r = n1.shiftRight(k);
            var prng = bnGetPrng();
            var a;
            for (var i = 0; i < t; ++i) {
                // select witness 'a' at random from between 1 and n1
                do {
                    a = new BigInteger(this.bitLength(), prng);
                }
                while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
                var y = a.modPow(r, this);
                if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
                    var j = 1;
                    while (j++ < k && y.compareTo(n1) != 0) {
                        y = y.modPowInt(2, this);
                        if (y.compareTo(BigInteger.ONE) == 0) return false;
                    }
                    if (y.compareTo(n1) != 0) return false;
                }
            }
            return true;
        }

// get pseudo random number generator
        function bnGetPrng() {
            // create prng with api that matches BigInteger secure random
            return {
                // x is an array to fill with bytes
                nextBytes: function (x) {
                    for (var i = 0; i < x.length; ++i) {
                        x[i] = Math.floor(Math.random() * 0x0100);
                    }
                }
            };
        }

//protected
        BigInteger.prototype.chunkSize = bnpChunkSize;
        BigInteger.prototype.toRadix = bnpToRadix;
        BigInteger.prototype.fromRadix = bnpFromRadix;
        BigInteger.prototype.fromNumber = bnpFromNumber;
        BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
        BigInteger.prototype.changeBit = bnpChangeBit;
        BigInteger.prototype.addTo = bnpAddTo;
        BigInteger.prototype.dMultiply = bnpDMultiply;
        BigInteger.prototype.dAddOffset = bnpDAddOffset;
        BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
        BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
        BigInteger.prototype.modInt = bnpModInt;
        BigInteger.prototype.millerRabin = bnpMillerRabin;

//public
        BigInteger.prototype.clone = bnClone;
        BigInteger.prototype.intValue = bnIntValue;
        BigInteger.prototype.byteValue = bnByteValue;
        BigInteger.prototype.shortValue = bnShortValue;
        BigInteger.prototype.signum = bnSigNum;
        BigInteger.prototype.toByteArray = bnToByteArray;
        BigInteger.prototype.equals = bnEquals;
        BigInteger.prototype.min = bnMin;
        BigInteger.prototype.max = bnMax;
        BigInteger.prototype.and = bnAnd;
        BigInteger.prototype.or = bnOr;
        BigInteger.prototype.xor = bnXor;
        BigInteger.prototype.andNot = bnAndNot;
        BigInteger.prototype.not = bnNot;
        BigInteger.prototype.shiftLeft = bnShiftLeft;
        BigInteger.prototype.shiftRight = bnShiftRight;
        BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
        BigInteger.prototype.bitCount = bnBitCount;
        BigInteger.prototype.testBit = bnTestBit;
        BigInteger.prototype.setBit = bnSetBit;
        BigInteger.prototype.clearBit = bnClearBit;
        BigInteger.prototype.flipBit = bnFlipBit;
        BigInteger.prototype.add = bnAdd;
        BigInteger.prototype.subtract = bnSubtract;
        BigInteger.prototype.multiply = bnMultiply;
        BigInteger.prototype.divide = bnDivide;
        BigInteger.prototype.remainder = bnRemainder;
        BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
        BigInteger.prototype.modPow = bnModPow;
        BigInteger.prototype.modInverse = bnModInverse;
        BigInteger.prototype.pow = bnPow;
        BigInteger.prototype.gcd = bnGCD;
        BigInteger.prototype.isProbablePrime = bnIsProbablePrime;

        kcaseagt.BigInteger = BigInteger;
    }

    function initRsa() {
        var BigInteger = kcaseagt.BigInteger;

        var rsaPublicKeyValidator = {
            // RSAPublicKey
            name: 'RSAPublicKey',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
                // modulus (n)
                name: 'RSAPublicKey.modulus',
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.INTEGER,
                constructed: false,
                capture: 'publicKeyModulus'
            }, {
                // publicExponent (e)
                name: 'RSAPublicKey.exponent',
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.INTEGER,
                constructed: false,
                capture: 'publicKeyExponent'
            }]
        };

        var publicKeyValidator = {
            name: 'SubjectPublicKeyInfo',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: 'subjectPublicKeyInfo',
            value: [{
                name: 'SubjectPublicKeyInfo.AlgorithmIdentifier',
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.SEQUENCE,
                constructed: true,
                value: [{
                    name: 'AlgorithmIdentifier.algorithm',
                    tagClass: asn1.Class.UNIVERSAL,
                    type: asn1.Type.OID,
                    constructed: false,
                    capture: 'publicKeyOid'
                }]
            }, {
                // subjectPublicKey
                name: 'SubjectPublicKeyInfo.subjectPublicKey',
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.BITSTRING,
                constructed: false,
                value: [{
                    // RSAPublicKey
                    name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
                    tagClass: asn1.Class.UNIVERSAL,
                    type: asn1.Type.SEQUENCE,
                    constructed: true,
                    optional: true,
                    captureAsn1: 'rsaPublicKey'
                }]
            }]
        };

        function setRsaPublicKey(n, e) {
            var key = {
                n: n,
                e: e
            };

            return key;
        }

        this.publicKeyFromPem = function (pem) {
            var msg = util.decode64(pem);

            // convert DER to ASN.1 object
            var obj = asn1.fromDer(msg);

            return rsa.publicKeyFromAsn1(obj);
        };

        this.publicKeyFromAsn1 = function (obj) {
            // get SubjectPublicKeyInfo
            var capture = {};
            var errors = [];
            if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
                obj = capture.rsaPublicKey;
            }

            // get RSA params
            errors = [];
            if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
                var error = new Error('Cannot read public key. ' +
                    'ASN.1 object does not contain an RSAPublicKey.');
                error.errors = errors;
                throw error;
            }

            // FIXME: inefficient, get a BigInteger that uses byte strings
            var n = util.createBuffer(capture.publicKeyModulus).toHex();
            var e = util.createBuffer(capture.publicKeyExponent).toHex();

            // set public key
            return setRsaPublicKey(
                new BigInteger(n, 16),
                new BigInteger(e, 16));
        };

        function _encodePkcs1_v1_5(m, key, bt) {
            var eb = util.createBuffer();

            // get the length of the modulus in bytes
            var k = Math.ceil(key.n.bitLength() / 8);

            /* use PKCS#1 v1.5 padding */
            if (m.length > (k - 11)) {
                var error = new Error('Message is too long for PKCS#1 v1.5 padding.');
                error.length = m.length;
                error.max = k - 11;
                throw error;
            }

            // build the encryption block
            eb.putByte(0x00);
            eb.putByte(bt);

            // create the padding
            var padNum = k - 3 - m.length;
            var padByte;
            // private key op
            if (bt === 0x00 || bt === 0x01) {
                padByte = (bt === 0x00) ? 0x00 : 0xFF;
                for (var i = 0; i < padNum; ++i) {
                    eb.putByte(padByte);
                }
            } else {
                // public key op
                // pad with random non-zero values
                while (padNum > 0) {
                    var numZeros = 0;
                    var padBytes = random.generate(padNum);
                    for (var i = 0; i < padNum; ++i) {
                        padByte = padBytes.charCodeAt(i);
                        if (padByte === 0) {
                            ++numZeros;
                        } else {
                            eb.putByte(padByte);
                        }
                    }
                    padNum = numZeros;
                }
            }

            // zero followed by message
            eb.putByte(0x00);
            eb.putBytes(m);

            return eb;
        }

        function _decodePkcs1_v1_5(em, key, pub, ml) {
            // get the length of the modulus in bytes
            var k = Math.ceil(key.n.bitLength() / 8);

            // parse the encryption block
            var eb = util.createBuffer(em);
            var first = eb.getByte();
            var bt = eb.getByte();
            if (first !== 0x00 ||
                (pub && bt !== 0x00 && bt !== 0x01) ||
                (!pub && bt != 0x02) ||
                (pub && bt === 0x00 && typeof(ml) === 'undefined')) {
                throw new Error('Encryption block is invalid.');
            }

            var padNum = 0;
            if (bt === 0x00) {
                // check all padding bytes for 0x00
                padNum = k - 3 - ml;
                for (var i = 0; i < padNum; ++i) {
                    if (eb.getByte() !== 0x00) {
                        throw new Error('Encryption block is invalid.');
                    }
                }
            } else if (bt === 0x01) {
                // find the first byte that isn't 0xFF, should be after all padding
                padNum = 0;
                while (eb.length() > 1) {
                    if (eb.getByte() !== 0xFF) {
                        --eb.read;
                        break;
                    }
                    ++padNum;
                }
            } else if (bt === 0x02) {
                // look for 0x00 byte
                padNum = 0;
                while (eb.length() > 1) {
                    if (eb.getByte() === 0x00) {
                        --eb.read;
                        break;
                    }
                    ++padNum;
                }
            }

            // zero must be 0x00 and padNum must be (k - 3 - message length)
            var zero = eb.getByte();
            if (zero !== 0x00 || padNum !== (k - 3 - eb.length())) {
                throw new Error('Encryption block is invalid.');
            }

            return eb.getBytes();
        }

        var _modPow = function (x, key, pub) {
            if (pub) {
                return x.modPow(key.e, key.n);
            }

            if (!key.p || !key.q) {
                // allow calculation without CRT params (slow)
                return x.modPow(key.d, key.n);
            }

            // pre-compute dP, dQ, and qInv if necessary
            if (!key.dP) {
                key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
            }
            if (!key.dQ) {
                key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
            }
            if (!key.qInv) {
                key.qInv = key.q.modInverse(key.p);
            }

            // cryptographic blinding
            var r;
            do {
                r = new BigInteger(
                    util.bytesToHex(random.getBytes(key.n.bitLength() / 8)),
                    16).mod(key.n);
            } while (r.equals(BigInteger.ZERO));
            x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);

            // calculate xp and xq
            var xp = x.mod(key.p).modPow(key.dP, key.p);
            var xq = x.mod(key.q).modPow(key.dQ, key.q);

            // xp must be larger than xq to avoid signed bit usage
            while (xp.compareTo(xq) < 0) {
                xp = xp.add(key.p);
            }

            // do last step
            var y = xp.subtract(xq)
                .multiply(key.qInv).mod(key.p)
                .multiply(key.q).add(xq);

            // remove effect of random for cryptographic blinding
            y = y.multiply(r.modInverse(key.n)).mod(key.n);

            return y;
        };

        this.encrypt = function (m, key, bt) {
            var e, encData;
            while(true) {
                e = _encodePkcs1_v1_5(m, key, 0x02).getBytes();
                encData = _rsaEncrypt(e, key, true);
                if (encData.length == (key.n.bitLength()/8)) {
                    break;
                }
            }
            return encData;
        };

        function _rsaEncrypt(m, key, bt) {
            var pub = bt;
            var eb;

            // get the length of the modulus in bytes
            var k = Math.ceil(key.n.bitLength() / 8);

            if (bt !== false && bt !== true) {
                // legacy, default to PKCS#1 v1.5 padding
                pub = (bt === 0x02);
                eb = _encodePkcs1_v1_5(m, key, bt);
            } else {
                eb = util.createBuffer();
                eb.putBytes(m);
            }

            // load encryption block as big integer 'x'
            // FIXME: hex conversion inefficient, get BigInteger w/byte strings
            var x = new BigInteger(eb.toHex(), 16);

            // do RSA encryption
            var y = _modPow(x, key, pub);

            // convert y into the encrypted data byte string, if y is shorter in
            // bytes than k, then prepend zero bytes to fill up ed
            // FIXME: hex conversion inefficient, get BigInteger w/byte strings
            var yhex = y.toString(16);
            var ed = util.createBuffer();
            var zeros = k - Math.ceil(yhex.length / 2);
            while (zeros > 0) {
                ed.putByte(0x00);
                --zeros;
            }
            ed.putBytes(util.hexToBytes(yhex));
            return ed.getBytes();
        }

        this.decrypt = function (ed, key, pub, ml) {
            // get the length of the modulus in bytes
            var k = Math.ceil(key.n.bitLength() / 8);

            // error if the length of the encrypted data ED is not k
            if (ed.length !== k) {
                var error = new Error('Encrypted message length is invalid.');
                error.length = ed.length;
                error.expected = k;
                throw error;
            }

            // convert encrypted data into a big integer
            // FIXME: hex conversion inefficient, get BigInteger w/byte strings
            var y = new BigInteger(util.createBuffer(ed).toHex(), 16);

            // y must be less than the modulus or it wasn't the result of
            // a previous mod operation (encryption) using that modulus
            if (y.compareTo(key.n) >= 0) {
                throw new Error('Encrypted message is invalid.');
            }

            // do RSA decryption
            var x = _modPow(y, key, pub);

            // create the encryption block, if x is shorter in bytes than k, then
            // prepend zero bytes to fill up eb
            // FIXME: hex conversion inefficient, get BigInteger w/byte strings
            var xhex = x.toString(16);
            var eb = util.createBuffer();
            var zeros = k - Math.ceil(xhex.length / 2);
            while (zeros > 0) {
                eb.putByte(0x00);
                eb.putByte(0x01);
                --zeros;
            }

            eb.putBytes(util.hexToBytes(xhex));

            // return message
            return eb.getBytes();
        };

        this.verify = function (digest, signature, key) {
            var d = rsa.decrypt(signature, key, true, false);

            // remove padding
            d = _decodePkcs1_v1_5(d, key, true);
            var obj = asn1.fromDer(d);
            return digest === obj.value[1].value;
        };
    }

    function initRandom() {
        function _generate(byte) {
            var randValue;
            var cnt = byte / 32;
            var rem = byte % 32;

            randValue = util.createBuffer();

            if (cnt > 0) {
                for (var i = 1; i < cnt; i++) {
                    randValue.putBytes(_rand(32));
                }
            }

            if (rem > 0) {
                randValue.putBytes(_rand(rem));
            }

            if (cnt == 1 && rem == 0) {
                randValue.putBytes(_rand(32));
            }

            function _rand(b) {
                var hash = sha256.create();
                hash.update(Math.random(), "utf8");
                var digest = hash.digest();
                return digest.getBytes(b);
            }
            return randValue.getBytes();
        }

        this.generate = _generate;

        this.generateStr = function () {
            var bytes = _generate(32);
            var retBytes = "";
            var randBytes = util.createBuffer();

            randBytes.putBytes(bytes);

            for(var i = 0; i < randBytes.length(); i++) {
                var b = randBytes.getByte();

                if((b > 65 && b < 90) || (b > 97 && b < 122)) {
                    retBytes += String.fromCharCode(b);
                }
            }
            return retBytes;
        };
    }
    function initSeed() {
        this.startEncrypting = function (key, iv, output, mode) {
            var cipher = _createCipher({
                key: key,
                output: output,
                decrypt: false,
                mode: mode || (iv === null ? 'ECB' : 'CBC')
            });
            cipher.start(iv);
            return cipher;
        };

        this.createEncryptionCipher = function (key, mode) {
            return _createCipher({
                key: key,
                output: null,
                decrypt: false,
                mode: mode
            });
        };

        this.startDecrypting = function (key, iv, output, mode) {
            var cipher = _createCipher({
                key: key,
                output: output,
                decrypt: true,
                mode: mode || (iv === null ? 'ECB' : 'CBC')
            });
            cipher.start(iv);
            return cipher;
        };

        this.createDecryptionCipher = function (key, mode) {
            return _createCipher({
                key: key,
                output: null,
                decrypt: true,
                mode: mode
            });
        };

        this.Algorithm = function (name, mode) {
            if (!_isInitialized) {
                _initialize();
            }

            var self = this;
            self.name = name;
            self.mode = new mode({
                blockSize: 16,
                cipher: {
                    encrypt: function (inBlock, outBlock) {
                        return _updateBlock(self._w, inBlock, outBlock, false);
                    },
                    decrypt: function (inBlock, outBlock) {
                        return _updateBlock(self._w, inBlock, outBlock, true);
                    }
                }
            });
            self._init = false;
        };

        this.Algorithm.prototype.initialize = function (options) {
            if (this._init) {
                return;
            }

            var key = options.key;
            var tmp;

            if (typeof key === 'string' && (key.length === 16)) {
                // convert key string into byte buffer
                key = util.createBuffer(key);
            }
            else if (util.isArray(key) && (key.length === 16)) {
                // convert key integer array into byte buffer
                tmp = key;
                key = util.createBuffer();
                for (var i = 0; i < tmp.length; ++i) {
                    key.putByte(tmp[i]);
                }
            }

            // convert key byte buffer into 32-bit integer array
            if (!util.isArray(key)) {
                tmp = key;
                key = [];

                // key lengths of 16 bytes allowed
                var len = tmp.length();
                if (len === 16) {
                    len = len >>> 2;
                    for (var i = 0; i < len; ++i) {
                        key.push(tmp.getInt32());
                    }
                }
            }

            // key must be an array of 32-bit integers by now
            if (!util.isArray(key) || !(key.length === 4)) {
                throw new Error('Invalid key parameter.');
            }

            // encryption operation is always used for these modes
            var mode = this.mode.name;
            var encryptOp = false;//(['CFB', 'OFB', 'CTR', 'GCM'].indexOf(mode) !== -1);

            // do key expansion
            this._w = _expandKey(key, options.decrypt && !encryptOp);
            this._init = true;
        };
        var Algorithm = this.Algorithm;

        this._expandKey = function (key, decrypt) {
            if (!isInitialized) {
                initialize();
            }
            return _expandKey(key, decrypt);
        };

        this._updateBlock = _updateBlock;

        /** Register SEED algorithms **/
        registerAlgorithm('SEED-CBC', cipher.modes.cbc);

        function registerAlgorithm(name, mode) {
            var factory = function () {
                return new Algorithm(name, mode);
            };
            cipher.registerAlgorithm(name, factory);
        }

        /** SEED implementation **/
        var _isInitialized = false;
        var _ss0;
        var _ss1;
        var _ss2;
        var _ss3;

        function _initialize() {
            _isInitialized = true;

            _ss0 = [0x2989a1a8, 0x05858184, 0x16c6d2d4, 0x13c3d3d0, 0x14445054, 0x1d0d111c, 0x2c8ca0ac, 0x25052124,
                0x1d4d515c, 0x03434340, 0x18081018, 0x1e0e121c, 0x11415150, 0x3cccf0fc, 0x0acac2c8, 0x23436360,
                0x28082028, 0x04444044, 0x20002020, 0x1d8d919c, 0x20c0e0e0, 0x22c2e2e0, 0x08c8c0c8, 0x17071314,
                0x2585a1a4, 0x0f8f838c, 0x03030300, 0x3b4b7378, 0x3b8bb3b8, 0x13031310, 0x12c2d2d0, 0x2ecee2ec,
                0x30407070, 0x0c8c808c, 0x3f0f333c, 0x2888a0a8, 0x32023230, 0x1dcdd1dc, 0x36c6f2f4, 0x34447074,
                0x2ccce0ec, 0x15859194, 0x0b0b0308, 0x17475354, 0x1c4c505c, 0x1b4b5358, 0x3d8db1bc, 0x01010100,
                0x24042024, 0x1c0c101c, 0x33437370, 0x18889098, 0x10001010, 0x0cccc0cc, 0x32c2f2f0, 0x19c9d1d8,
                0x2c0c202c, 0x27c7e3e4, 0x32427270, 0x03838380, 0x1b8b9398, 0x11c1d1d0, 0x06868284, 0x09c9c1c8,
                0x20406060, 0x10405050, 0x2383a3a0, 0x2bcbe3e8, 0x0d0d010c, 0x3686b2b4, 0x1e8e929c, 0x0f4f434c,
                0x3787b3b4, 0x1a4a5258, 0x06c6c2c4, 0x38487078, 0x2686a2a4, 0x12021210, 0x2f8fa3ac, 0x15c5d1d4,
                0x21416160, 0x03c3c3c0, 0x3484b0b4, 0x01414140, 0x12425250, 0x3d4d717c, 0x0d8d818c, 0x08080008,
                0x1f0f131c, 0x19899198, 0x00000000, 0x19091118, 0x04040004, 0x13435350, 0x37c7f3f4, 0x21c1e1e0,
                0x3dcdf1fc, 0x36467274, 0x2f0f232c, 0x27072324, 0x3080b0b0, 0x0b8b8388, 0x0e0e020c, 0x2b8ba3a8,
                0x2282a2a0, 0x2e4e626c, 0x13839390, 0x0d4d414c, 0x29496168, 0x3c4c707c, 0x09090108, 0x0a0a0208,
                0x3f8fb3bc, 0x2fcfe3ec, 0x33c3f3f0, 0x05c5c1c4, 0x07878384, 0x14041014, 0x3ecef2fc, 0x24446064,
                0x1eced2dc, 0x2e0e222c, 0x0b4b4348, 0x1a0a1218, 0x06060204, 0x21012120, 0x2b4b6368, 0x26466264,
                0x02020200, 0x35c5f1f4, 0x12829290, 0x0a8a8288, 0x0c0c000c, 0x3383b3b0, 0x3e4e727c, 0x10c0d0d0,
                0x3a4a7278, 0x07474344, 0x16869294, 0x25c5e1e4, 0x26062224, 0x00808080, 0x2d8da1ac, 0x1fcfd3dc,
                0x2181a1a0, 0x30003030, 0x37073334, 0x2e8ea2ac, 0x36063234, 0x15051114, 0x22022220, 0x38083038,
                0x34c4f0f4, 0x2787a3a4, 0x05454144, 0x0c4c404c, 0x01818180, 0x29c9e1e8, 0x04848084, 0x17879394,
                0x35053134, 0x0bcbc3c8, 0x0ecec2cc, 0x3c0c303c, 0x31417170, 0x11011110, 0x07c7c3c4, 0x09898188,
                0x35457174, 0x3bcbf3f8, 0x1acad2d8, 0x38c8f0f8, 0x14849094, 0x19495158, 0x02828280, 0x04c4c0c4,
                0x3fcff3fc, 0x09494148, 0x39093138, 0x27476364, 0x00c0c0c0, 0x0fcfc3cc, 0x17c7d3d4, 0x3888b0b8,
                0x0f0f030c, 0x0e8e828c, 0x02424240, 0x23032320, 0x11819190, 0x2c4c606c, 0x1bcbd3d8, 0x2484a0a4,
                0x34043034, 0x31c1f1f0, 0x08484048, 0x02c2c2c0, 0x2f4f636c, 0x3d0d313c, 0x2d0d212c, 0x00404040,
                0x3e8eb2bc, 0x3e0e323c, 0x3c8cb0bc, 0x01c1c1c0, 0x2a8aa2a8, 0x3a8ab2b8, 0x0e4e424c, 0x15455154,
                0x3b0b3338, 0x1cccd0dc, 0x28486068, 0x3f4f737c, 0x1c8c909c, 0x18c8d0d8, 0x0a4a4248, 0x16465254,
                0x37477374, 0x2080a0a0, 0x2dcde1ec, 0x06464244, 0x3585b1b4, 0x2b0b2328, 0x25456164, 0x3acaf2f8,
                0x23c3e3e0, 0x3989b1b8, 0x3181b1b0, 0x1f8f939c, 0x1e4e525c, 0x39c9f1f8, 0x26c6e2e4, 0x3282b2b0,
                0x31013130, 0x2acae2e8, 0x2d4d616c, 0x1f4f535c, 0x24c4e0e4, 0x30c0f0f0, 0x0dcdc1cc, 0x08888088,
                0x16061214, 0x3a0a3238, 0x18485058, 0x14c4d0d4, 0x22426260, 0x29092128, 0x07070304, 0x33033330,
                0x28c8e0e8, 0x1b0b1318, 0x05050104, 0x39497178, 0x10809090, 0x2a4a6268, 0x2a0a2228, 0x1a8a9298];

            _ss1 = [0x38380830, 0xe828c8e0, 0x2c2d0d21, 0xa42686a2, 0xcc0fcfc3, 0xdc1eced2, 0xb03383b3, 0xb83888b0,
                0xac2f8fa3, 0x60204060, 0x54154551, 0xc407c7c3, 0x44044440, 0x6c2f4f63, 0x682b4b63, 0x581b4b53,
                0xc003c3c3, 0x60224262, 0x30330333, 0xb43585b1, 0x28290921, 0xa02080a0, 0xe022c2e2, 0xa42787a3,
                0xd013c3d3, 0x90118191, 0x10110111, 0x04060602, 0x1c1c0c10, 0xbc3c8cb0, 0x34360632, 0x480b4b43,
                0xec2fcfe3, 0x88088880, 0x6c2c4c60, 0xa82888a0, 0x14170713, 0xc404c4c0, 0x14160612, 0xf434c4f0,
                0xc002c2c2, 0x44054541, 0xe021c1e1, 0xd416c6d2, 0x3c3f0f33, 0x3c3d0d31, 0x8c0e8e82, 0x98188890,
                0x28280820, 0x4c0e4e42, 0xf436c6f2, 0x3c3e0e32, 0xa42585a1, 0xf839c9f1, 0x0c0d0d01, 0xdc1fcfd3,
                0xd818c8d0, 0x282b0b23, 0x64264662, 0x783a4a72, 0x24270723, 0x2c2f0f23, 0xf031c1f1, 0x70324272,
                0x40024242, 0xd414c4d0, 0x40014141, 0xc000c0c0, 0x70334373, 0x64274763, 0xac2c8ca0, 0x880b8b83,
                0xf437c7f3, 0xac2d8da1, 0x80008080, 0x1c1f0f13, 0xc80acac2, 0x2c2c0c20, 0xa82a8aa2, 0x34340430,
                0xd012c2d2, 0x080b0b03, 0xec2ecee2, 0xe829c9e1, 0x5c1d4d51, 0x94148490, 0x18180810, 0xf838c8f0,
                0x54174753, 0xac2e8ea2, 0x08080800, 0xc405c5c1, 0x10130313, 0xcc0dcdc1, 0x84068682, 0xb83989b1,
                0xfc3fcff3, 0x7c3d4d71, 0xc001c1c1, 0x30310131, 0xf435c5f1, 0x880a8a82, 0x682a4a62, 0xb03181b1,
                0xd011c1d1, 0x20200020, 0xd417c7d3, 0x00020202, 0x20220222, 0x04040400, 0x68284860, 0x70314171,
                0x04070703, 0xd81bcbd3, 0x9c1d8d91, 0x98198991, 0x60214161, 0xbc3e8eb2, 0xe426c6e2, 0x58194951,
                0xdc1dcdd1, 0x50114151, 0x90108090, 0xdc1cccd0, 0x981a8a92, 0xa02383a3, 0xa82b8ba3, 0xd010c0d0,
                0x80018181, 0x0c0f0f03, 0x44074743, 0x181a0a12, 0xe023c3e3, 0xec2ccce0, 0x8c0d8d81, 0xbc3f8fb3,
                0x94168692, 0x783b4b73, 0x5c1c4c50, 0xa02282a2, 0xa02181a1, 0x60234363, 0x20230323, 0x4c0d4d41,
                0xc808c8c0, 0x9c1e8e92, 0x9c1c8c90, 0x383a0a32, 0x0c0c0c00, 0x2c2e0e22, 0xb83a8ab2, 0x6c2e4e62,
                0x9c1f8f93, 0x581a4a52, 0xf032c2f2, 0x90128292, 0xf033c3f3, 0x48094941, 0x78384870, 0xcc0cccc0,
                0x14150511, 0xf83bcbf3, 0x70304070, 0x74354571, 0x7c3f4f73, 0x34350531, 0x10100010, 0x00030303,
                0x64244460, 0x6c2d4d61, 0xc406c6c2, 0x74344470, 0xd415c5d1, 0xb43484b0, 0xe82acae2, 0x08090901,
                0x74364672, 0x18190911, 0xfc3ecef2, 0x40004040, 0x10120212, 0xe020c0e0, 0xbc3d8db1, 0x04050501,
                0xf83acaf2, 0x00010101, 0xf030c0f0, 0x282a0a22, 0x5c1e4e52, 0xa82989a1, 0x54164652, 0x40034343,
                0x84058581, 0x14140410, 0x88098981, 0x981b8b93, 0xb03080b0, 0xe425c5e1, 0x48084840, 0x78394971,
                0x94178793, 0xfc3cccf0, 0x1c1e0e12, 0x80028282, 0x20210121, 0x8c0c8c80, 0x181b0b13, 0x5c1f4f53,
                0x74374773, 0x54144450, 0xb03282b2, 0x1c1d0d11, 0x24250521, 0x4c0f4f43, 0x00000000, 0x44064642,
                0xec2dcde1, 0x58184850, 0x50124252, 0xe82bcbe3, 0x7c3e4e72, 0xd81acad2, 0xc809c9c1, 0xfc3dcdf1,
                0x30300030, 0x94158591, 0x64254561, 0x3c3c0c30, 0xb43686b2, 0xe424c4e0, 0xb83b8bb3, 0x7c3c4c70,
                0x0c0e0e02, 0x50104050, 0x38390931, 0x24260622, 0x30320232, 0x84048480, 0x68294961, 0x90138393,
                0x34370733, 0xe427c7e3, 0x24240420, 0xa42484a0, 0xc80bcbc3, 0x50134353, 0x080a0a02, 0x84078783,
                0xd819c9d1, 0x4c0c4c40, 0x80038383, 0x8c0f8f83, 0xcc0ecec2, 0x383b0b33, 0x480a4a42, 0xb43787b3];

            _ss2 = [0xa1a82989, 0x81840585, 0xd2d416c6, 0xd3d013c3, 0x50541444, 0x111c1d0d, 0xa0ac2c8c, 0x21242505,
                0x515c1d4d, 0x43400343, 0x10181808, 0x121c1e0e, 0x51501141, 0xf0fc3ccc, 0xc2c80aca, 0x63602343,
                0x20282808, 0x40440444, 0x20202000, 0x919c1d8d, 0xe0e020c0, 0xe2e022c2, 0xc0c808c8, 0x13141707,
                0xa1a42585, 0x838c0f8f, 0x03000303, 0x73783b4b, 0xb3b83b8b, 0x13101303, 0xd2d012c2, 0xe2ec2ece,
                0x70703040, 0x808c0c8c, 0x333c3f0f, 0xa0a82888, 0x32303202, 0xd1dc1dcd, 0xf2f436c6, 0x70743444,
                0xe0ec2ccc, 0x91941585, 0x03080b0b, 0x53541747, 0x505c1c4c, 0x53581b4b, 0xb1bc3d8d, 0x01000101,
                0x20242404, 0x101c1c0c, 0x73703343, 0x90981888, 0x10101000, 0xc0cc0ccc, 0xf2f032c2, 0xd1d819c9,
                0x202c2c0c, 0xe3e427c7, 0x72703242, 0x83800383, 0x93981b8b, 0xd1d011c1, 0x82840686, 0xc1c809c9,
                0x60602040, 0x50501040, 0xa3a02383, 0xe3e82bcb, 0x010c0d0d, 0xb2b43686, 0x929c1e8e, 0x434c0f4f,
                0xb3b43787, 0x52581a4a, 0xc2c406c6, 0x70783848, 0xa2a42686, 0x12101202, 0xa3ac2f8f, 0xd1d415c5,
                0x61602141, 0xc3c003c3, 0xb0b43484, 0x41400141, 0x52501242, 0x717c3d4d, 0x818c0d8d, 0x00080808,
                0x131c1f0f, 0x91981989, 0x00000000, 0x11181909, 0x00040404, 0x53501343, 0xf3f437c7, 0xe1e021c1,
                0xf1fc3dcd, 0x72743646, 0x232c2f0f, 0x23242707, 0xb0b03080, 0x83880b8b, 0x020c0e0e, 0xa3a82b8b,
                0xa2a02282, 0x626c2e4e, 0x93901383, 0x414c0d4d, 0x61682949, 0x707c3c4c, 0x01080909, 0x02080a0a,
                0xb3bc3f8f, 0xe3ec2fcf, 0xf3f033c3, 0xc1c405c5, 0x83840787, 0x10141404, 0xf2fc3ece, 0x60642444,
                0xd2dc1ece, 0x222c2e0e, 0x43480b4b, 0x12181a0a, 0x02040606, 0x21202101, 0x63682b4b, 0x62642646,
                0x02000202, 0xf1f435c5, 0x92901282, 0x82880a8a, 0x000c0c0c, 0xb3b03383, 0x727c3e4e, 0xd0d010c0,
                0x72783a4a, 0x43440747, 0x92941686, 0xe1e425c5, 0x22242606, 0x80800080, 0xa1ac2d8d, 0xd3dc1fcf,
                0xa1a02181, 0x30303000, 0x33343707, 0xa2ac2e8e, 0x32343606, 0x11141505, 0x22202202, 0x30383808,
                0xf0f434c4, 0xa3a42787, 0x41440545, 0x404c0c4c, 0x81800181, 0xe1e829c9, 0x80840484, 0x93941787,
                0x31343505, 0xc3c80bcb, 0xc2cc0ece, 0x303c3c0c, 0x71703141, 0x11101101, 0xc3c407c7, 0x81880989,
                0x71743545, 0xf3f83bcb, 0xd2d81aca, 0xf0f838c8, 0x90941484, 0x51581949, 0x82800282, 0xc0c404c4,
                0xf3fc3fcf, 0x41480949, 0x31383909, 0x63642747, 0xc0c000c0, 0xc3cc0fcf, 0xd3d417c7, 0xb0b83888,
                0x030c0f0f, 0x828c0e8e, 0x42400242, 0x23202303, 0x91901181, 0x606c2c4c, 0xd3d81bcb, 0xa0a42484,
                0x30343404, 0xf1f031c1, 0x40480848, 0xc2c002c2, 0x636c2f4f, 0x313c3d0d, 0x212c2d0d, 0x40400040,
                0xb2bc3e8e, 0x323c3e0e, 0xb0bc3c8c, 0xc1c001c1, 0xa2a82a8a, 0xb2b83a8a, 0x424c0e4e, 0x51541545,
                0x33383b0b, 0xd0dc1ccc, 0x60682848, 0x737c3f4f, 0x909c1c8c, 0xd0d818c8, 0x42480a4a, 0x52541646,
                0x73743747, 0xa0a02080, 0xe1ec2dcd, 0x42440646, 0xb1b43585, 0x23282b0b, 0x61642545, 0xf2f83aca,
                0xe3e023c3, 0xb1b83989, 0xb1b03181, 0x939c1f8f, 0x525c1e4e, 0xf1f839c9, 0xe2e426c6, 0xb2b03282,
                0x31303101, 0xe2e82aca, 0x616c2d4d, 0x535c1f4f, 0xe0e424c4, 0xf0f030c0, 0xc1cc0dcd, 0x80880888,
                0x12141606, 0x32383a0a, 0x50581848, 0xd0d414c4, 0x62602242, 0x21282909, 0x03040707, 0x33303303,
                0xe0e828c8, 0x13181b0b, 0x01040505, 0x71783949, 0x90901080, 0x62682a4a, 0x22282a0a, 0x92981a8a];

            _ss3 = [0x08303838, 0xc8e0e828, 0x0d212c2d, 0x86a2a426, 0xcfc3cc0f, 0xced2dc1e, 0x83b3b033, 0x88b0b838,
                0x8fa3ac2f, 0x40606020, 0x45515415, 0xc7c3c407, 0x44404404, 0x4f636c2f, 0x4b63682b, 0x4b53581b,
                0xc3c3c003, 0x42626022, 0x03333033, 0x85b1b435, 0x09212829, 0x80a0a020, 0xc2e2e022, 0x87a3a427,
                0xc3d3d013, 0x81919011, 0x01111011, 0x06020406, 0x0c101c1c, 0x8cb0bc3c, 0x06323436, 0x4b43480b,
                0xcfe3ec2f, 0x88808808, 0x4c606c2c, 0x88a0a828, 0x07131417, 0xc4c0c404, 0x06121416, 0xc4f0f434,
                0xc2c2c002, 0x45414405, 0xc1e1e021, 0xc6d2d416, 0x0f333c3f, 0x0d313c3d, 0x8e828c0e, 0x88909818,
                0x08202828, 0x4e424c0e, 0xc6f2f436, 0x0e323c3e, 0x85a1a425, 0xc9f1f839, 0x0d010c0d, 0xcfd3dc1f,
                0xc8d0d818, 0x0b23282b, 0x46626426, 0x4a72783a, 0x07232427, 0x0f232c2f, 0xc1f1f031, 0x42727032,
                0x42424002, 0xc4d0d414, 0x41414001, 0xc0c0c000, 0x43737033, 0x47636427, 0x8ca0ac2c, 0x8b83880b,
                0xc7f3f437, 0x8da1ac2d, 0x80808000, 0x0f131c1f, 0xcac2c80a, 0x0c202c2c, 0x8aa2a82a, 0x04303434,
                0xc2d2d012, 0x0b03080b, 0xcee2ec2e, 0xc9e1e829, 0x4d515c1d, 0x84909414, 0x08101818, 0xc8f0f838,
                0x47535417, 0x8ea2ac2e, 0x08000808, 0xc5c1c405, 0x03131013, 0xcdc1cc0d, 0x86828406, 0x89b1b839,
                0xcff3fc3f, 0x4d717c3d, 0xc1c1c001, 0x01313031, 0xc5f1f435, 0x8a82880a, 0x4a62682a, 0x81b1b031,
                0xc1d1d011, 0x00202020, 0xc7d3d417, 0x02020002, 0x02222022, 0x04000404, 0x48606828, 0x41717031,
                0x07030407, 0xcbd3d81b, 0x8d919c1d, 0x89919819, 0x41616021, 0x8eb2bc3e, 0xc6e2e426, 0x49515819,
                0xcdd1dc1d, 0x41515011, 0x80909010, 0xccd0dc1c, 0x8a92981a, 0x83a3a023, 0x8ba3a82b, 0xc0d0d010,
                0x81818001, 0x0f030c0f, 0x47434407, 0x0a12181a, 0xc3e3e023, 0xcce0ec2c, 0x8d818c0d, 0x8fb3bc3f,
                0x86929416, 0x4b73783b, 0x4c505c1c, 0x82a2a022, 0x81a1a021, 0x43636023, 0x03232023, 0x4d414c0d,
                0xc8c0c808, 0x8e929c1e, 0x8c909c1c, 0x0a32383a, 0x0c000c0c, 0x0e222c2e, 0x8ab2b83a, 0x4e626c2e,
                0x8f939c1f, 0x4a52581a, 0xc2f2f032, 0x82929012, 0xc3f3f033, 0x49414809, 0x48707838, 0xccc0cc0c,
                0x05111415, 0xcbf3f83b, 0x40707030, 0x45717435, 0x4f737c3f, 0x05313435, 0x00101010, 0x03030003,
                0x44606424, 0x4d616c2d, 0xc6c2c406, 0x44707434, 0xc5d1d415, 0x84b0b434, 0xcae2e82a, 0x09010809,
                0x46727436, 0x09111819, 0xcef2fc3e, 0x40404000, 0x02121012, 0xc0e0e020, 0x8db1bc3d, 0x05010405,
                0xcaf2f83a, 0x01010001, 0xc0f0f030, 0x0a22282a, 0x4e525c1e, 0x89a1a829, 0x46525416, 0x43434003,
                0x85818405, 0x04101414, 0x89818809, 0x8b93981b, 0x80b0b030, 0xc5e1e425, 0x48404808, 0x49717839,
                0x87939417, 0xccf0fc3c, 0x0e121c1e, 0x82828002, 0x01212021, 0x8c808c0c, 0x0b13181b, 0x4f535c1f,
                0x47737437, 0x44505414, 0x82b2b032, 0x0d111c1d, 0x05212425, 0x4f434c0f, 0x00000000, 0x46424406,
                0xcde1ec2d, 0x48505818, 0x42525012, 0xcbe3e82b, 0x4e727c3e, 0xcad2d81a, 0xc9c1c809, 0xcdf1fc3d,
                0x00303030, 0x85919415, 0x45616425, 0x0c303c3c, 0x86b2b436, 0xc4e0e424, 0x8bb3b83b, 0x4c707c3c,
                0x0e020c0e, 0x40505010, 0x09313839, 0x06222426, 0x02323032, 0x84808404, 0x49616829, 0x83939013,
                0x07333437, 0xc7e3e427, 0x04202424, 0x84a0a424, 0xcbc3c80b, 0x43535013, 0x0a02080a, 0x87838407,
                0xc9d1d819, 0x4c404c0c, 0x83838003, 0x8f838c0f, 0xcec2cc0e, 0x0b33383b, 0x4a42480a, 0x87b3b437];

        }

        var _kc = [0x9e3779b9, 0x3c6ef373, 0x78dde6e6, 0xf1bbcdcc, 0xe3779b99, 0xc6ef3733, 0x8dde6e67, 0x1bbcdccf,
            0x3779b99e, 0x6ef3733c, 0xdde6e678, 0xbbcdccf1, 0x779b99e3, 0xef3733c6, 0xde6e678d, 0xbcdccf1b];

        function _expandKey(key, decrypt) {
            var kcIndex = 0;
            var wCount = 0;
            var w = new Array(32);

            var T = key.slice(0);
            var T0 = T[0] + T[2] - _kc[kcIndex];
            var T1 = T[1] + _kc[kcIndex] - T[3];
            w[wCount++] = _getValue(T0);
            w[wCount++] = _getValue(T1);

            for (kcIndex = 1; kcIndex < _kc.length; ++kcIndex) {
                if (kcIndex & 0x00000001) {
                    _oddF(T);
                }
                else {
                    _evenF(T);
                }

                T0 = T[0] + T[2] - _kc[kcIndex];
                T1 = T[1] + _kc[kcIndex] - T[3];
                w[wCount++] = _getValue(T0);
                w[wCount++] = _getValue(T1);
            }

            return w;
        }

        function _oddF(T) {
            var tmp = T[0];
            T[0] = (T[0] >>> 8) ^ (T[1] << 24);
            T[1] = (T[1] >>> 8) ^ (tmp << 24);
        }

        function _evenF(T) {
            var tmp = T[2];
            T[2] = (T[2] << 8) ^ (T[3] >>> 24);
            T[3] = (T[3] << 8) ^ (tmp >>> 24);
        }

        function _getValue(T) {
            return _ss0[(T & 0x000000ff)] ^ _ss1[((T >>> 8) & 0x000000ff)] ^ _ss2[((T >>> 16) & 0x000000ff)] ^ _ss3[((T >>> 24) & 0x000000ff)];
        }

        function _subF(T) {
            T = _ss0[(T & 0x000000ff)] ^ _ss1[((T >>> 8) & 0x000000ff)] ^ _ss2[((T >>> 16) & 0x000000ff)] ^ _ss3[((T >>> 24) & 0x000000ff)];
            return T;
            //return ((T < 0) ? (T & 0x7fffffff) | (0x80000000) : (T));
        }

        function _updateBlock(w, input, output, decrypt) {
            var T = input.slice(0);

            var roundNumber = w.length / 2;
            var wIndex = 0;
            if (decrypt) {
                wIndex = w.length - 1;
            }

            var tmp0, tmp1, kc0, kc1, T0, T1;
            for (var round = 0; round < roundNumber; ++round) {
                if (decrypt) {
                    kc1 = w[wIndex--];
                    kc0 = w[wIndex--];
                }
                else {
                    kc0 = w[wIndex++];
                    kc1 = w[wIndex++];
                }

                if (round & 0x00000001) {
                    T0 = T[0] ^ kc0;
                    T1 = T[1] ^ kc1;
                }
                else {
                    T0 = T[2] ^ kc0;
                    T1 = T[3] ^ kc1;
                }

                T1 = _subF(T0 ^ T1);
                T0 = _subF(T0 + T1);
                T1 = _subF(T0 + T1);

                T0 += T1;

                if (round & 0x00000001) {
                    T[2] ^= T0;
                    T[3] ^= T1;
                }
                else {
                    T[0] ^= T0;
                    T[1] ^= T1;
                }
            }

            output[0] = T[2];
            output[1] = T[3];
            output[2] = T[0];
            output[3] = T[1];
        }

        function _createCipher(options) {
            options = options || {};
            var mode = (options.mode || 'CBC').toUpperCase();
            var algorithm = 'SEED-' + mode;

            var cipherObj;
            if (options.decrypt) {
                cipherObj = cipher.createDecipher(algorithm, options.key);
            } else {
                cipherObj = cipher.createCipher(algorithm, options.key);
            }

            // backwards compatible start API
            var start = cipherObj.start;
            cipherObj.start = function (iv, options) {
                // backwards compatibility: support second arg as output buffer
                var output = null;
                if (options instanceof util.ByteBuffer) {
                    output = options;
                    options = {};
                }
                options = options || {};
                options.output = output;
                options.iv = iv;
                start.call(cipherObj, options);
            };
            return cipherObj;
        }
    }


    function initSha256() {
        this.create = function () {
            // do initialization as necessary
            if (!_initialized) {
                _init();
            }

            // SHA-256 state contains eight 32-bit integers
            var _state = null;

            var _input = util.createBuffer();

            var _w = new Array(64);

            var md = {
                algorithm: 'sha256',
                blockLength: 64,
                digestLength: 32,
                // 56-bit length of message so far (does not including padding)
                messageLength: 0,
                // true 64-bit message length as two 32-bit ints
                messageLength64: [0, 0]
            };

            /**
             * Starts the digest.
             * @return this digest object.
             */
            md.start = function () {
                md.messageLength = 0;
                md.messageLength64 = [0, 0];
                _input = util.createBuffer();
                _state = {
                    h0: 0x6A09E667,
                    h1: 0xBB67AE85,
                    h2: 0x3C6EF372,
                    h3: 0xA54FF53A,
                    h4: 0x510E527F,
                    h5: 0x9B05688C,
                    h6: 0x1F83D9AB,
                    h7: 0x5BE0CD19
                };
                return md;
            };
            md.start();

            /**
             * Updates the digest with the given message input. The given input can
             * treated as raw input (no encoding will be applied) or an encoding of
             * 'utf8' maybe given to encode the input using UTF-8.
             *
             * @param msg the message input to update with.
             * @param encoding the encoding to use (default: 'raw', other: 'utf8').
             * @return this digest object.
             */
            md.update = function (msg, encoding) {
                if (encoding === 'utf8') {
                    msg = util.encodeUtf8(msg);
                }

                md.messageLength += msg.length;
                md.messageLength64[0] += (msg.length / 0x100000000) >>> 0;
                md.messageLength64[1] += msg.length >>> 0;

                _input.putBytes(msg);

                _update(_state, _w, _input);

                if (_input.read > 2048 || _input.length() === 0) {
                    _input.compact();
                }

                return md;
            };

            /**
             * Produces the digest.
             * @return a byte buffer containing the digest value.
             */
            md.digest = function () {
                var padBytes = util.createBuffer();
                padBytes.putBytes(_input.bytes());
                padBytes.putBytes(_padding.substr(0, 64 - ((md.messageLength64[1] + 8) & 0x3F)));
                padBytes.putInt32((md.messageLength64[0] << 3) | (md.messageLength64[0] >>> 28));
                padBytes.putInt32(md.messageLength64[1] << 3);
                var s2 = {
                    h0: _state.h0,
                    h1: _state.h1,
                    h2: _state.h2,
                    h3: _state.h3,
                    h4: _state.h4,
                    h5: _state.h5,
                    h6: _state.h6,
                    h7: _state.h7
                };
                _update(s2, _w, padBytes);
                var rval = util.createBuffer();
                rval.putInt32(s2.h0);
                rval.putInt32(s2.h1);
                rval.putInt32(s2.h2);
                rval.putInt32(s2.h3);
                rval.putInt32(s2.h4);
                rval.putInt32(s2.h5);
                rval.putInt32(s2.h6);
                rval.putInt32(s2.h7);
                return rval;
            };

            return md;
        };

        var _padding = null;
        var _initialized = false;

        var _k = null;

        function _init() {
            _padding = String.fromCharCode(128);
            _padding += util.fillString(String.fromCharCode(0x00), 64);

            _k = [
                0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
                0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
                0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
                0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
                0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
                0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
                0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
                0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
                0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
                0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
                0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
                0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
                0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
                0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];

            _initialized = true;
        }

        /**
         * Updates a SHA-256 state with the given byte buffer.
         * @param s the SHA-256 state to update.
         * @param w the array to use to store words.
         * @param bytes the byte buffer to update with.
         */
        function _update(s, w, bytes) {
            var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;
            var len = bytes.length();
            while (len >= 64) {
                for (i = 0; i < 16; ++i) {
                    w[i] = bytes.getInt32();
                }
                for (; i < 64; ++i) {
                    t1 = w[i - 2];
                    t1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);
                    t2 = w[i - 15];
                    t2 = ((t2 >>> 7) | (t2 << 25)) ^ ((t2 >>> 18) | (t2 << 14)) ^ (t2 >>> 3);
                    w[i] = (t1 + w[i - 7] + t2 + w[i - 16]) | 0;
                }

                a = s.h0;
                b = s.h1;
                c = s.h2;
                d = s.h3;
                e = s.h4;
                f = s.h5;
                g = s.h6;
                h = s.h7;

                for (i = 0; i < 64; ++i) {
                    s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));
                    ch = g ^ (e & (f ^ g));
                    s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));
                    maj = (a & b) | (c & (a ^ b));

                    t1 = h + s1 + ch + _k[i] + w[i];
                    t2 = s0 + maj;
                    h = g;
                    g = f;
                    f = e;
                    e = (d + t1) | 0;
                    d = c;
                    c = b;
                    b = a;
                    a = (t1 + t2) | 0;
                }

                s.h0 = (s.h0 + a) | 0;
                s.h1 = (s.h1 + b) | 0;
                s.h2 = (s.h2 + c) | 0;
                s.h3 = (s.h3 + d) | 0;
                s.h4 = (s.h4 + e) | 0;
                s.h5 = (s.h5 + f) | 0;
                s.h6 = (s.h6 + g) | 0;
                s.h7 = (s.h7 + h) | 0;
                len -= 64;
            }
        }
    }

    function initCipher() {
        // registered algorithms
        this.algorithms = this.algorithms || {};

        this.createCipher = function (algorithm, key) {
            var api = algorithm;
            if (typeof api === 'string') {
                api = this.getAlgorithm(api);
                if (api) {
                    api = api();
                }
            }
            if (!api) {
                throw new Error('Unsupported algorithm: ' + algorithm);
            }

            // assume block cipher
            return new this.BlockCipher({
                algorithm: api,
                key: key,
                decrypt: false
            });
        };

        this.createDecipher = function (algorithm, key) {
            var api = algorithm;
            if (typeof api === 'string') {
                api = this.getAlgorithm(api);
                if (api) {
                    api = api();
                }
            }
            if (!api) {
                throw new Error('Unsupported algorithm: ' + algorithm);
            }

            // assume block cipher
            return new this.BlockCipher({
                algorithm: api,
                key: key,
                decrypt: true
            });
        };

        this.registerAlgorithm = function (name, algorithm) {
            name = name.toUpperCase();
            this.algorithms[name] = algorithm;
        };

        this.getAlgorithm = function (name) {
            name = name.toUpperCase();
            if (name in this.algorithms) {
                return this.algorithms[name];
            }
            return null;
        };

        var BlockCipher = this.BlockCipher = function (options) {
            this.algorithm = options.algorithm;
            this.mode = this.algorithm.mode;
            this.blockSize = this.mode.blockSize;
            this._finish = false;
            this._input = null;
            this.output = null;
            this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
            this._decrypt = options.decrypt;
            this.algorithm.initialize(options);
        };

				var ASP_BlockCipher = this.ASP_BlockCipher = function (options) {
            this.algorithm = options.algorithm;
            this.mode = this.algorithm.mode;
            this.blockSize = this.mode.blockSize;
            this._finish = false;
            this._input = null;
            this.output = null;
            this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
            this._decrypt = options.decrypt;
            this.algorithm.initialize(options);
        };
        BlockCipher.prototype.start = function (options) {
            options = options || {};
            var opts = {};
            for (var key in options) {
                opts[key] = options[key];
            }
            opts.decrypt = this._decrypt;
            this._finish = false;
            this._input = util.createBuffer();
            this.output = options.output || util.createBuffer();
            this.mode.start(opts);
        };

        BlockCipher.prototype.update = function (input) {
            if (!this._finish) {
                // not finishing, so fill the input buffer with more input
                this._input.putBuffer(input);
            }

            // do cipher operation while input contains full blocks or if finishing
            while (this._input.length() >= this.blockSize ||
            (this._input.length() > 0 && this._finish)) {
                this._op.call(this.mode, this._input, this.output);
            }

            // free consumed memory from input buffer
            this._input.compact();
        };

        BlockCipher.prototype.finish = function (pad) {
            // backwards-compatibility w/deprecated padding API
            // Note: will overwrite padding functions even after another start() call
            if (pad && this.mode.name === 'CBC') {
                this.mode.pad = function (input) {
                    return pad(this.blockSize, input, false);
                };
                this.mode.unpad = function (output) {
                    return pad(this.blockSize, output, true);
                };
            }

            // build options for padding and afterFinish functions
            var options = {};
            options.decrypt = this._decrypt;

            // get # of bytes that won't fill a block
            options.overflow = this._input.length() % this.blockSize;

            if (!this._decrypt && this.mode.pad) {
                if (!this.mode.pad(this._input, options)) {
                    return false;
                }
            }

            // do final update
            this._finish = true;
            this.update();

            if (this._decrypt && this.mode.unpad) {
                if (!this.mode.unpad(this.output, options)) {
                    return false;
                }
            }

            if (this.mode.afterFinish) {
                if (!this.mode.afterFinish(this.output, options)) {
                    return false;
                }
            }

            return true;
        };
    }

    function initCipherModes() {
        /** Cipher-block Chaining (CBC) **/
        this.cbc = function (options) {
            options = options || {};
            this.name = 'CBC';
            this.cipher = options.cipher;
            this.blockSize = options.blockSize || 16;
            this._blocks = this.blockSize / 4;
            this._inBlock = new Array(this._blocks);
            this._outBlock = new Array(this._blocks);
        };

        this.cbc.prototype.start = function (options) {
            // Note: legacy support for using IV residue (has security flaws)
            // if IV is null, reuse block from previous processing
            if (options.iv === null) {
                // must have a previous block
                if (!this._prev) {
                    throw new Error('Invalid IV parameter.');
                }
                this._iv = this._prev.slice(0);
            } else if (!('iv' in options)) {
                throw new Error('Invalid IV parameter.');
            } else {
                // save IV as "previous" block
                this._iv = transformIV(options.iv);
                this._prev = this._iv.slice(0);
            }
        };

        this.cbc.prototype.encrypt = function (input, output) {
            // get next block
            // CBC XOR's IV (or previous block) with plaintext
            for (var i = 0; i < this._blocks; ++i) {
                this._inBlock[i] = this._prev[i] ^ input.getInt32();
            }

            // encrypt block
            this.cipher.encrypt(this._inBlock, this._outBlock);

            // write output, save previous block
            for (var i = 0; i < this._blocks; ++i) {
                output.putInt32(this._outBlock[i]);
            }
            this._prev = this._outBlock;
        };

        this.cbc.prototype.decrypt = function (input, output) {
            // get next block
            for (var i = 0; i < this._blocks; ++i) {
                this._inBlock[i] = input.getInt32();
            }

            // decrypt block
            this.cipher.decrypt(this._inBlock, this._outBlock);

            // write output, save previous ciphered block
            // CBC XOR's IV (or previous block) with ciphertext
            for (var i = 0; i < this._blocks; ++i) {
                output.putInt32(this._prev[i] ^ this._outBlock[i]);
            }
            this._prev = this._inBlock.slice(0);
        };

        this.cbc.prototype.pad = function (input, options) {
            // add PKCS#7 padding to block (each pad byte is the
            // value of the number of pad bytes)
            var padding = (input.length() === this.blockSize ?
                this.blockSize : (this.blockSize - input.length()));
            input.fillWithByte(padding, padding);
            return true;
        };

        this.cbc.prototype.unpad = function (output, options) {
            // check for error: input data not a multiple of blockSize
            if (options.overflow > 0) {
                return false;
            }

            // ensure padding byte count is valid
            var len = output.length();
            var count = output.at(len - 1);
            if (count > (this.blockSize << 2)) {
                return false;
            }

            // trim off padding bytes
            output.truncate(count);
            return true;
        };

        /** Utility functions */

        function transformIV(iv) {
            if (typeof iv === 'string') {
                // convert iv string into byte buffer
                iv = util.createBuffer(iv);
            }

            if (util.isArray(iv) && iv.length > 4) {
                // convert iv byte array into byte buffer
                var tmp = iv;
                iv = util.createBuffer();
                for (var i = 0; i < iv.length; ++i) {
                    iv.putByte(tmp[i]);
                }
            }
            if (!util.isArray(iv)) {
                // convert iv byte buffer into 32-bit integer array
                iv = [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()];
            }

            return iv;
        }

        function inc32(block) {
            // increment last 32 bits of block only
            block[block.length - 1] = (block[block.length - 1] + 1) & 0xFFFFFFFF;
        }

        function from64To32(num) {
            // convert 64-bit number to two BE Int32s
            return [(num / 0x100000000) | 0, num & 0xFFFFFFFF];
        }
    }

    function initUtil() {

        var deletedIds = [];

        var slice = deletedIds.slice;

        var concat = deletedIds.concat;

        var push = deletedIds.push;

        var indexOf = deletedIds.indexOf;

        var class2type = {};

        var toString = class2type.toString;

        var hasOwn = class2type.hasOwnProperty;

        var support = {};

        var version = "1.11.3";

        var jQuery = function( selector, context ) {
                return new jQuery.fn.init( selector, context );
            },

            rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

            rmsPrefix = /^-ms-/,
            rdashAlpha = /-([\da-z])/gi,

            fcamelCase = function( all, letter ) {
                return letter.toUpperCase();
            };

        jQuery.fn = jQuery.prototype = {
            jquery: version,

            constructor: jQuery,

            selector: "",

            length: 0,

            toArray: function() {
                return slice.call( this );
            },

            get: function( num ) {
                return num != null ?

                    ( num < 0 ? this[ num + this.length ] : this[ num ] ) :

                    slice.call( this );
            },

            pushStack: function( elems ) {

                var ret = jQuery.merge( this.constructor(), elems );

                ret.prevObject = this;
                ret.context = this.context;

                return ret;
            },

            each: function( callback, args ) {
                return jQuery.each( this, callback, args );
            },

            map: function( callback ) {
                return this.pushStack( jQuery.map(this, function( elem, i ) {
                    return callback.call( elem, i, elem );
                }));
            },

            slice: function() {
                return this.pushStack( slice.apply( this, arguments ) );
            },

            first: function() {
                return this.eq( 0 );
            },

            last: function() {
                return this.eq( -1 );
            },

            eq: function( i ) {
                var len = this.length,
                    j = +i + ( i < 0 ? len : 0 );
                return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
            },

            end: function() {
                return this.prevObject || this.constructor(null);
            },

            push: push,
            sort: deletedIds.sort,
            splice: deletedIds.splice
        };

        jQuery.extend = jQuery.fn.extend = function() {
            var src, copyIsArray, copy, name, options, clone,
                target = arguments[0] || {},
                i = 1,
                length = arguments.length,
                deep = false;

            if ( typeof target === "boolean" ) {
                deep = target;

                target = arguments[ i ] || {};
                i++;
            }

            if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
                target = {};
            }

            if ( i === length ) {
                target = this;
                i--;
            }

            for ( ; i < length; i++ ) {
                if ( (options = arguments[ i ]) != null ) {
                    for ( name in options ) {
                        src = target[ name ];
                        copy = options[ name ];

                        if ( target === copy ) {
                            continue;
                        }

                        if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                            if ( copyIsArray ) {
                                copyIsArray = false;
                                clone = src && jQuery.isArray(src) ? src : [];

                            } else {
                                clone = src && jQuery.isPlainObject(src) ? src : {};
                            }

                            target[ name ] = jQuery.extend( deep, clone, copy );

                        } else if ( copy !== undefined ) {
                            target[ name ] = copy;
                        }
                    }
                }
            }

            return target;
        };

        jQuery.extend({
            expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

            isReady: true,

            error: function( msg ) {
                throw new Error( msg );
            },

            noop: function() {},

            isFunction: function( obj ) {
                return jQuery.type(obj) === "function";
            },

            isArray: Array.isArray || function( obj ) {
                return jQuery.type(obj) === "array";
            },

            isWindow: function( obj ) {
                return obj != null && obj == obj.window;
            },

            isNumeric: function( obj ) {
                return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
            },

            isEmptyObject: function( obj ) {
                var name;
                for ( name in obj ) {
                    return false;
                }
                return true;
            },

            isPlainObject: function( obj ) {
                var key;

                if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
                    return false;
                }

                try {
                    if ( obj.constructor &&
                        !hasOwn.call(obj, "constructor") &&
                        !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
                        return false;
                    }
                } catch ( e ) {
                    return false;
                }

                if ( support.ownLast ) {
                    for ( key in obj ) {
                        return hasOwn.call( obj, key );
                    }
                }

                for ( key in obj ) {}

                return key === undefined || hasOwn.call( obj, key );
            },

            type: function( obj ) {
                if ( obj == null ) {
                    return obj + "";
                }
                return typeof obj === "object" || typeof obj === "function" ?
                    class2type[ toString.call(obj) ] || "object" :
                    typeof obj;
            },

            globalEval: function( data ) {
                if ( data && jQuery.trim( data ) ) {
                    ( window.execScript || function( data ) {
                        window[ "eval" ].call( window, data );
                    } )( data );
                }
            },

            camelCase: function( string ) {
                return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
            },

            nodeName: function( elem, name ) {
                return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
            },

            each: function( obj, callback, args ) {
                var value,
                    i = 0,
                    length = obj.length,
                    isArray = isArraylike( obj );

                if ( args ) {
                    if ( isArray ) {
                        for ( ; i < length; i++ ) {
                            value = callback.apply( obj[ i ], args );

                            if ( value === false ) {
                                break;
                            }
                        }
                    } else {
                        for ( i in obj ) {
                            value = callback.apply( obj[ i ], args );

                            if ( value === false ) {
                                break;
                            }
                        }
                    }

                } else {
                    if ( isArray ) {
                        for ( ; i < length; i++ ) {
                            value = callback.call( obj[ i ], i, obj[ i ] );

                            if ( value === false ) {
                                break;
                            }
                        }
                    } else {
                        for ( i in obj ) {
                            value = callback.call( obj[ i ], i, obj[ i ] );

                            if ( value === false ) {
                                break;
                            }
                        }
                    }
                }

                return obj;
            },

            trim: function( text ) {
                return text == null ?
                    "" :
                    ( text + "" ).replace( rtrim, "" );
            },

            makeArray: function( arr, results ) {
                var ret = results || [];

                if ( arr != null ) {
                    if ( isArraylike( Object(arr) ) ) {
                        jQuery.merge( ret,
                            typeof arr === "string" ?
                                [ arr ] : arr
                        );
                    } else {
                        push.call( ret, arr );
                    }
                }

                return ret;
            },

            inArray: function( elem, arr, i ) {
                var len;

                if ( arr ) {
                    if ( indexOf ) {
                        return indexOf.call( arr, elem, i );
                    }

                    len = arr.length;
                    i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

                    for ( ; i < len; i++ ) {
                        if ( i in arr && arr[ i ] === elem ) {
                            return i;
                        }
                    }
                }

                return -1;
            },

            merge: function( first, second ) {
                var len = +second.length,
                    j = 0,
                    i = first.length;

                while ( j < len ) {
                    first[ i++ ] = second[ j++ ];
                }

                if ( len !== len ) {
                    while ( second[j] !== undefined ) {
                        first[ i++ ] = second[ j++ ];
                    }
                }

                first.length = i;

                return first;
            },

            grep: function( elems, callback, invert ) {
                var callbackInverse,
                    matches = [],
                    i = 0,
                    length = elems.length,
                    callbackExpect = !invert;

                for ( ; i < length; i++ ) {
                    callbackInverse = !callback( elems[ i ], i );
                    if ( callbackInverse !== callbackExpect ) {
                        matches.push( elems[ i ] );
                    }
                }

                return matches;
            },

            map: function( elems, callback, arg ) {
                var value,
                    i = 0,
                    length = elems.length,
                    isArray = isArraylike( elems ),
                    ret = [];

                if ( isArray ) {
                    for ( ; i < length; i++ ) {
                        value = callback( elems[ i ], i, arg );

                        if ( value != null ) {
                            ret.push( value );
                        }
                    }

                } else {
                    for ( i in elems ) {
                        value = callback( elems[ i ], i, arg );

                        if ( value != null ) {
                            ret.push( value );
                        }
                    }
                }

                return concat.apply( [], ret );
            },

            guid: 1,

            proxy: function( fn, context ) {
                var args, proxy, tmp;

                if ( typeof context === "string" ) {
                    tmp = fn[ context ];
                    context = fn;
                    fn = tmp;
                }

                if ( !jQuery.isFunction( fn ) ) {
                    return undefined;
                }

                args = slice.call( arguments, 2 );
                proxy = function() {
                    return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
                };

                proxy.guid = fn.guid = fn.guid || jQuery.guid++;

                return proxy;
            },

            now: function() {
                return +( new Date() );
            },

            support: support
        });

        jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
            class2type[ "[object " + name + "]" ] = name.toLowerCase();
        });

        function isArraylike( obj ) {

            var length = "length" in obj && obj.length,
                type = jQuery.type( obj );

            if ( type === "function" || jQuery.isWindow( obj ) ) {
                return false;
            }

            if ( obj.nodeType === 1 && length ) {
                return true;
            }

            return type === "array" || length === 0 ||
                typeof length === "number" && length > 0 && ( length - 1 ) in obj;
        }
        var Sizzle =
            (function( window ) {

                var i,
                    support,
                    Expr,
                    getText,
                    isXML,
                    tokenize,
                    compile,
                    select,
                    outermostContext,
                    sortInput,
                    hasDuplicate,

                    setDocument,
                    document,
                    docElem,
                    documentIsHTML,
                    rbuggyQSA,
                    rbuggyMatches,
                    matches,
                    contains,

                    expando = "sizzle" + 1 * new Date(),
                    preferredDoc = window.document,
                    dirruns = 0,
                    done = 0,
                    classCache = createCache(),
                    tokenCache = createCache(),
                    compilerCache = createCache(),
                    sortOrder = function( a, b ) {
                        if ( a === b ) {
                            hasDuplicate = true;
                        }
                        return 0;
                    },

                    MAX_NEGATIVE = 1 << 31,

                    hasOwn = ({}).hasOwnProperty,
                    arr = [],
                    pop = arr.pop,
                    push_native = arr.push,
                    push = arr.push,
                    slice = arr.slice,
                    indexOf = function( list, elem ) {
                        var i = 0,
                            len = list.length;
                        for ( ; i < len; i++ ) {
                            if ( list[i] === elem ) {
                                return i;
                            }
                        }
                        return -1;
                    },

                    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

                    whitespace = "[\\x20\\t\\r\\n\\f]",
                    characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

                    identifier = characterEncoding.replace( "w", "w#" ),

                    attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
                        "*([*^$|!~]?=)" + whitespace +
                        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
                        "*\\]",

                    pseudos = ":(" + characterEncoding + ")(?:\\((" +
                        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
                        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
                        ".*" +
                        ")\\)|)",

                    rwhitespace = new RegExp( whitespace + "+", "g" ),
                    rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

                    rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
                    rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

                    rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

                    rpseudo = new RegExp( pseudos ),
                    ridentifier = new RegExp( "^" + identifier + "$" ),

                    matchExpr = {
                        "ID": new RegExp( "^#(" + characterEncoding + ")" ),
                        "CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
                        "TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
                        "ATTR": new RegExp( "^" + attributes ),
                        "PSEUDO": new RegExp( "^" + pseudos ),
                        "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                            "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                            "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
                        "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
                        "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                            whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
                    },

                    rinputs = /^(?:input|select|textarea|button)$/i,
                    rheader = /^h\d$/i,

                    rnative = /^[^{]+\{\s*\[native \w/,

                    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

                    rsibling = /[+~]/,
                    rescape = /'|\\/g,

                    runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
                    funescape = function( _, escaped, escapedWhitespace ) {
                        var high = "0x" + escaped - 0x10000;
                        return high !== high || escapedWhitespace ?
                            escaped :
                            high < 0 ?
                                String.fromCharCode( high + 0x10000 ) :
                                String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
                    },

                    unloadHandler = function() {
                        setDocument();
                    };

                try {
                    push.apply(
                        (arr = slice.call( preferredDoc.childNodes )),
                        preferredDoc.childNodes
                    );
                    arr[ preferredDoc.childNodes.length ].nodeType;
                } catch ( e ) {
                    push = { apply: arr.length ?

                        function( target, els ) {
                            push_native.apply( target, slice.call(els) );
                        } :

                        function( target, els ) {
                            var j = target.length,
                                i = 0;
                            while ( (target[j++] = els[i++]) ) {}
                            target.length = j - 1;
                        }
                    };
                }

                function Sizzle( selector, context, results, seed ) {
                    var match, elem, m, nodeType,
                        i, groups, old, nid, newContext, newSelector;

                    if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
                        setDocument( context );
                    }

                    context = context || document;
                    results = results || [];
                    nodeType = context.nodeType;

                    if ( typeof selector !== "string" || !selector ||
                        nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

                        return results;
                    }

                    if ( !seed && documentIsHTML ) {

                        if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
                            if ( (m = match[1]) ) {
                                if ( nodeType === 9 ) {
                                    elem = context.getElementById( m );
                                    if ( elem && elem.parentNode ) {
                                        if ( elem.id === m ) {
                                            results.push( elem );
                                            return results;
                                        }
                                    } else {
                                        return results;
                                    }
                                } else {
                                    if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
                                        contains( context, elem ) && elem.id === m ) {
                                        results.push( elem );
                                        return results;
                                    }
                                }

                            } else if ( match[2] ) {
                                push.apply( results, context.getElementsByTagName( selector ) );
                                return results;

                            } else if ( (m = match[3]) && support.getElementsByClassName ) {
                                push.apply( results, context.getElementsByClassName( m ) );
                                return results;
                            }
                        }

                        if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
                            nid = old = expando;
                            newContext = context;
                            newSelector = nodeType !== 1 && selector;

                            if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
                                groups = tokenize( selector );

                                if ( (old = context.getAttribute("id")) ) {
                                    nid = old.replace( rescape, "\\$&" );
                                } else {
                                    context.setAttribute( "id", nid );
                                }
                                nid = "[id='" + nid + "'] ";

                                i = groups.length;
                                while ( i-- ) {
                                    groups[i] = nid + toSelector( groups[i] );
                                }
                                newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
                                newSelector = groups.join(",");
                            }

                            if ( newSelector ) {
                                try {
                                    push.apply( results,
                                        newContext.querySelectorAll( newSelector )
                                    );
                                    return results;
                                } catch(qsaError) {
                                } finally {
                                    if ( !old ) {
                                        context.removeAttribute("id");
                                    }
                                }
                            }
                        }
                    }

                    return select( selector.replace( rtrim, "$1" ), context, results, seed );
                }
                function createCache() {
                    var keys = [];

                    function cache( key, value ) {
                        if ( keys.push( key + " " ) > Expr.cacheLength ) {
                            delete cache[ keys.shift() ];
                        }
                        return (cache[ key + " " ] = value);
                    }
                    return cache;
                }

                function markFunction( fn ) {
                    fn[ expando ] = true;
                    return fn;
                }

                function assert( fn ) {
                    var div = document.createElement("div");

                    try {
                        return !!fn( div );
                    } catch (e) {
                        return false;
                    } finally {
                        if ( div.parentNode ) {
                            div.parentNode.removeChild( div );
                        }
                        div = null;
                    }
                }

                function addHandle( attrs, handler ) {
                    var arr = attrs.split("|"),
                        i = attrs.length;

                    while ( i-- ) {
                        Expr.attrHandle[ arr[i] ] = handler;
                    }
                }

                function siblingCheck( a, b ) {
                    var cur = b && a,
                        diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                            ( ~b.sourceIndex || MAX_NEGATIVE ) -
                            ( ~a.sourceIndex || MAX_NEGATIVE );

                    if ( diff ) {
                        return diff;
                    }

                    if ( cur ) {
                        while ( (cur = cur.nextSibling) ) {
                            if ( cur === b ) {
                                return -1;
                            }
                        }
                    }

                    return a ? 1 : -1;
                }

                function createInputPseudo( type ) {
                    return function( elem ) {
                        var name = elem.nodeName.toLowerCase();
                        return name === "input" && elem.type === type;
                    };
                }

                function createButtonPseudo( type ) {
                    return function( elem ) {
                        var name = elem.nodeName.toLowerCase();
                        return (name === "input" || name === "button") && elem.type === type;
                    };
                }

                function createPositionalPseudo( fn ) {
                    return markFunction(function( argument ) {
                        argument = +argument;
                        return markFunction(function( seed, matches ) {
                            var j,
                                matchIndexes = fn( [], seed.length, argument ),
                                i = matchIndexes.length;

                            while ( i-- ) {
                                if ( seed[ (j = matchIndexes[i]) ] ) {
                                    seed[j] = !(matches[j] = seed[j]);
                                }
                            }
                        });
                    });
                }

                function testContext( context ) {
                    return context && typeof context.getElementsByTagName !== "undefined" && context;
                }

                support = Sizzle.support = {};

                isXML = Sizzle.isXML = function( elem ) {
                    var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                    return documentElement ? documentElement.nodeName !== "HTML" : false;
                };

                setDocument = Sizzle.setDocument = function( node ) {
                    var hasCompare, parent,
                        doc = node ? node.ownerDocument || node : preferredDoc;

                    if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
                        return document;
                    }

                    document = doc;
                    docElem = doc.documentElement;
                    parent = doc.defaultView;

                    if ( parent && parent !== parent.top ) {
                        if ( parent.addEventListener ) {
                            parent.addEventListener( "unload", unloadHandler, false );
                        } else if ( parent.attachEvent ) {
                            parent.attachEvent( "onunload", unloadHandler );
                        }
                    }

                    documentIsHTML = !isXML( doc );

                    support.attributes = assert(function( div ) {
                        div.className = "i";
                        return !div.getAttribute("className");
                    });

                    support.getElementsByTagName = assert(function( div ) {
                        div.appendChild( doc.createComment("") );
                        return !div.getElementsByTagName("*").length;
                    });

                    support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

                    support.getById = assert(function( div ) {
                        docElem.appendChild( div ).id = expando;
                        return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
                    });

                    if ( support.getById ) {
                        Expr.find["ID"] = function( id, context ) {
                            if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
                                var m = context.getElementById( id );
                                return m && m.parentNode ? [ m ] : [];
                            }
                        };
                        Expr.filter["ID"] = function( id ) {
                            var attrId = id.replace( runescape, funescape );
                            return function( elem ) {
                                return elem.getAttribute("id") === attrId;
                            };
                        };
                    } else {
                        delete Expr.find["ID"];

                        Expr.filter["ID"] =  function( id ) {
                            var attrId = id.replace( runescape, funescape );
                            return function( elem ) {
                                var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                                return node && node.value === attrId;
                            };
                        };
                    }

                    Expr.find["TAG"] = support.getElementsByTagName ?
                        function( tag, context ) {
                            if ( typeof context.getElementsByTagName !== "undefined" ) {
                                return context.getElementsByTagName( tag );

                            } else if ( support.qsa ) {
                                return context.querySelectorAll( tag );
                            }
                        } :

                        function( tag, context ) {
                            var elem,
                                tmp = [],
                                i = 0,
                                results = context.getElementsByTagName( tag );

                            if ( tag === "*" ) {
                                while ( (elem = results[i++]) ) {
                                    if ( elem.nodeType === 1 ) {
                                        tmp.push( elem );
                                    }
                                }

                                return tmp;
                            }
                            return results;
                        };

                    Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
                            if ( documentIsHTML ) {
                                return context.getElementsByClassName( className );
                            }
                        };

                    rbuggyMatches = [];

                    rbuggyQSA = [];

                    if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
                        assert(function( div ) {
                            docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
                                "<select id='" + expando + "-\f]' msallowcapture=''>" +
                                "<option selected=''></option></select>";

                            if ( div.querySelectorAll("[msallowcapture^='']").length ) {
                                rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
                            }

                            if ( !div.querySelectorAll("[selected]").length ) {
                                rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
                            }

                            if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
                                rbuggyQSA.push("~=");
                            }

                            if ( !div.querySelectorAll(":checked").length ) {
                                rbuggyQSA.push(":checked");
                            }

                            if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
                                rbuggyQSA.push(".#.+[+~]");
                            }
                        });

                        assert(function( div ) {
                            var input = doc.createElement("input");
                            input.setAttribute( "type", "hidden" );
                            div.appendChild( input ).setAttribute( "name", "D" );

                            if ( div.querySelectorAll("[name=d]").length ) {
                                rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
                            }

                            if ( !div.querySelectorAll(":enabled").length ) {
                                rbuggyQSA.push( ":enabled", ":disabled" );
                            }

                            div.querySelectorAll("*,:x");
                            rbuggyQSA.push(",.*:");
                        });
                    }

                    if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
                            docElem.webkitMatchesSelector ||
                            docElem.mozMatchesSelector ||
                            docElem.oMatchesSelector ||
                            docElem.msMatchesSelector) )) ) {

                        assert(function( div ) {
                            support.disconnectedMatch = matches.call( div, "div" );

                            matches.call( div, "[s!='']:x" );
                            rbuggyMatches.push( "!=", pseudos );
                        });
                    }

                    rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
                    rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

                    hasCompare = rnative.test( docElem.compareDocumentPosition );

                    contains = hasCompare || rnative.test( docElem.contains ) ?
                        function( a, b ) {
                            var adown = a.nodeType === 9 ? a.documentElement : a,
                                bup = b && b.parentNode;
                            return a === bup || !!( bup && bup.nodeType === 1 && (
                                    adown.contains ?
                                        adown.contains( bup ) :
                                        a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
                                ));
                        } :
                        function( a, b ) {
                            if ( b ) {
                                while ( (b = b.parentNode) ) {
                                    if ( b === a ) {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        };

                    sortOrder = hasCompare ?
                        function( a, b ) {

                            if ( a === b ) {
                                hasDuplicate = true;
                                return 0;
                            }

                            var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                            if ( compare ) {
                                return compare;
                            }

                            compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
                                a.compareDocumentPosition( b ) :

                                1;

                            if ( compare & 1 ||
                                (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

                                if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
                                    return -1;
                                }
                                if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
                                    return 1;
                                }

                                return sortInput ?
                                    ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                                    0;
                            }

                            return compare & 4 ? -1 : 1;
                        } :
                        function( a, b ) {
                            if ( a === b ) {
                                hasDuplicate = true;
                                return 0;
                            }

                            var cur,
                                i = 0,
                                aup = a.parentNode,
                                bup = b.parentNode,
                                ap = [ a ],
                                bp = [ b ];

                            if ( !aup || !bup ) {
                                return a === doc ? -1 :
                                    b === doc ? 1 :
                                        aup ? -1 :
                                            bup ? 1 :
                                                sortInput ?
                                                    ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                                                    0;

                            } else if ( aup === bup ) {
                                return siblingCheck( a, b );
                            }

                            cur = a;
                            while ( (cur = cur.parentNode) ) {
                                ap.unshift( cur );
                            }
                            cur = b;
                            while ( (cur = cur.parentNode) ) {
                                bp.unshift( cur );
                            }

                            while ( ap[i] === bp[i] ) {
                                i++;
                            }

                            return i ?
                                siblingCheck( ap[i], bp[i] ) :

                                ap[i] === preferredDoc ? -1 :
                                    bp[i] === preferredDoc ? 1 :
                                        0;
                        };

                    return doc;
                };

                Sizzle.matches = function( expr, elements ) {
                    return Sizzle( expr, null, null, elements );
                };

                Sizzle.matchesSelector = function( elem, expr ) {
                    if ( ( elem.ownerDocument || elem ) !== document ) {
                        setDocument( elem );
                    }

                    expr = expr.replace( rattributeQuotes, "='$1']" );

                    if ( support.matchesSelector && documentIsHTML &&
                        ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
                        ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

                        try {
                            var ret = matches.call( elem, expr );

                            if ( ret || support.disconnectedMatch ||
                                elem.document && elem.document.nodeType !== 11 ) {
                                return ret;
                            }
                        } catch (e) {}
                    }

                    return Sizzle( expr, document, null, [ elem ] ).length > 0;
                };

                Sizzle.contains = function( context, elem ) {
                    if ( ( context.ownerDocument || context ) !== document ) {
                        setDocument( context );
                    }
                    return contains( context, elem );
                };

                Sizzle.attr = function( elem, name ) {
                    if ( ( elem.ownerDocument || elem ) !== document ) {
                        setDocument( elem );
                    }

                    var fn = Expr.attrHandle[ name.toLowerCase() ],
                        val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
                            fn( elem, name, !documentIsHTML ) :
                            undefined;

                    return val !== undefined ?
                        val :
                        support.attributes || !documentIsHTML ?
                            elem.getAttribute( name ) :
                            (val = elem.getAttributeNode(name)) && val.specified ?
                                val.value :
                                null;
                };

                Sizzle.error = function( msg ) {
                    throw new Error( "Syntax error, unrecognized expression: " + msg );
                };

                Sizzle.uniqueSort = function( results ) {
                    var elem,
                        duplicates = [],
                        j = 0,
                        i = 0;

                    hasDuplicate = !support.detectDuplicates;
                    sortInput = !support.sortStable && results.slice( 0 );
                    results.sort( sortOrder );

                    if ( hasDuplicate ) {
                        while ( (elem = results[i++]) ) {
                            if ( elem === results[ i ] ) {
                                j = duplicates.push( i );
                            }
                        }
                        while ( j-- ) {
                            results.splice( duplicates[ j ], 1 );
                        }
                    }

                    sortInput = null;

                    return results;
                };

                getText = Sizzle.getText = function( elem ) {
                    var node,
                        ret = "",
                        i = 0,
                        nodeType = elem.nodeType;

                    if ( !nodeType ) {
                        while ( (node = elem[i++]) ) {
                            ret += getText( node );
                        }
                    } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
                        if ( typeof elem.textContent === "string" ) {
                            return elem.textContent;
                        } else {
                            for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                                ret += getText( elem );
                            }
                        }
                    } else if ( nodeType === 3 || nodeType === 4 ) {
                        return elem.nodeValue;
                    }

                    return ret;
                };

                Expr = Sizzle.selectors = {

                    cacheLength: 50,

                    createPseudo: markFunction,

                    match: matchExpr,

                    attrHandle: {},

                    find: {},

                    relative: {
                        ">": { dir: "parentNode", first: true },
                        " ": { dir: "parentNode" },
                        "+": { dir: "previousSibling", first: true },
                        "~": { dir: "previousSibling" }
                    },

                    preFilter: {
                        "ATTR": function( match ) {
                            match[1] = match[1].replace( runescape, funescape );

                            match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

                            if ( match[2] === "~=" ) {
                                match[3] = " " + match[3] + " ";
                            }

                            return match.slice( 0, 4 );
                        },

                        "CHILD": function( match ) {
                            match[1] = match[1].toLowerCase();

                            if ( match[1].slice( 0, 3 ) === "nth" ) {
                                if ( !match[3] ) {
                                    Sizzle.error( match[0] );
                                }

                                match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
                                match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

                            } else if ( match[3] ) {
                                Sizzle.error( match[0] );
                            }

                            return match;
                        },

                        "PSEUDO": function( match ) {
                            var excess,
                                unquoted = !match[6] && match[2];

                            if ( matchExpr["CHILD"].test( match[0] ) ) {
                                return null;
                            }

                            if ( match[3] ) {
                                match[2] = match[4] || match[5] || "";

                            } else if ( unquoted && rpseudo.test( unquoted ) &&
                                (excess = tokenize( unquoted, true )) &&
                                (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

                                match[0] = match[0].slice( 0, excess );
                                match[2] = unquoted.slice( 0, excess );
                            }

                            return match.slice( 0, 3 );
                        }
                    },

                    filter: {

                        "TAG": function( nodeNameSelector ) {
                            var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
                            return nodeNameSelector === "*" ?
                                function() { return true; } :
                                function( elem ) {
                                    return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                                };
                        },

                        "CLASS": function( className ) {
                            var pattern = classCache[ className + " " ];

                            return pattern ||
                                (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
                                classCache( className, function( elem ) {
                                    return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
                                });
                        },

                        "ATTR": function( name, operator, check ) {
                            return function( elem ) {
                                var result = Sizzle.attr( elem, name );

                                if ( result == null ) {
                                    return operator === "!=";
                                }
                                if ( !operator ) {
                                    return true;
                                }

                                result += "";

                                return operator === "=" ? result === check :
                                    operator === "!=" ? result !== check :
                                        operator === "^=" ? check && result.indexOf( check ) === 0 :
                                            operator === "*=" ? check && result.indexOf( check ) > -1 :
                                                operator === "$=" ? check && result.slice( -check.length ) === check :
                                                    operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
                                                        operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
                                                            false;
                            };
                        },

                        "CHILD": function( type, what, argument, first, last ) {
                            var simple = type.slice( 0, 3 ) !== "nth",
                                forward = type.slice( -4 ) !== "last",
                                ofType = what === "of-type";

                            return first === 1 && last === 0 ?

                                function( elem ) {
                                    return !!elem.parentNode;
                                } :

                                function( elem, context, xml ) {
                                    var cache, outerCache, node, diff, nodeIndex, start,
                                        dir = simple !== forward ? "nextSibling" : "previousSibling",
                                        parent = elem.parentNode,
                                        name = ofType && elem.nodeName.toLowerCase(),
                                        useCache = !xml && !ofType;

                                    if ( parent ) {

                                        if ( simple ) {
                                            while ( dir ) {
                                                node = elem;
                                                while ( (node = node[ dir ]) ) {
                                                    if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
                                                        return false;
                                                    }
                                                }
                                                start = dir = type === "only" && !start && "nextSibling";
                                            }
                                            return true;
                                        }

                                        start = [ forward ? parent.firstChild : parent.lastChild ];

                                        if ( forward && useCache ) {
                                            outerCache = parent[ expando ] || (parent[ expando ] = {});
                                            cache = outerCache[ type ] || [];
                                            nodeIndex = cache[0] === dirruns && cache[1];
                                            diff = cache[0] === dirruns && cache[2];
                                            node = nodeIndex && parent.childNodes[ nodeIndex ];

                                            while ( (node = ++nodeIndex && node && node[ dir ] ||

                                                (diff = nodeIndex = 0) || start.pop()) ) {

                                                if ( node.nodeType === 1 && ++diff && node === elem ) {
                                                    outerCache[ type ] = [ dirruns, nodeIndex, diff ];
                                                    break;
                                                }
                                            }

                                        } else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
                                            diff = cache[1];

                                        } else {
                                            while ( (node = ++nodeIndex && node && node[ dir ] ||
                                                (diff = nodeIndex = 0) || start.pop()) ) {

                                                if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
                                                    if ( useCache ) {
                                                        (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
                                                    }

                                                    if ( node === elem ) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }

                                        diff -= last;
                                        return diff === first || ( diff % first === 0 && diff / first >= 0 );
                                    }
                                };
                        },

                        "PSEUDO": function( pseudo, argument ) {
                            var args,
                                fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                                    Sizzle.error( "unsupported pseudo: " + pseudo );

                            if ( fn[ expando ] ) {
                                return fn( argument );
                            }

                            if ( fn.length > 1 ) {
                                args = [ pseudo, pseudo, "", argument ];
                                return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                                    markFunction(function( seed, matches ) {
                                        var idx,
                                            matched = fn( seed, argument ),
                                            i = matched.length;
                                        while ( i-- ) {
                                            idx = indexOf( seed, matched[i] );
                                            seed[ idx ] = !( matches[ idx ] = matched[i] );
                                        }
                                    }) :
                                    function( elem ) {
                                        return fn( elem, 0, args );
                                    };
                            }

                            return fn;
                        }
                    },

                    pseudos: {
                        "not": markFunction(function( selector ) {
                            var input = [],
                                results = [],
                                matcher = compile( selector.replace( rtrim, "$1" ) );

                            return matcher[ expando ] ?
                                markFunction(function( seed, matches, context, xml ) {
                                    var elem,
                                        unmatched = matcher( seed, null, xml, [] ),
                                        i = seed.length;

                                    while ( i-- ) {
                                        if ( (elem = unmatched[i]) ) {
                                            seed[i] = !(matches[i] = elem);
                                        }
                                    }
                                }) :
                                function( elem, context, xml ) {
                                    input[0] = elem;
                                    matcher( input, null, xml, results );
                                    input[0] = null;
                                    return !results.pop();
                                };
                        }),

                        "has": markFunction(function( selector ) {
                            return function( elem ) {
                                return Sizzle( selector, elem ).length > 0;
                            };
                        }),

                        "contains": markFunction(function( text ) {
                            text = text.replace( runescape, funescape );
                            return function( elem ) {
                                return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
                            };
                        }),

                        "lang": markFunction( function( lang ) {
                            if ( !ridentifier.test(lang || "") ) {
                                Sizzle.error( "unsupported lang: " + lang );
                            }
                            lang = lang.replace( runescape, funescape ).toLowerCase();
                            return function( elem ) {
                                var elemLang;
                                do {
                                    if ( (elemLang = documentIsHTML ?
                                            elem.lang :
                                            elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

                                        elemLang = elemLang.toLowerCase();
                                        return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
                                    }
                                } while ( (elem = elem.parentNode) && elem.nodeType === 1 );
                                return false;
                            };
                        }),

                        "target": function( elem ) {
                            var hash = window.location && window.location.hash;
                            return hash && hash.slice( 1 ) === elem.id;
                        },

                        "root": function( elem ) {
                            return elem === docElem;
                        },

                        "focus": function( elem ) {
                            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                        },

                        "enabled": function( elem ) {
                            return elem.disabled === false;
                        },

                        "disabled": function( elem ) {
                            return elem.disabled === true;
                        },

                        "checked": function( elem ) {
                            var nodeName = elem.nodeName.toLowerCase();
                            return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                        },

                        "selected": function( elem ) {
                            if ( elem.parentNode ) {
                                elem.parentNode.selectedIndex;
                            }

                            return elem.selected === true;
                        },

                        "empty": function( elem ) {
                            for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                                if ( elem.nodeType < 6 ) {
                                    return false;
                                }
                            }
                            return true;
                        },

                        "parent": function( elem ) {
                            return !Expr.pseudos["empty"]( elem );
                        },

                        "header": function( elem ) {
                            return rheader.test( elem.nodeName );
                        },

                        "input": function( elem ) {
                            return rinputs.test( elem.nodeName );
                        },

                        "button": function( elem ) {
                            var name = elem.nodeName.toLowerCase();
                            return name === "input" && elem.type === "button" || name === "button";
                        },

                        "text": function( elem ) {
                            var attr;
                            return elem.nodeName.toLowerCase() === "input" &&
                                elem.type === "text" &&

                                ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
                        },

                        "first": createPositionalPseudo(function() {
                            return [ 0 ];
                        }),

                        "last": createPositionalPseudo(function( matchIndexes, length ) {
                            return [ length - 1 ];
                        }),

                        "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
                            return [ argument < 0 ? argument + length : argument ];
                        }),

                        "even": createPositionalPseudo(function( matchIndexes, length ) {
                            var i = 0;
                            for ( ; i < length; i += 2 ) {
                                matchIndexes.push( i );
                            }
                            return matchIndexes;
                        }),

                        "odd": createPositionalPseudo(function( matchIndexes, length ) {
                            var i = 1;
                            for ( ; i < length; i += 2 ) {
                                matchIndexes.push( i );
                            }
                            return matchIndexes;
                        }),

                        "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                            var i = argument < 0 ? argument + length : argument;
                            for ( ; --i >= 0; ) {
                                matchIndexes.push( i );
                            }
                            return matchIndexes;
                        }),

                        "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                            var i = argument < 0 ? argument + length : argument;
                            for ( ; ++i < length; ) {
                                matchIndexes.push( i );
                            }
                            return matchIndexes;
                        })
                    }
                };

                Expr.pseudos["nth"] = Expr.pseudos["eq"];

                for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
                    Expr.pseudos[ i ] = createInputPseudo( i );
                }
                for ( i in { submit: true, reset: true } ) {
                    Expr.pseudos[ i ] = createButtonPseudo( i );
                }

                function setFilters() {}
                setFilters.prototype = Expr.filters = Expr.pseudos;
                Expr.setFilters = new setFilters();

                tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
                    var matched, match, tokens, type,
                        soFar, groups, preFilters,
                        cached = tokenCache[ selector + " " ];

                    if ( cached ) {
                        return parseOnly ? 0 : cached.slice( 0 );
                    }

                    soFar = selector;
                    groups = [];
                    preFilters = Expr.preFilter;

                    while ( soFar ) {

                        if ( !matched || (match = rcomma.exec( soFar )) ) {
                            if ( match ) {
                                soFar = soFar.slice( match[0].length ) || soFar;
                            }
                            groups.push( (tokens = []) );
                        }

                        matched = false;

                        if ( (match = rcombinators.exec( soFar )) ) {
                            matched = match.shift();
                            tokens.push({
                                value: matched,
                                type: match[0].replace( rtrim, " " )
                            });
                            soFar = soFar.slice( matched.length );
                        }

                        for ( type in Expr.filter ) {
                            if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
                                (match = preFilters[ type ]( match ))) ) {
                                matched = match.shift();
                                tokens.push({
                                    value: matched,
                                    type: type,
                                    matches: match
                                });
                                soFar = soFar.slice( matched.length );
                            }
                        }

                        if ( !matched ) {
                            break;
                        }
                    }

                    return parseOnly ?
                        soFar.length :
                        soFar ?
                            Sizzle.error( selector ) :
                            tokenCache( selector, groups ).slice( 0 );
                };

                function toSelector( tokens ) {
                    var i = 0,
                        len = tokens.length,
                        selector = "";
                    for ( ; i < len; i++ ) {
                        selector += tokens[i].value;
                    }
                    return selector;
                }

                function addCombinator( matcher, combinator, base ) {
                    var dir = combinator.dir,
                        checkNonElements = base && dir === "parentNode",
                        doneName = done++;

                    return combinator.first ?
                        function( elem, context, xml ) {
                            while ( (elem = elem[ dir ]) ) {
                                if ( elem.nodeType === 1 || checkNonElements ) {
                                    return matcher( elem, context, xml );
                                }
                            }
                        } :

                        function( elem, context, xml ) {
                            var oldCache, outerCache,
                                newCache = [ dirruns, doneName ];

                            if ( xml ) {
                                while ( (elem = elem[ dir ]) ) {
                                    if ( elem.nodeType === 1 || checkNonElements ) {
                                        if ( matcher( elem, context, xml ) ) {
                                            return true;
                                        }
                                    }
                                }
                            } else {
                                while ( (elem = elem[ dir ]) ) {
                                    if ( elem.nodeType === 1 || checkNonElements ) {
                                        outerCache = elem[ expando ] || (elem[ expando ] = {});
                                        if ( (oldCache = outerCache[ dir ]) &&
                                            oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

                                            return (newCache[ 2 ] = oldCache[ 2 ]);
                                        } else {
                                            outerCache[ dir ] = newCache;

                                            if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                                                return true;
                                            }
                                        }
                                    }
                                }
                            }
                        };
                }

                function elementMatcher( matchers ) {
                    return matchers.length > 1 ?
                        function( elem, context, xml ) {
                            var i = matchers.length;
                            while ( i-- ) {
                                if ( !matchers[i]( elem, context, xml ) ) {
                                    return false;
                                }
                            }
                            return true;
                        } :
                        matchers[0];
                }

                function multipleContexts( selector, contexts, results ) {
                    var i = 0,
                        len = contexts.length;
                    for ( ; i < len; i++ ) {
                        Sizzle( selector, contexts[i], results );
                    }
                    return results;
                }

                function condense( unmatched, map, filter, context, xml ) {
                    var elem,
                        newUnmatched = [],
                        i = 0,
                        len = unmatched.length,
                        mapped = map != null;

                    for ( ; i < len; i++ ) {
                        if ( (elem = unmatched[i]) ) {
                            if ( !filter || filter( elem, context, xml ) ) {
                                newUnmatched.push( elem );
                                if ( mapped ) {
                                    map.push( i );
                                }
                            }
                        }
                    }

                    return newUnmatched;
                }

                function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
                    if ( postFilter && !postFilter[ expando ] ) {
                        postFilter = setMatcher( postFilter );
                    }
                    if ( postFinder && !postFinder[ expando ] ) {
                        postFinder = setMatcher( postFinder, postSelector );
                    }
                    return markFunction(function( seed, results, context, xml ) {
                        var temp, i, elem,
                            preMap = [],
                            postMap = [],
                            preexisting = results.length,

                            elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

                            matcherIn = preFilter && ( seed || !selector ) ?
                                condense( elems, preMap, preFilter, context, xml ) :
                                elems,

                            matcherOut = matcher ?
                                postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                                    [] :

                                    results :
                                matcherIn;

                        if ( matcher ) {
                            matcher( matcherIn, matcherOut, context, xml );
                        }

                        if ( postFilter ) {
                            temp = condense( matcherOut, postMap );
                            postFilter( temp, [], context, xml );

                            i = temp.length;
                            while ( i-- ) {
                                if ( (elem = temp[i]) ) {
                                    matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                                }
                            }
                        }

                        if ( seed ) {
                            if ( postFinder || preFilter ) {
                                if ( postFinder ) {
                                    temp = [];
                                    i = matcherOut.length;
                                    while ( i-- ) {
                                        if ( (elem = matcherOut[i]) ) {
                                            temp.push( (matcherIn[i] = elem) );
                                        }
                                    }
                                    postFinder( null, (matcherOut = []), temp, xml );
                                }

                                i = matcherOut.length;
                                while ( i-- ) {
                                    if ( (elem = matcherOut[i]) &&
                                        (temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

                                        seed[temp] = !(results[temp] = elem);
                                    }
                                }
                            }

                        } else {
                            matcherOut = condense(
                                matcherOut === results ?
                                    matcherOut.splice( preexisting, matcherOut.length ) :
                                    matcherOut
                            );
                            if ( postFinder ) {
                                postFinder( null, results, matcherOut, xml );
                            } else {
                                push.apply( results, matcherOut );
                            }
                        }
                    });
                }

                function matcherFromTokens( tokens ) {
                    var checkContext, matcher, j,
                        len = tokens.length,
                        leadingRelative = Expr.relative[ tokens[0].type ],
                        implicitRelative = leadingRelative || Expr.relative[" "],
                        i = leadingRelative ? 1 : 0,

                        matchContext = addCombinator( function( elem ) {
                            return elem === checkContext;
                        }, implicitRelative, true ),
                        matchAnyContext = addCombinator( function( elem ) {
                            return indexOf( checkContext, elem ) > -1;
                        }, implicitRelative, true ),
                        matchers = [ function( elem, context, xml ) {
                            var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                                    (checkContext = context).nodeType ?
                                        matchContext( elem, context, xml ) :
                                        matchAnyContext( elem, context, xml ) );
                            checkContext = null;
                            return ret;
                        } ];

                    for ( ; i < len; i++ ) {
                        if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
                            matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
                        } else {
                            matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

                            if ( matcher[ expando ] ) {
                                j = ++i;
                                for ( ; j < len; j++ ) {
                                    if ( Expr.relative[ tokens[j].type ] ) {
                                        break;
                                    }
                                }
                                return setMatcher(
                                    i > 1 && elementMatcher( matchers ),
                                    i > 1 && toSelector(
                                        tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
                                    ).replace( rtrim, "$1" ),
                                    matcher,
                                    i < j && matcherFromTokens( tokens.slice( i, j ) ),
                                    j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
                                    j < len && toSelector( tokens )
                                );
                            }
                            matchers.push( matcher );
                        }
                    }

                    return elementMatcher( matchers );
                }

                function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
                    var bySet = setMatchers.length > 0,
                        byElement = elementMatchers.length > 0,
                        superMatcher = function( seed, context, xml, results, outermost ) {
                            var elem, j, matcher,
                                matchedCount = 0,
                                i = "0",
                                unmatched = seed && [],
                                setMatched = [],
                                contextBackup = outermostContext,
                                elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
                                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                                len = elems.length;

                            if ( outermost ) {
                                outermostContext = context !== document && context;
                            }
                            for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
                                if ( byElement && elem ) {
                                    j = 0;
                                    while ( (matcher = elementMatchers[j++]) ) {
                                        if ( matcher( elem, context, xml ) ) {
                                            results.push( elem );
                                            break;
                                        }
                                    }
                                    if ( outermost ) {
                                        dirruns = dirrunsUnique;
                                    }
                                }

                                if ( bySet ) {
                                    if ( (elem = !matcher && elem) ) {
                                        matchedCount--;
                                    }

                                    if ( seed ) {
                                        unmatched.push( elem );
                                    }
                                }
                            }

                            matchedCount += i;
                            if ( bySet && i !== matchedCount ) {
                                j = 0;
                                while ( (matcher = setMatchers[j++]) ) {
                                    matcher( unmatched, setMatched, context, xml );
                                }

                                if ( seed ) {
                                    if ( matchedCount > 0 ) {
                                        while ( i-- ) {
                                            if ( !(unmatched[i] || setMatched[i]) ) {
                                                setMatched[i] = pop.call( results );
                                            }
                                        }
                                    }

                                    setMatched = condense( setMatched );
                                }

                                push.apply( results, setMatched );

                                if ( outermost && !seed && setMatched.length > 0 &&
                                    ( matchedCount + setMatchers.length ) > 1 ) {

                                    Sizzle.uniqueSort( results );
                                }
                            }

                            if ( outermost ) {
                                dirruns = dirrunsUnique;
                                outermostContext = contextBackup;
                            }

                            return unmatched;
                        };

                    return bySet ?
                        markFunction( superMatcher ) :
                        superMatcher;
                }

                compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
                    var i,
                        setMatchers = [],
                        elementMatchers = [],
                        cached = compilerCache[ selector + " " ];

                    if ( !cached ) {
                        if ( !match ) {
                            match = tokenize( selector );
                        }
                        i = match.length;
                        while ( i-- ) {
                            cached = matcherFromTokens( match[i] );
                            if ( cached[ expando ] ) {
                                setMatchers.push( cached );
                            } else {
                                elementMatchers.push( cached );
                            }
                        }

                        cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

                        cached.selector = selector;
                    }
                    return cached;
                };

                select = Sizzle.select = function( selector, context, results, seed ) {
                    var i, tokens, token, type, find,
                        compiled = typeof selector === "function" && selector,
                        match = !seed && tokenize( (selector = compiled.selector || selector) );

                    results = results || [];

                    if ( match.length === 1 ) {

                        tokens = match[0] = match[0].slice( 0 );
                        if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                            support.getById && context.nodeType === 9 && documentIsHTML &&
                            Expr.relative[ tokens[1].type ] ) {

                            context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
                            if ( !context ) {
                                return results;

                            } else if ( compiled ) {
                                context = context.parentNode;
                            }

                            selector = selector.slice( tokens.shift().value.length );
                        }

                        i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
                        while ( i-- ) {
                            token = tokens[i];

                            if ( Expr.relative[ (type = token.type) ] ) {
                                break;
                            }
                            if ( (find = Expr.find[ type ]) ) {
                                if ( (seed = find(
                                        token.matches[0].replace( runescape, funescape ),
                                        rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
                                    )) ) {

                                    tokens.splice( i, 1 );
                                    selector = seed.length && toSelector( tokens );
                                    if ( !selector ) {
                                        push.apply( results, seed );
                                        return results;
                                    }

                                    break;
                                }
                            }
                        }
                    }

                    ( compiled || compile( selector, match ) )(
                        seed,
                        context,
                        !documentIsHTML,
                        results,
                        rsibling.test( selector ) && testContext( context.parentNode ) || context
                    );
                    return results;
                };

                support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

                support.detectDuplicates = !!hasDuplicate;

                setDocument();

                support.sortDetached = assert(function( div1 ) {
                    return div1.compareDocumentPosition( document.createElement("div") ) & 1;
                });

                if ( !assert(function( div ) {
                        div.innerHTML = "<a href='#'></a>";
                        return div.firstChild.getAttribute("href") === "#" ;
                    }) ) {
                    addHandle( "type|href|height|width", function( elem, name, isXML ) {
                        if ( !isXML ) {
                            return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
                        }
                    });
                }

                if ( !support.attributes || !assert(function( div ) {
                        div.innerHTML = "<input/>";
                        div.firstChild.setAttribute( "value", "" );
                        return div.firstChild.getAttribute( "value" ) === "";
                    }) ) {
                    addHandle( "value", function( elem, name, isXML ) {
                        if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
                            return elem.defaultValue;
                        }
                    });
                }

                if ( !assert(function( div ) {
                        return div.getAttribute("disabled") == null;
                    }) ) {
                    addHandle( booleans, function( elem, name, isXML ) {
                        var val;
                        if ( !isXML ) {
                            return elem[ name ] === true ? name.toLowerCase() :
                                (val = elem.getAttributeNode( name )) && val.specified ?
                                    val.value :
                                    null;
                        }
                    });
                }

                return Sizzle;

            })( window );



        jQuery.find = Sizzle;
        jQuery.expr = Sizzle.selectors;
        jQuery.expr[":"] = jQuery.expr.pseudos;
        jQuery.unique = Sizzle.uniqueSort;
        jQuery.text = Sizzle.getText;
        jQuery.isXMLDoc = Sizzle.isXML;
        jQuery.contains = Sizzle.contains;



        var rneedsContext = jQuery.expr.match.needsContext;

        var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



        var risSimple = /^.[^:#\[\.,]*$/;

        function winnow( elements, qualifier, not ) {
            if ( jQuery.isFunction( qualifier ) ) {
                return jQuery.grep( elements, function( elem, i ) {
                    /* jshint -W018 */
                    return !!qualifier.call( elem, i, elem ) !== not;
                });

            }

            if ( qualifier.nodeType ) {
                return jQuery.grep( elements, function( elem ) {
                    return ( elem === qualifier ) !== not;
                });

            }

            if ( typeof qualifier === "string" ) {
                if ( risSimple.test( qualifier ) ) {
                    return jQuery.filter( qualifier, elements, not );
                }

                qualifier = jQuery.filter( qualifier, elements );
            }

            return jQuery.grep( elements, function( elem ) {
                return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;
            });
        }

        jQuery.filter = function( expr, elems, not ) {
            var elem = elems[ 0 ];

            if ( not ) {
                expr = ":not(" + expr + ")";
            }

            return elems.length === 1 && elem.nodeType === 1 ?
                jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
                jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
                    return elem.nodeType === 1;
                }));
        };

        jQuery.fn.extend({
            find: function( selector ) {
                var i,
                    ret = [],
                    self = this,
                    len = self.length;

                if ( typeof selector !== "string" ) {
                    return this.pushStack( jQuery( selector ).filter(function() {
                        for ( i = 0; i < len; i++ ) {
                            if ( jQuery.contains( self[ i ], this ) ) {
                                return true;
                            }
                        }
                    }) );
                }

                for ( i = 0; i < len; i++ ) {
                    jQuery.find( selector, self[ i ], ret );
                }

                ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
                ret.selector = this.selector ? this.selector + " " + selector : selector;
                return ret;
            },
            filter: function( selector ) {
                return this.pushStack( winnow(this, selector || [], false) );
            },
            not: function( selector ) {
                return this.pushStack( winnow(this, selector || [], true) );
            },
            is: function( selector ) {
                return !!winnow(
                    this,

                    typeof selector === "string" && rneedsContext.test( selector ) ?
                        jQuery( selector ) :
                        selector || [],
                    false
                ).length;
            }
        });


        var rootjQuery,

            document = window.document,

            rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

            init = jQuery.fn.init = function( selector, context ) {
                var match, elem;

                if ( !selector ) {
                    return this;
                }

                if ( typeof selector === "string" ) {
                    if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
                        match = [ null, selector, null ];

                    } else {
                        match = rquickExpr.exec( selector );
                    }

                    if ( match && (match[1] || !context) ) {

                        if ( match[1] ) {
                            context = context instanceof jQuery ? context[0] : context;

                            jQuery.merge( this, jQuery.parseHTML(
                                match[1],
                                context && context.nodeType ? context.ownerDocument || context : document,
                                true
                            ) );

                            if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
                                for ( match in context ) {
                                    if ( jQuery.isFunction( this[ match ] ) ) {
                                        this[ match ]( context[ match ] );

                                    } else {
                                        this.attr( match, context[ match ] );
                                    }
                                }
                            }

                            return this;

                        } else {
                            elem = document.getElementById( match[2] );

                            if ( elem && elem.parentNode ) {
                                if ( elem.id !== match[2] ) {
                                    return rootjQuery.find( selector );
                                }

                                this.length = 1;
                                this[0] = elem;
                            }

                            this.context = document;
                            this.selector = selector;
                            return this;
                        }

                    } else if ( !context || context.jquery ) {
                        return ( context || rootjQuery ).find( selector );

                    } else {
                        return this.constructor( context ).find( selector );
                    }

                } else if ( selector.nodeType ) {
                    this.context = this[0] = selector;
                    this.length = 1;
                    return this;

                } else if ( jQuery.isFunction( selector ) ) {
                    return typeof rootjQuery.ready !== "undefined" ?
                        rootjQuery.ready( selector ) :
                        selector( jQuery );
                }

                if ( selector.selector !== undefined ) {
                    this.selector = selector.selector;
                    this.context = selector.context;
                }

                return jQuery.makeArray( selector, this );
            };

        init.prototype = jQuery.fn;

        rootjQuery = jQuery( document );


        var rparentsprev = /^(?:parents|prev(?:Until|All))/,
            guaranteedUnique = {
                children: true,
                contents: true,
                next: true,
                prev: true
            };

        jQuery.extend({
            dir: function( elem, dir, until ) {
                var matched = [],
                    cur = elem[ dir ];

                while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
                    if ( cur.nodeType === 1 ) {
                        matched.push( cur );
                    }
                    cur = cur[dir];
                }
                return matched;
            },

            sibling: function( n, elem ) {
                var r = [];

                for ( ; n; n = n.nextSibling ) {
                    if ( n.nodeType === 1 && n !== elem ) {
                        r.push( n );
                    }
                }

                return r;
            }
        });

        jQuery.fn.extend({
            has: function( target ) {
                var i,
                    targets = jQuery( target, this ),
                    len = targets.length;

                return this.filter(function() {
                    for ( i = 0; i < len; i++ ) {
                        if ( jQuery.contains( this, targets[i] ) ) {
                            return true;
                        }
                    }
                });
            },

            closest: function( selectors, context ) {
                var cur,
                    i = 0,
                    l = this.length,
                    matched = [],
                    pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
                        jQuery( selectors, context || this.context ) :
                        0;

                for ( ; i < l; i++ ) {
                    for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
                        if ( cur.nodeType < 11 && (pos ?
                                pos.index(cur) > -1 :

                                cur.nodeType === 1 &&
                                jQuery.find.matchesSelector(cur, selectors)) ) {

                            matched.push( cur );
                            break;
                        }
                    }
                }

                return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
            },

            index: function( elem ) {

                if ( !elem ) {
                    return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
                }

                if ( typeof elem === "string" ) {
                    return jQuery.inArray( this[0], jQuery( elem ) );
                }

                return jQuery.inArray(
                    elem.jquery ? elem[0] : elem, this );
            },

            add: function( selector, context ) {
                return this.pushStack(
                    jQuery.unique(
                        jQuery.merge( this.get(), jQuery( selector, context ) )
                    )
                );
            },

            addBack: function( selector ) {
                return this.add( selector == null ?
                    this.prevObject : this.prevObject.filter(selector)
                );
            }
        });

        function sibling( cur, dir ) {
            do {
                cur = cur[ dir ];
            } while ( cur && cur.nodeType !== 1 );

            return cur;
        }

        jQuery.each({
            parent: function( elem ) {
                var parent = elem.parentNode;
                return parent && parent.nodeType !== 11 ? parent : null;
            },
            parents: function( elem ) {
                return jQuery.dir( elem, "parentNode" );
            },
            parentsUntil: function( elem, i, until ) {
                return jQuery.dir( elem, "parentNode", until );
            },
            next: function( elem ) {
                return sibling( elem, "nextSibling" );
            },
            prev: function( elem ) {
                return sibling( elem, "previousSibling" );
            },
            nextAll: function( elem ) {
                return jQuery.dir( elem, "nextSibling" );
            },
            prevAll: function( elem ) {
                return jQuery.dir( elem, "previousSibling" );
            },
            nextUntil: function( elem, i, until ) {
                return jQuery.dir( elem, "nextSibling", until );
            },
            prevUntil: function( elem, i, until ) {
                return jQuery.dir( elem, "previousSibling", until );
            },
            siblings: function( elem ) {
                return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
            },
            children: function( elem ) {
                return jQuery.sibling( elem.firstChild );
            },
            contents: function( elem ) {
                return jQuery.nodeName( elem, "iframe" ) ?
                    elem.contentDocument || elem.contentWindow.document :
                    jQuery.merge( [], elem.childNodes );
            }
        }, function( name, fn ) {
            jQuery.fn[ name ] = function( until, selector ) {
                var ret = jQuery.map( this, fn, until );

                if ( name.slice( -5 ) !== "Until" ) {
                    selector = until;
                }

                if ( selector && typeof selector === "string" ) {
                    ret = jQuery.filter( selector, ret );
                }

                if ( this.length > 1 ) {
                    if ( !guaranteedUnique[ name ] ) {
                        ret = jQuery.unique( ret );
                    }

                    if ( rparentsprev.test( name ) ) {
                        ret = ret.reverse();
                    }
                }

                return this.pushStack( ret );
            };
        });
        var rnotwhite = (/\S+/g);

        var optionsCache = {};

        function createOptions( options ) {
            var object = optionsCache[ options ] = {};
            jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
                object[ flag ] = true;
            });
            return object;
        }

        jQuery.Callbacks = function( options ) {

            options = typeof options === "string" ?
                ( optionsCache[ options ] || createOptions( options ) ) :
                jQuery.extend( {}, options );

            var firing,
                memory,
                fired,
                firingLength,
                firingIndex,
                firingStart,
                list = [],
                stack = !options.once && [],
                fire = function( data ) {
                    memory = options.memory && data;
                    fired = true;
                    firingIndex = firingStart || 0;
                    firingStart = 0;
                    firingLength = list.length;
                    firing = true;
                    for ( ; list && firingIndex < firingLength; firingIndex++ ) {
                        if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
                            memory = false;
                            break;
                        }
                    }
                    firing = false;
                    if ( list ) {
                        if ( stack ) {
                            if ( stack.length ) {
                                fire( stack.shift() );
                            }
                        } else if ( memory ) {
                            list = [];
                        } else {
                            self.disable();
                        }
                    }
                },
                self = {
                    add: function() {
                        if ( list ) {
                            var start = list.length;
                            (function add( args ) {
                                jQuery.each( args, function( _, arg ) {
                                    var type = jQuery.type( arg );
                                    if ( type === "function" ) {
                                        if ( !options.unique || !self.has( arg ) ) {
                                            list.push( arg );
                                        }
                                    } else if ( arg && arg.length && type !== "string" ) {
                                        add( arg );
                                    }
                                });
                            })( arguments );
                            if ( firing ) {
                                firingLength = list.length;
                            } else if ( memory ) {
                                firingStart = start;
                                fire( memory );
                            }
                        }
                        return this;
                    },
                    remove: function() {
                        if ( list ) {
                            jQuery.each( arguments, function( _, arg ) {
                                var index;
                                while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
                                    list.splice( index, 1 );
                                    if ( firing ) {
                                        if ( index <= firingLength ) {
                                            firingLength--;
                                        }
                                        if ( index <= firingIndex ) {
                                            firingIndex--;
                                        }
                                    }
                                }
                            });
                        }
                        return this;
                    },
                    has: function( fn ) {
                        return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
                    },
                    empty: function() {
                        list = [];
                        firingLength = 0;
                        return this;
                    },
                    disable: function() {
                        list = stack = memory = undefined;
                        return this;
                    },
                    disabled: function() {
                        return !list;
                    },
                    lock: function() {
                        stack = undefined;
                        if ( !memory ) {
                            self.disable();
                        }
                        return this;
                    },
                    locked: function() {
                        return !stack;
                    },
                    fireWith: function( context, args ) {
                        if ( list && ( !fired || stack ) ) {
                            args = args || [];
                            args = [ context, args.slice ? args.slice() : args ];
                            if ( firing ) {
                                stack.push( args );
                            } else {
                                fire( args );
                            }
                        }
                        return this;
                    },
                    fire: function() {
                        self.fireWith( this, arguments );
                        return this;
                    },
                    fired: function() {
                        return !!fired;
                    }
                };

            return self;
        };


        jQuery.extend({

            Deferred: function( func ) {
                var tuples = [
                        [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
                        [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
                        [ "notify", "progress", jQuery.Callbacks("memory") ]
                    ],
                    state = "pending",
                    promise = {
                        state: function() {
                            return state;
                        },
                        always: function() {
                            deferred.done( arguments ).fail( arguments );
                            return this;
                        },
                        then: function( /* fnDone, fnFail, fnProgress */ ) {
                            var fns = arguments;
                            return jQuery.Deferred(function( newDefer ) {
                                jQuery.each( tuples, function( i, tuple ) {
                                    var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
                                    deferred[ tuple[1] ](function() {
                                        var returned = fn && fn.apply( this, arguments );
                                        if ( returned && jQuery.isFunction( returned.promise ) ) {
                                            returned.promise()
                                                .done( newDefer.resolve )
                                                .fail( newDefer.reject )
                                                .progress( newDefer.notify );
                                        } else {
                                            newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
                                        }
                                    });
                                });
                                fns = null;
                            }).promise();
                        },
                        promise: function( obj ) {
                            return obj != null ? jQuery.extend( obj, promise ) : promise;
                        }
                    },
                    deferred = {};

                promise.pipe = promise.then;

                jQuery.each( tuples, function( i, tuple ) {
                    var list = tuple[ 2 ],
                        stateString = tuple[ 3 ];

                    promise[ tuple[1] ] = list.add;

                    if ( stateString ) {
                        list.add(function() {
                            state = stateString;

                        }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
                    }

                    deferred[ tuple[0] ] = function() {
                        deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
                        return this;
                    };
                    deferred[ tuple[0] + "With" ] = list.fireWith;
                });

                promise.promise( deferred );

                if ( func ) {
                    func.call( deferred, deferred );
                }

                return deferred;
            },

            when: function( subordinate /* , ..., subordinateN */ ) {
                var i = 0,
                    resolveValues = slice.call( arguments ),
                    length = resolveValues.length,

                    remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

                    deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

                    updateFunc = function( i, contexts, values ) {
                        return function( value ) {
                            contexts[ i ] = this;
                            values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                            if ( values === progressValues ) {
                                deferred.notifyWith( contexts, values );

                            } else if ( !(--remaining) ) {
                                deferred.resolveWith( contexts, values );
                            }
                        };
                    },

                    progressValues, progressContexts, resolveContexts;

                if ( length > 1 ) {
                    progressValues = new Array( length );
                    progressContexts = new Array( length );
                    resolveContexts = new Array( length );
                    for ( ; i < length; i++ ) {
                        if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                            resolveValues[ i ].promise()
                                .done( updateFunc( i, resolveContexts, resolveValues ) )
                                .fail( deferred.reject )
                                .progress( updateFunc( i, progressContexts, progressValues ) );
                        } else {
                            --remaining;
                        }
                    }
                }

                if ( !remaining ) {
                    deferred.resolveWith( resolveContexts, resolveValues );
                }

                return deferred.promise();
            }
        });


        var readyList;

        jQuery.fn.ready = function( fn ) {
            jQuery.ready.promise().done( fn );

            return this;
        };

        jQuery.extend({
            isReady: false,

            readyWait: 1,

            holdReady: function( hold ) {
                if ( hold ) {
                    jQuery.readyWait++;
                } else {
                    jQuery.ready( true );
                }
            },

            ready: function( wait ) {

                if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
                    return;
                }

                if ( !document.body ) {
                    return setTimeout( jQuery.ready );
                }

                jQuery.isReady = true;

                if ( wait !== true && --jQuery.readyWait > 0 ) {
                    return;
                }

                readyList.resolveWith( document, [ jQuery ] );

                if ( jQuery.fn.triggerHandler ) {
                    jQuery( document ).triggerHandler( "ready" );
                    jQuery( document ).off( "ready" );
                }
            }
        });

        function detach() {
            if ( document.addEventListener ) {
                document.removeEventListener( "DOMContentLoaded", completed, false );
                window.removeEventListener( "load", completed, false );

            } else {
                document.detachEvent( "onreadystatechange", completed );
                window.detachEvent( "onload", completed );
            }
        }

        function completed() {
            if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
                detach();
                jQuery.ready();
            }
        }

        jQuery.ready.promise = function( obj ) {
            if ( !readyList ) {

                readyList = jQuery.Deferred();

                if ( document.readyState === "complete" ) {
                    setTimeout( jQuery.ready );

                } else if ( document.addEventListener ) {
                    document.addEventListener( "DOMContentLoaded", completed, false );

                    window.addEventListener( "load", completed, false );

                } else {
                    document.attachEvent( "onreadystatechange", completed );

                    window.attachEvent( "onload", completed );

                    var top = false;

                    try {
                        top = window.frameElement == null && document.documentElement;
                    } catch(e) {}

                    if ( top && top.doScroll ) {
                        (function doScrollCheck() {
                            if ( !jQuery.isReady ) {

                                try {
                                    top.doScroll("left");
                                } catch(e) {
                                    return setTimeout( doScrollCheck, 50 );
                                }

                                detach();

                                jQuery.ready();
                            }
                        })();
                    }
                }
            }
            return readyList.promise( obj );
        };


        var strundefined = typeof undefined;

        var i;
        for ( i in jQuery( support ) ) {
            break;
        }
        support.ownLast = i !== "0";

        support.inlineBlockNeedsLayout = false;

        jQuery(function() {
            var val, div, body, container;

            body = document.getElementsByTagName( "body" )[ 0 ];
            if ( !body || !body.style ) {
                return;
            }

            div = document.createElement( "div" );
            container = document.createElement( "div" );
            container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
            body.appendChild( container ).appendChild( div );

            if ( typeof div.style.zoom !== strundefined ) {
                div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";

                support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
                if ( val ) {
                    body.style.zoom = 1;
                }
            }

            body.removeChild( container );
        });




        (function() {
            var div = document.createElement( "div" );

            if (support.deleteExpando == null) {
                support.deleteExpando = true;
                try {
                    delete div.test;
                } catch( e ) {
                    support.deleteExpando = false;
                }
            }

            div = null;
        })();


        jQuery.acceptData = function( elem ) {
            var noData = jQuery.noData[ (elem.nodeName + " ").toLowerCase() ],
                nodeType = +elem.nodeType || 1;

            return nodeType !== 1 && nodeType !== 9 ?
                false :

                !noData || noData !== true && elem.getAttribute("classid") === noData;
        };


        var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
            rmultiDash = /([A-Z])/g;

        function dataAttr( elem, key, data ) {
            if ( data === undefined && elem.nodeType === 1 ) {

                var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

                data = elem.getAttribute( name );

                if ( typeof data === "string" ) {
                    try {
                        data = data === "true" ? true :
                            data === "false" ? false :
                                data === "null" ? null :
                                    +data + "" === data ? +data :
                                        rbrace.test( data ) ? jQuery.parseJSON( data ) :
                                            data;
                    } catch( e ) {}

                    jQuery.data( elem, key, data );

                } else {
                    data = undefined;
                }
            }

            return data;
        }

        function isEmptyDataObject( obj ) {
            var name;
            for ( name in obj ) {

                if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
                    continue;
                }
                if ( name !== "toJSON" ) {
                    return false;
                }
            }

            return true;
        }

        function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
            if ( !jQuery.acceptData( elem ) ) {
                return;
            }

            var ret, thisCache,
                internalKey = jQuery.expando,

                isNode = elem.nodeType,

                cache = isNode ? jQuery.cache : elem,

                id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

            if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {
                return;
            }

            if ( !id ) {
                if ( isNode ) {
                    id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
                } else {
                    id = internalKey;
                }
            }

            if ( !cache[ id ] ) {
                cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
            }

            if ( typeof name === "object" || typeof name === "function" ) {
                if ( pvt ) {
                    cache[ id ] = jQuery.extend( cache[ id ], name );
                } else {
                    cache[ id ].data = jQuery.extend( cache[ id ].data, name );
                }
            }

            thisCache = cache[ id ];

            if ( !pvt ) {
                if ( !thisCache.data ) {
                    thisCache.data = {};
                }

                thisCache = thisCache.data;
            }

            if ( data !== undefined ) {
                thisCache[ jQuery.camelCase( name ) ] = data;
            }

            if ( typeof name === "string" ) {

                ret = thisCache[ name ];

                if ( ret == null ) {

                    ret = thisCache[ jQuery.camelCase( name ) ];
                }
            } else {
                ret = thisCache;
            }

            return ret;
        }

        function internalRemoveData( elem, name, pvt ) {
            if ( !jQuery.acceptData( elem ) ) {
                return;
            }

            var thisCache, i,
                isNode = elem.nodeType,

                cache = isNode ? jQuery.cache : elem,
                id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

            if ( !cache[ id ] ) {
                return;
            }

            if ( name ) {

                thisCache = pvt ? cache[ id ] : cache[ id ].data;

                if ( thisCache ) {

                    if ( !jQuery.isArray( name ) ) {

                        if ( name in thisCache ) {
                            name = [ name ];
                        } else {

                            name = jQuery.camelCase( name );
                            if ( name in thisCache ) {
                                name = [ name ];
                            } else {
                                name = name.split(" ");
                            }
                        }
                    } else {
                        name = name.concat( jQuery.map( name, jQuery.camelCase ) );
                    }

                    i = name.length;
                    while ( i-- ) {
                        delete thisCache[ name[i] ];
                    }
                    if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
                        return;
                    }
                }
            }

            if ( !pvt ) {
                delete cache[ id ].data;

                if ( !isEmptyDataObject( cache[ id ] ) ) {
                    return;
                }
            }

            if ( isNode ) {
                jQuery.cleanData( [ elem ], true );

            } else if ( support.deleteExpando || cache != cache.window ) {
                delete cache[ id ];

            } else {
                cache[ id ] = null;
            }
        }

        jQuery.extend({
            cache: {},
            noData: {
                "applet ": true,
                "embed ": true,
                "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
            },

            hasData: function( elem ) {
                elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
                return !!elem && !isEmptyDataObject( elem );
            },

            data: function( elem, name, data ) {
                return internalData( elem, name, data );
            },

            removeData: function( elem, name ) {
                return internalRemoveData( elem, name );
            },

            _data: function( elem, name, data ) {
                return internalData( elem, name, data, true );
            },

            _removeData: function( elem, name ) {
                return internalRemoveData( elem, name, true );
            }
        });

        jQuery.fn.extend({
            data: function( key, value ) {
                var i, name, data,
                    elem = this[0],
                    attrs = elem && elem.attributes;

                if ( key === undefined ) {
                    if ( this.length ) {
                        data = jQuery.data( elem );

                        if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
                            i = attrs.length;
                            while ( i-- ) {

                                if ( attrs[ i ] ) {
                                    name = attrs[ i ].name;
                                    if ( name.indexOf( "data-" ) === 0 ) {
                                        name = jQuery.camelCase( name.slice(5) );
                                        dataAttr( elem, name, data[ name ] );
                                    }
                                }
                            }
                            jQuery._data( elem, "parsedAttrs", true );
                        }
                    }

                    return data;
                }

                if ( typeof key === "object" ) {
                    return this.each(function() {
                        jQuery.data( this, key );
                    });
                }

                return arguments.length > 1 ?

                    // Sets one value
                    this.each(function() {
                        jQuery.data( this, key, value );
                    }) :

                    elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
            },

            removeData: function( key ) {
                return this.each(function() {
                    jQuery.removeData( this, key );
                });
            }
        });


        jQuery.extend({
            queue: function( elem, type, data ) {
                var queue;

                if ( elem ) {
                    type = ( type || "fx" ) + "queue";
                    queue = jQuery._data( elem, type );

                    if ( data ) {
                        if ( !queue || jQuery.isArray(data) ) {
                            queue = jQuery._data( elem, type, jQuery.makeArray(data) );
                        } else {
                            queue.push( data );
                        }
                    }
                    return queue || [];
                }
            },

            dequeue: function( elem, type ) {
                type = type || "fx";

                var queue = jQuery.queue( elem, type ),
                    startLength = queue.length,
                    fn = queue.shift(),
                    hooks = jQuery._queueHooks( elem, type ),
                    next = function() {
                        jQuery.dequeue( elem, type );
                    };

                if ( fn === "inprogress" ) {
                    fn = queue.shift();
                    startLength--;
                }

                if ( fn ) {

                    if ( type === "fx" ) {
                        queue.unshift( "inprogress" );
                    }

                    delete hooks.stop;
                    fn.call( elem, next, hooks );
                }

                if ( !startLength && hooks ) {
                    hooks.empty.fire();
                }
            },

            _queueHooks: function( elem, type ) {
                var key = type + "queueHooks";
                return jQuery._data( elem, key ) || jQuery._data( elem, key, {
                        empty: jQuery.Callbacks("once memory").add(function() {
                            jQuery._removeData( elem, type + "queue" );
                            jQuery._removeData( elem, key );
                        })
                    });
            }
        });

        jQuery.fn.extend({
            queue: function( type, data ) {
                var setter = 2;

                if ( typeof type !== "string" ) {
                    data = type;
                    type = "fx";
                    setter--;
                }

                if ( arguments.length < setter ) {
                    return jQuery.queue( this[0], type );
                }

                return data === undefined ?
                    this :
                    this.each(function() {
                        var queue = jQuery.queue( this, type, data );

                        jQuery._queueHooks( this, type );

                        if ( type === "fx" && queue[0] !== "inprogress" ) {
                            jQuery.dequeue( this, type );
                        }
                    });
            },
            dequeue: function( type ) {
                return this.each(function() {
                    jQuery.dequeue( this, type );
                });
            },
            clearQueue: function( type ) {
                return this.queue( type || "fx", [] );
            },
            promise: function( type, obj ) {
                var tmp,
                    count = 1,
                    defer = jQuery.Deferred(),
                    elements = this,
                    i = this.length,
                    resolve = function() {
                        if ( !( --count ) ) {
                            defer.resolveWith( elements, [ elements ] );
                        }
                    };

                if ( typeof type !== "string" ) {
                    obj = type;
                    type = undefined;
                }
                type = type || "fx";

                while ( i-- ) {
                    tmp = jQuery._data( elements[ i ], type + "queueHooks" );
                    if ( tmp && tmp.empty ) {
                        count++;
                        tmp.empty.add( resolve );
                    }
                }
                resolve();
                return defer.promise( obj );
            }
        });
        var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

        var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

        var isHidden = function( elem, el ) {
            elem = el || elem;
            return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
        };

        var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
            var i = 0,
                length = elems.length,
                bulk = key == null;

            if ( jQuery.type( key ) === "object" ) {
                chainable = true;
                for ( i in key ) {
                    jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
                }

            } else if ( value !== undefined ) {
                chainable = true;

                if ( !jQuery.isFunction( value ) ) {
                    raw = true;
                }

                if ( bulk ) {
                    if ( raw ) {
                        fn.call( elems, value );
                        fn = null;

                    } else {
                        bulk = fn;
                        fn = function( elem, key, value ) {
                            return bulk.call( jQuery( elem ), value );
                        };
                    }
                }

                if ( fn ) {
                    for ( ; i < length; i++ ) {
                        fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
                    }
                }
            }

            return chainable ?
                elems :

                bulk ?
                    fn.call( elems ) :
                    length ? fn( elems[0], key ) : emptyGet;
        };
        var rcheckableType = (/^(?:checkbox|radio)$/i);



        (function() {
            var input = document.createElement( "input" ),
                div = document.createElement( "div" ),
                fragment = document.createDocumentFragment();

            div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

            support.leadingWhitespace = div.firstChild.nodeType === 3;

            support.tbody = !div.getElementsByTagName( "tbody" ).length;

            support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;

            support.html5Clone =
                document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";

            input.type = "checkbox";
            input.checked = true;
            fragment.appendChild( input );
            support.appendChecked = input.checked;

            div.innerHTML = "<textarea>x</textarea>";
            support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

            fragment.appendChild( div );
            div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

            support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

            support.noCloneEvent = true;
            if ( div.attachEvent ) {
                div.attachEvent( "onclick", function() {
                    support.noCloneEvent = false;
                });

                div.cloneNode( true ).click();
            }

            if (support.deleteExpando == null) {
                // Support: IE<9
                support.deleteExpando = true;
                try {
                    delete div.test;
                } catch( e ) {
                    support.deleteExpando = false;
                }
            }
        })();


        (function() {
            var i, eventName,
                div = document.createElement( "div" );

            for ( i in { submit: true, change: true, focusin: true }) {
                eventName = "on" + i;

                if ( !(support[ i + "Bubbles" ] = eventName in window) ) {
                    div.setAttribute( eventName, "t" );
                    support[ i + "Bubbles" ] = div.attributes[ eventName ].expando === false;
                }
            }

            div = null;
        })();


        var rformElems = /^(?:input|select|textarea)$/i,
            rkeyEvent = /^key/,
            rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
            rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
            rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

        function returnTrue() {
            return true;
        }

        function returnFalse() {
            return false;
        }

        function safeActiveElement() {
            try {
                return document.activeElement;
            } catch ( err ) { }
        }

        jQuery.event = {

            global: {},

            add: function( elem, types, handler, data, selector ) {
                var tmp, events, t, handleObjIn,
                    special, eventHandle, handleObj,
                    handlers, type, namespaces, origType,
                    elemData = jQuery._data( elem );

                if ( !elemData ) {
                    return;
                }

                if ( handler.handler ) {
                    handleObjIn = handler;
                    handler = handleObjIn.handler;
                    selector = handleObjIn.selector;
                }

                if ( !handler.guid ) {
                    handler.guid = jQuery.guid++;
                }

                if ( !(events = elemData.events) ) {
                    events = elemData.events = {};
                }
                if ( !(eventHandle = elemData.handle) ) {
                    eventHandle = elemData.handle = function( e ) {
                        return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?
                            jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
                            undefined;
                    };
                    eventHandle.elem = elem;
                }

                types = ( types || "" ).match( rnotwhite ) || [ "" ];
                t = types.length;
                while ( t-- ) {
                    tmp = rtypenamespace.exec( types[t] ) || [];
                    type = origType = tmp[1];
                    namespaces = ( tmp[2] || "" ).split( "." ).sort();

                    if ( !type ) {
                        continue;
                    }

                    special = jQuery.event.special[ type ] || {};

                    type = ( selector ? special.delegateType : special.bindType ) || type;

                    special = jQuery.event.special[ type ] || {};

                    handleObj = jQuery.extend({
                        type: type,
                        origType: origType,
                        data: data,
                        handler: handler,
                        guid: handler.guid,
                        selector: selector,
                        needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
                        namespace: namespaces.join(".")
                    }, handleObjIn );

                    if ( !(handlers = events[ type ]) ) {
                        handlers = events[ type ] = [];
                        handlers.delegateCount = 0;

                        if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
                            if ( elem.addEventListener ) {
                                elem.addEventListener( type, eventHandle, false );

                            } else if ( elem.attachEvent ) {
                                elem.attachEvent( "on" + type, eventHandle );
                            }
                        }
                    }

                    if ( special.add ) {
                        special.add.call( elem, handleObj );

                        if ( !handleObj.handler.guid ) {
                            handleObj.handler.guid = handler.guid;
                        }
                    }

                    if ( selector ) {
                        handlers.splice( handlers.delegateCount++, 0, handleObj );
                    } else {
                        handlers.push( handleObj );
                    }

                    jQuery.event.global[ type ] = true;
                }

                elem = null;
            },

            remove: function( elem, types, handler, selector, mappedTypes ) {
                var j, handleObj, tmp,
                    origCount, t, events,
                    special, handlers, type,
                    namespaces, origType,
                    elemData = jQuery.hasData( elem ) && jQuery._data( elem );

                if ( !elemData || !(events = elemData.events) ) {
                    return;
                }

                types = ( types || "" ).match( rnotwhite ) || [ "" ];
                t = types.length;
                while ( t-- ) {
                    tmp = rtypenamespace.exec( types[t] ) || [];
                    type = origType = tmp[1];
                    namespaces = ( tmp[2] || "" ).split( "." ).sort();

                    if ( !type ) {
                        for ( type in events ) {
                            jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                        }
                        continue;
                    }

                    special = jQuery.event.special[ type ] || {};
                    type = ( selector ? special.delegateType : special.bindType ) || type;
                    handlers = events[ type ] || [];
                    tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

                    origCount = j = handlers.length;
                    while ( j-- ) {
                        handleObj = handlers[ j ];

                        if ( ( mappedTypes || origType === handleObj.origType ) &&
                            ( !handler || handler.guid === handleObj.guid ) &&
                            ( !tmp || tmp.test( handleObj.namespace ) ) &&
                            ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
                            handlers.splice( j, 1 );

                            if ( handleObj.selector ) {
                                handlers.delegateCount--;
                            }
                            if ( special.remove ) {
                                special.remove.call( elem, handleObj );
                            }
                        }
                    }

                    if ( origCount && !handlers.length ) {
                        if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
                            jQuery.removeEvent( elem, type, elemData.handle );
                        }

                        delete events[ type ];
                    }
                }

                if ( jQuery.isEmptyObject( events ) ) {
                    delete elemData.handle;

                    jQuery._removeData( elem, "events" );
                }
            },

            trigger: function( event, data, elem, onlyHandlers ) {
                var handle, ontype, cur,
                    bubbleType, special, tmp, i,
                    eventPath = [ elem || document ],
                    type = hasOwn.call( event, "type" ) ? event.type : event,
                    namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

                cur = tmp = elem = elem || document;

                if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                    return;
                }

                if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
                    return;
                }

                if ( type.indexOf(".") >= 0 ) {
                    namespaces = type.split(".");
                    type = namespaces.shift();
                    namespaces.sort();
                }
                ontype = type.indexOf(":") < 0 && "on" + type;

                event = event[ jQuery.expando ] ?
                    event :
                    new jQuery.Event( type, typeof event === "object" && event );

                event.isTrigger = onlyHandlers ? 2 : 3;
                event.namespace = namespaces.join(".");
                event.namespace_re = event.namespace ?
                    new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
                    null;

                event.result = undefined;
                if ( !event.target ) {
                    event.target = elem;
                }

                data = data == null ?
                    [ event ] :
                    jQuery.makeArray( data, [ event ] );

                special = jQuery.event.special[ type ] || {};
                if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
                    return;
                }

                if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

                    bubbleType = special.delegateType || type;
                    if ( !rfocusMorph.test( bubbleType + type ) ) {
                        cur = cur.parentNode;
                    }
                    for ( ; cur; cur = cur.parentNode ) {
                        eventPath.push( cur );
                        tmp = cur;
                    }

                    if ( tmp === (elem.ownerDocument || document) ) {
                        eventPath.push( tmp.defaultView || tmp.parentWindow || window );
                    }
                }

                i = 0;
                while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

                    event.type = i > 1 ?
                        bubbleType :
                        special.bindType || type;

                    handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
                    if ( handle ) {
                        handle.apply( cur, data );
                    }

                    handle = ontype && cur[ ontype ];
                    if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
                        event.result = handle.apply( cur, data );
                        if ( event.result === false ) {
                            event.preventDefault();
                        }
                    }
                }
                event.type = type;

                if ( !onlyHandlers && !event.isDefaultPrevented() ) {

                    if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
                        jQuery.acceptData( elem ) ) {

                        if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

                            tmp = elem[ ontype ];

                            if ( tmp ) {
                                elem[ ontype ] = null;
                            }

                            jQuery.event.triggered = type;
                            try {
                                elem[ type ]();
                            } catch ( e ) {
                            }
                            jQuery.event.triggered = undefined;

                            if ( tmp ) {
                                elem[ ontype ] = tmp;
                            }
                        }
                    }
                }

                return event.result;
            },

            dispatch: function( event ) {

                event = jQuery.event.fix( event );

                var i, ret, handleObj, matched, j,
                    handlerQueue = [],
                    args = slice.call( arguments ),
                    handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
                    special = jQuery.event.special[ event.type ] || {};

                args[0] = event;
                event.delegateTarget = this;

                if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
                    return;
                }

                handlerQueue = jQuery.event.handlers.call( this, event, handlers );

                i = 0;
                while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
                    event.currentTarget = matched.elem;

                    j = 0;
                    while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

                        if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

                            event.handleObj = handleObj;
                            event.data = handleObj.data;

                            ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
                                .apply( matched.elem, args );

                            if ( ret !== undefined ) {
                                if ( (event.result = ret) === false ) {
                                    event.preventDefault();
                                    event.stopPropagation();
                                }
                            }
                        }
                    }
                }

                if ( special.postDispatch ) {
                    special.postDispatch.call( this, event );
                }

                return event.result;
            },

            handlers: function( event, handlers ) {
                var sel, handleObj, matches, i,
                    handlerQueue = [],
                    delegateCount = handlers.delegateCount,
                    cur = event.target;

                if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

                    for ( ; cur != this; cur = cur.parentNode || this ) {

                        if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
                            matches = [];
                            for ( i = 0; i < delegateCount; i++ ) {
                                handleObj = handlers[ i ];

                                sel = handleObj.selector + " ";

                                if ( matches[ sel ] === undefined ) {
                                    matches[ sel ] = handleObj.needsContext ?
                                        jQuery( sel, this ).index( cur ) >= 0 :
                                        jQuery.find( sel, this, null, [ cur ] ).length;
                                }
                                if ( matches[ sel ] ) {
                                    matches.push( handleObj );
                                }
                            }
                            if ( matches.length ) {
                                handlerQueue.push({ elem: cur, handlers: matches });
                            }
                        }
                    }
                }

                if ( delegateCount < handlers.length ) {
                    handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
                }

                return handlerQueue;
            },

            fix: function( event ) {
                if ( event[ jQuery.expando ] ) {
                    return event;
                }

                var i, prop, copy,
                    type = event.type,
                    originalEvent = event,
                    fixHook = this.fixHooks[ type ];

                if ( !fixHook ) {
                    this.fixHooks[ type ] = fixHook =
                        rmouseEvent.test( type ) ? this.mouseHooks :
                            rkeyEvent.test( type ) ? this.keyHooks :
                                {};
                }
                copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

                event = new jQuery.Event( originalEvent );

                i = copy.length;
                while ( i-- ) {
                    prop = copy[ i ];
                    event[ prop ] = originalEvent[ prop ];
                }

                if ( !event.target ) {
                    event.target = originalEvent.srcElement || document;
                }

                if ( event.target.nodeType === 3 ) {
                    event.target = event.target.parentNode;
                }

                event.metaKey = !!event.metaKey;

                return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
            },

            props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

            fixHooks: {},

            keyHooks: {
                props: "char charCode key keyCode".split(" "),
                filter: function( event, original ) {

                    // Add which for key events
                    if ( event.which == null ) {
                        event.which = original.charCode != null ? original.charCode : original.keyCode;
                    }

                    return event;
                }
            },

            mouseHooks: {
                props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
                filter: function( event, original ) {
                    var body, eventDoc, doc,
                        button = original.button,
                        fromElement = original.fromElement;

                    if ( event.pageX == null && original.clientX != null ) {
                        eventDoc = event.target.ownerDocument || document;
                        doc = eventDoc.documentElement;
                        body = eventDoc.body;

                        event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                        event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
                    }

                    if ( !event.relatedTarget && fromElement ) {
                        event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
                    }

                    if ( !event.which && button !== undefined ) {
                        event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
                    }

                    return event;
                }
            },

            special: {
                load: {
                    noBubble: true
                },
                focus: {
                    trigger: function() {
                        if ( this !== safeActiveElement() && this.focus ) {
                            try {
                                this.focus();
                                return false;
                            } catch ( e ) {
                            }
                        }
                    },
                    delegateType: "focusin"
                },
                blur: {
                    trigger: function() {
                        if ( this === safeActiveElement() && this.blur ) {
                            this.blur();
                            return false;
                        }
                    },
                    delegateType: "focusout"
                },
                click: {
                    trigger: function() {
                        if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
                            this.click();
                            return false;
                        }
                    },

                    _default: function( event ) {
                        return jQuery.nodeName( event.target, "a" );
                    }
                },

                beforeunload: {
                    postDispatch: function( event ) {

                        if ( event.result !== undefined && event.originalEvent ) {
                            event.originalEvent.returnValue = event.result;
                        }
                    }
                }
            },

            simulate: function( type, elem, event, bubble ) {
                var e = jQuery.extend(
                    new jQuery.Event(),
                    event,
                    {
                        type: type,
                        isSimulated: true,
                        originalEvent: {}
                    }
                );
                if ( bubble ) {
                    jQuery.event.trigger( e, null, elem );
                } else {
                    jQuery.event.dispatch.call( elem, e );
                }
                if ( e.isDefaultPrevented() ) {
                    event.preventDefault();
                }
            }
        };

        jQuery.removeEvent = document.removeEventListener ?
            function( elem, type, handle ) {
                if ( elem.removeEventListener ) {
                    elem.removeEventListener( type, handle, false );
                }
            } :
            function( elem, type, handle ) {
                var name = "on" + type;

                if ( elem.detachEvent ) {

                    if ( typeof elem[ name ] === strundefined ) {
                        elem[ name ] = null;
                    }

                    elem.detachEvent( name, handle );
                }
            };

        jQuery.Event = function( src, props ) {
            if ( !(this instanceof jQuery.Event) ) {
                return new jQuery.Event( src, props );
            }

            // Event object
            if ( src && src.type ) {
                this.originalEvent = src;
                this.type = src.type;

                this.isDefaultPrevented = src.defaultPrevented ||
                src.defaultPrevented === undefined &&
                src.returnValue === false ?
                    returnTrue :
                    returnFalse;

                // Event type
            } else {
                this.type = src;
            }

            if ( props ) {
                jQuery.extend( this, props );
            }

            this.timeStamp = src && src.timeStamp || jQuery.now();

            this[ jQuery.expando ] = true;
        };

        jQuery.Event.prototype = {
            isDefaultPrevented: returnFalse,
            isPropagationStopped: returnFalse,
            isImmediatePropagationStopped: returnFalse,

            preventDefault: function() {
                var e = this.originalEvent;

                this.isDefaultPrevented = returnTrue;
                if ( !e ) {
                    return;
                }

                if ( e.preventDefault ) {
                    e.preventDefault();

                } else {
                    e.returnValue = false;
                }
            },
            stopPropagation: function() {
                var e = this.originalEvent;

                this.isPropagationStopped = returnTrue;
                if ( !e ) {
                    return;
                }
                if ( e.stopPropagation ) {
                    e.stopPropagation();
                }

                e.cancelBubble = true;
            },
            stopImmediatePropagation: function() {
                var e = this.originalEvent;

                this.isImmediatePropagationStopped = returnTrue;

                if ( e && e.stopImmediatePropagation ) {
                    e.stopImmediatePropagation();
                }

                this.stopPropagation();
            }
        };

        jQuery.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout"
        }, function( orig, fix ) {
            jQuery.event.special[ orig ] = {
                delegateType: fix,
                bindType: fix,

                handle: function( event ) {
                    var ret,
                        target = this,
                        related = event.relatedTarget,
                        handleObj = event.handleObj;

                    if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
                        event.type = handleObj.origType;
                        ret = handleObj.handler.apply( this, arguments );
                        event.type = fix;
                    }
                    return ret;
                }
            };
        });

        if ( !support.submitBubbles ) {

            jQuery.event.special.submit = {
                setup: function() {
                    if ( jQuery.nodeName( this, "form" ) ) {
                        return false;
                    }

                    jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
                        var elem = e.target,
                            form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
                        if ( form && !jQuery._data( form, "submitBubbles" ) ) {
                            jQuery.event.add( form, "submit._submit", function( event ) {
                                event._submit_bubble = true;
                            });
                            jQuery._data( form, "submitBubbles", true );
                        }
                    });
                },

                postDispatch: function( event ) {
                    if ( event._submit_bubble ) {
                        delete event._submit_bubble;
                        if ( this.parentNode && !event.isTrigger ) {
                            jQuery.event.simulate( "submit", this.parentNode, event, true );
                        }
                    }
                },

                teardown: function() {
                    if ( jQuery.nodeName( this, "form" ) ) {
                        return false;
                    }

                    jQuery.event.remove( this, "._submit" );
                }
            };
        }

        if ( !support.changeBubbles ) {

            jQuery.event.special.change = {

                setup: function() {

                    if ( rformElems.test( this.nodeName ) ) {
                        if ( this.type === "checkbox" || this.type === "radio" ) {
                            jQuery.event.add( this, "propertychange._change", function( event ) {
                                if ( event.originalEvent.propertyName === "checked" ) {
                                    this._just_changed = true;
                                }
                            });
                            jQuery.event.add( this, "click._change", function( event ) {
                                if ( this._just_changed && !event.isTrigger ) {
                                    this._just_changed = false;
                                }
                                jQuery.event.simulate( "change", this, event, true );
                            });
                        }
                        return false;
                    }
                    jQuery.event.add( this, "beforeactivate._change", function( e ) {
                        var elem = e.target;

                        if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
                            jQuery.event.add( elem, "change._change", function( event ) {
                                if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
                                    jQuery.event.simulate( "change", this.parentNode, event, true );
                                }
                            });
                            jQuery._data( elem, "changeBubbles", true );
                        }
                    });
                },

                handle: function( event ) {
                    var elem = event.target;

                    if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
                        return event.handleObj.handler.apply( this, arguments );
                    }
                },

                teardown: function() {
                    jQuery.event.remove( this, "._change" );

                    return !rformElems.test( this.nodeName );
                }
            };
        }

        if ( !support.focusinBubbles ) {
            jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

                var handler = function( event ) {
                    jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
                };

                jQuery.event.special[ fix ] = {
                    setup: function() {
                        var doc = this.ownerDocument || this,
                            attaches = jQuery._data( doc, fix );

                        if ( !attaches ) {
                            doc.addEventListener( orig, handler, true );
                        }
                        jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
                    },
                    teardown: function() {
                        var doc = this.ownerDocument || this,
                            attaches = jQuery._data( doc, fix ) - 1;

                        if ( !attaches ) {
                            doc.removeEventListener( orig, handler, true );
                            jQuery._removeData( doc, fix );
                        } else {
                            jQuery._data( doc, fix, attaches );
                        }
                    }
                };
            });
        }

        jQuery.fn.extend({

            on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
                var type, origFn;

                if ( typeof types === "object" ) {
                    if ( typeof selector !== "string" ) {
                        data = data || selector;
                        selector = undefined;
                    }
                    for ( type in types ) {
                        this.on( type, selector, data, types[ type ], one );
                    }
                    return this;
                }

                if ( data == null && fn == null ) {
                    fn = selector;
                    data = selector = undefined;
                } else if ( fn == null ) {
                    if ( typeof selector === "string" ) {
                        fn = data;
                        data = undefined;
                    } else {
                        fn = data;
                        data = selector;
                        selector = undefined;
                    }
                }
                if ( fn === false ) {
                    fn = returnFalse;
                } else if ( !fn ) {
                    return this;
                }

                if ( one === 1 ) {
                    origFn = fn;
                    fn = function( event ) {
                        jQuery().off( event );
                        return origFn.apply( this, arguments );
                    };
                    fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
                }
                return this.each( function() {
                    jQuery.event.add( this, types, fn, data, selector );
                });
            },
            one: function( types, selector, data, fn ) {
                return this.on( types, selector, data, fn, 1 );
            },
            off: function( types, selector, fn ) {
                var handleObj, type;
                if ( types && types.preventDefault && types.handleObj ) {
                    handleObj = types.handleObj;
                    jQuery( types.delegateTarget ).off(
                        handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                        handleObj.selector,
                        handleObj.handler
                    );
                    return this;
                }
                if ( typeof types === "object" ) {
                    for ( type in types ) {
                        this.off( type, selector, types[ type ] );
                    }
                    return this;
                }
                if ( selector === false || typeof selector === "function" ) {
                    fn = selector;
                    selector = undefined;
                }
                if ( fn === false ) {
                    fn = returnFalse;
                }
                return this.each(function() {
                    jQuery.event.remove( this, types, fn, selector );
                });
            },

            trigger: function( type, data ) {
                return this.each(function() {
                    jQuery.event.trigger( type, data, this );
                });
            },
            triggerHandler: function( type, data ) {
                var elem = this[0];
                if ( elem ) {
                    return jQuery.event.trigger( type, data, elem, true );
                }
            }
        });


        function createSafeFragment( document ) {
            var list = nodeNames.split( "|" ),
                safeFrag = document.createDocumentFragment();

            if ( safeFrag.createElement ) {
                while ( list.length ) {
                    safeFrag.createElement(
                        list.pop()
                    );
                }
            }
            return safeFrag;
        }

        var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
                "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
            rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
            rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
            rleadingWhitespace = /^\s+/,
            rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
            rtagName = /<([\w:]+)/,
            rtbody = /<tbody/i,
            rhtml = /<|&#?\w+;/,
            rnoInnerhtml = /<(?:script|style|link)/i,
            rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
            rscriptType = /^$|\/(?:java|ecma)script/i,
            rscriptTypeMasked = /^true\/(.*)/,
            rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

            wrapMap = {
                option: [ 1, "<select multiple='multiple'>", "</select>" ],
                legend: [ 1, "<fieldset>", "</fieldset>" ],
                area: [ 1, "<map>", "</map>" ],
                param: [ 1, "<object>", "</object>" ],
                thead: [ 1, "<table>", "</table>" ],
                tr: [ 2, "<table><tbody>", "</tbody></table>" ],
                col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
                td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

                _default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
            },
            safeFragment = createSafeFragment( document ),
            fragmentDiv = safeFragment.appendChild( document.createElement("div") );

        wrapMap.optgroup = wrapMap.option;
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;

        function getAll( context, tag ) {
            var elems, elem,
                i = 0,
                found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || "*" ) :
                    typeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || "*" ) :
                        undefined;

            if ( !found ) {
                for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
                    if ( !tag || jQuery.nodeName( elem, tag ) ) {
                        found.push( elem );
                    } else {
                        jQuery.merge( found, getAll( elem, tag ) );
                    }
                }
            }

            return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
                jQuery.merge( [ context ], found ) :
                found;
        }

        function fixDefaultChecked( elem ) {
            if ( rcheckableType.test( elem.type ) ) {
                elem.defaultChecked = elem.checked;
            }
        }

        function manipulationTarget( elem, content ) {
            return jQuery.nodeName( elem, "table" ) &&
            jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

                elem.getElementsByTagName("tbody")[0] ||
                elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
                elem;
        }

        function disableScript( elem ) {
            elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
            return elem;
        }
        function restoreScript( elem ) {
            var match = rscriptTypeMasked.exec( elem.type );
            if ( match ) {
                elem.type = match[1];
            } else {
                elem.removeAttribute("type");
            }
            return elem;
        }

        function setGlobalEval( elems, refElements ) {
            var elem,
                i = 0;
            for ( ; (elem = elems[i]) != null; i++ ) {
                jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
            }
        }

        function cloneCopyEvent( src, dest ) {

            if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
                return;
            }

            var type, i, l,
                oldData = jQuery._data( src ),
                curData = jQuery._data( dest, oldData ),
                events = oldData.events;

            if ( events ) {
                delete curData.handle;
                curData.events = {};

                for ( type in events ) {
                    for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                        jQuery.event.add( dest, type, events[ type ][ i ] );
                    }
                }
            }

            if ( curData.data ) {
                curData.data = jQuery.extend( {}, curData.data );
            }
        }

        function fixCloneNodeIssues( src, dest ) {
            var nodeName, e, data;

            if ( dest.nodeType !== 1 ) {
                return;
            }

            nodeName = dest.nodeName.toLowerCase();

            if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {
                data = jQuery._data( dest );

                for ( e in data.events ) {
                    jQuery.removeEvent( dest, e, data.handle );
                }

                dest.removeAttribute( jQuery.expando );
            }

            if ( nodeName === "script" && dest.text !== src.text ) {
                disableScript( dest ).text = src.text;
                restoreScript( dest );

            } else if ( nodeName === "object" ) {
                if ( dest.parentNode ) {
                    dest.outerHTML = src.outerHTML;
                }

                if ( support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
                    dest.innerHTML = src.innerHTML;
                }

            } else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {

                dest.defaultChecked = dest.checked = src.checked;

                if ( dest.value !== src.value ) {
                    dest.value = src.value;
                }

            } else if ( nodeName === "option" ) {
                dest.defaultSelected = dest.selected = src.defaultSelected;

            } else if ( nodeName === "input" || nodeName === "textarea" ) {
                dest.defaultValue = src.defaultValue;
            }
        }

        jQuery.extend({
            clone: function( elem, dataAndEvents, deepDataAndEvents ) {
                var destElements, node, clone, i, srcElements,
                    inPage = jQuery.contains( elem.ownerDocument, elem );

                if ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
                    clone = elem.cloneNode( true );

                } else {
                    fragmentDiv.innerHTML = elem.outerHTML;
                    fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
                }

                if ( (!support.noCloneEvent || !support.noCloneChecked) &&
                    (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

                    destElements = getAll( clone );
                    srcElements = getAll( elem );

                    for ( i = 0; (node = srcElements[i]) != null; ++i ) {
                        if ( destElements[i] ) {
                            fixCloneNodeIssues( node, destElements[i] );
                        }
                    }
                }

                if ( dataAndEvents ) {
                    if ( deepDataAndEvents ) {
                        srcElements = srcElements || getAll( elem );
                        destElements = destElements || getAll( clone );

                        for ( i = 0; (node = srcElements[i]) != null; i++ ) {
                            cloneCopyEvent( node, destElements[i] );
                        }
                    } else {
                        cloneCopyEvent( elem, clone );
                    }
                }

                destElements = getAll( clone, "script" );
                if ( destElements.length > 0 ) {
                    setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
                }

                destElements = srcElements = node = null;

                return clone;
            },

            buildFragment: function( elems, context, scripts, selection ) {
                var j, elem, contains,
                    tmp, tag, tbody, wrap,
                    l = elems.length,

                    safe = createSafeFragment( context ),

                    nodes = [],
                    i = 0;

                for ( ; i < l; i++ ) {
                    elem = elems[ i ];

                    if ( elem || elem === 0 ) {

                        if ( jQuery.type( elem ) === "object" ) {
                            jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

                        } else if ( !rhtml.test( elem ) ) {
                            nodes.push( context.createTextNode( elem ) );

                        } else {
                            tmp = tmp || safe.appendChild( context.createElement("div") );

                            tag = (rtagName.exec( elem ) || [ "", "" ])[ 1 ].toLowerCase();
                            wrap = wrapMap[ tag ] || wrapMap._default;

                            tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

                            j = wrap[0];
                            while ( j-- ) {
                                tmp = tmp.lastChild;
                            }

                            if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
                                nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
                            }

                            if ( !support.tbody ) {

                                elem = tag === "table" && !rtbody.test( elem ) ?
                                    tmp.firstChild :

                                    wrap[1] === "<table>" && !rtbody.test( elem ) ?
                                        tmp :
                                        0;

                                j = elem && elem.childNodes.length;
                                while ( j-- ) {
                                    if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
                                        elem.removeChild( tbody );
                                    }
                                }
                            }

                            jQuery.merge( nodes, tmp.childNodes );

                            tmp.textContent = "";

                            while ( tmp.firstChild ) {
                                tmp.removeChild( tmp.firstChild );
                            }

                            tmp = safe.lastChild;
                        }
                    }
                }

                if ( tmp ) {
                    safe.removeChild( tmp );
                }

                if ( !support.appendChecked ) {
                    jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
                }

                i = 0;
                while ( (elem = nodes[ i++ ]) ) {

                    if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
                        continue;
                    }

                    contains = jQuery.contains( elem.ownerDocument, elem );

                    tmp = getAll( safe.appendChild( elem ), "script" );

                    if ( contains ) {
                        setGlobalEval( tmp );
                    }

                    if ( scripts ) {
                        j = 0;
                        while ( (elem = tmp[ j++ ]) ) {
                            if ( rscriptType.test( elem.type || "" ) ) {
                                scripts.push( elem );
                            }
                        }
                    }
                }

                tmp = null;

                return safe;
            },

            cleanData: function( elems, /* internal */ acceptData ) {
                var elem, type, id, data,
                    i = 0,
                    internalKey = jQuery.expando,
                    cache = jQuery.cache,
                    deleteExpando = support.deleteExpando,
                    special = jQuery.event.special;

                for ( ; (elem = elems[i]) != null; i++ ) {
                    if ( acceptData || jQuery.acceptData( elem ) ) {

                        id = elem[ internalKey ];
                        data = id && cache[ id ];

                        if ( data ) {
                            if ( data.events ) {
                                for ( type in data.events ) {
                                    if ( special[ type ] ) {
                                        jQuery.event.remove( elem, type );

                                    } else {
                                        jQuery.removeEvent( elem, type, data.handle );
                                    }
                                }
                            }

                            if ( cache[ id ] ) {

                                delete cache[ id ];

                                if ( deleteExpando ) {
                                    delete elem[ internalKey ];

                                } else if ( typeof elem.removeAttribute !== strundefined ) {
                                    elem.removeAttribute( internalKey );

                                } else {
                                    elem[ internalKey ] = null;
                                }

                                deletedIds.push( id );
                            }
                        }
                    }
                }
            }
        });

        jQuery.fn.extend({
            text: function( value ) {
                return access( this, function( value ) {
                    return value === undefined ?
                        jQuery.text( this ) :
                        this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
                }, null, value, arguments.length );
            },

            append: function() {
                return this.domManip( arguments, function( elem ) {
                    if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                        var target = manipulationTarget( this, elem );
                        target.appendChild( elem );
                    }
                });
            },

            prepend: function() {
                return this.domManip( arguments, function( elem ) {
                    if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                        var target = manipulationTarget( this, elem );
                        target.insertBefore( elem, target.firstChild );
                    }
                });
            },

            before: function() {
                return this.domManip( arguments, function( elem ) {
                    if ( this.parentNode ) {
                        this.parentNode.insertBefore( elem, this );
                    }
                });
            },

            after: function() {
                return this.domManip( arguments, function( elem ) {
                    if ( this.parentNode ) {
                        this.parentNode.insertBefore( elem, this.nextSibling );
                    }
                });
            },

            remove: function( selector, keepData /* Internal Use Only */ ) {
                var elem,
                    elems = selector ? jQuery.filter( selector, this ) : this,
                    i = 0;

                for ( ; (elem = elems[i]) != null; i++ ) {

                    if ( !keepData && elem.nodeType === 1 ) {
                        jQuery.cleanData( getAll( elem ) );
                    }

                    if ( elem.parentNode ) {
                        if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
                            setGlobalEval( getAll( elem, "script" ) );
                        }
                        elem.parentNode.removeChild( elem );
                    }
                }

                return this;
            },

            empty: function() {
                var elem,
                    i = 0;

                for ( ; (elem = this[i]) != null; i++ ) {
                    if ( elem.nodeType === 1 ) {
                        jQuery.cleanData( getAll( elem, false ) );
                    }

                    while ( elem.firstChild ) {
                        elem.removeChild( elem.firstChild );
                    }

                    if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
                        elem.options.length = 0;
                    }
                }

                return this;
            },

            clone: function( dataAndEvents, deepDataAndEvents ) {
                dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

                return this.map(function() {
                    return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
                });
            },

            html: function( value ) {
                return access( this, function( value ) {
                    var elem = this[ 0 ] || {},
                        i = 0,
                        l = this.length;

                    if ( value === undefined ) {
                        return elem.nodeType === 1 ?
                            elem.innerHTML.replace( rinlinejQuery, "" ) :
                            undefined;
                    }

                    if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
                        ( support.htmlSerialize || !rnoshimcache.test( value )  ) &&
                        ( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
                        !wrapMap[ (rtagName.exec( value ) || [ "", "" ])[ 1 ].toLowerCase() ] ) {

                        value = value.replace( rxhtmlTag, "<$1></$2>" );

                        try {
                            for (; i < l; i++ ) {
                                elem = this[i] || {};
                                if ( elem.nodeType === 1 ) {
                                    jQuery.cleanData( getAll( elem, false ) );
                                    elem.innerHTML = value;
                                }
                            }

                            elem = 0;

                        } catch(e) {}
                    }

                    if ( elem ) {
                        this.empty().append( value );
                    }
                }, null, value, arguments.length );
            },

            replaceWith: function() {
                var arg = arguments[ 0 ];

                this.domManip( arguments, function( elem ) {
                    arg = this.parentNode;

                    jQuery.cleanData( getAll( this ) );

                    if ( arg ) {
                        arg.replaceChild( elem, this );
                    }
                });

                return arg && (arg.length || arg.nodeType) ? this : this.remove();
            },

            detach: function( selector ) {
                return this.remove( selector, true );
            },

            domManip: function( args, callback ) {

                args = concat.apply( [], args );

                var first, node, hasScripts,
                    scripts, doc, fragment,
                    i = 0,
                    l = this.length,
                    set = this,
                    iNoClone = l - 1,
                    value = args[0],
                    isFunction = jQuery.isFunction( value );

                if ( isFunction ||
                    ( l > 1 && typeof value === "string" &&
                    !support.checkClone && rchecked.test( value ) ) ) {
                    return this.each(function( index ) {
                        var self = set.eq( index );
                        if ( isFunction ) {
                            args[0] = value.call( this, index, self.html() );
                        }
                        self.domManip( args, callback );
                    });
                }

                if ( l ) {
                    fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
                    first = fragment.firstChild;

                    if ( fragment.childNodes.length === 1 ) {
                        fragment = first;
                    }

                    if ( first ) {
                        scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
                        hasScripts = scripts.length;

                        for ( ; i < l; i++ ) {
                            node = fragment;

                            if ( i !== iNoClone ) {
                                node = jQuery.clone( node, true, true );

                                if ( hasScripts ) {
                                    jQuery.merge( scripts, getAll( node, "script" ) );
                                }
                            }

                            callback.call( this[i], node, i );
                        }

                        if ( hasScripts ) {
                            doc = scripts[ scripts.length - 1 ].ownerDocument;

                            jQuery.map( scripts, restoreScript );

                            for ( i = 0; i < hasScripts; i++ ) {
                                node = scripts[ i ];
                                if ( rscriptType.test( node.type || "" ) &&
                                    !jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

                                    if ( node.src ) {
                                        if ( jQuery._evalUrl ) {
                                            jQuery._evalUrl( node.src );
                                        }
                                    } else {
                                        jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
                                    }
                                }
                            }
                        }

                        fragment = first = null;
                    }
                }

                return this;
            }
        });

        jQuery.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, function( name, original ) {
            jQuery.fn[ name ] = function( selector ) {
                var elems,
                    i = 0,
                    ret = [],
                    insert = jQuery( selector ),
                    last = insert.length - 1;

                for ( ; i <= last; i++ ) {
                    elems = i === last ? this : this.clone(true);
                    jQuery( insert[i] )[ original ]( elems );

                    push.apply( ret, elems.get() );
                }

                return this.pushStack( ret );
            };
        });


        var iframe,
            elemdisplay = {};

        function actualDisplay( name, doc ) {
            var style,
                elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

                display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

                    style.display : jQuery.css( elem[ 0 ], "display" );

            elem.detach();

            return display;
        }

        function defaultDisplay( nodeName ) {
            var doc = document,
                display = elemdisplay[ nodeName ];

            if ( !display ) {
                display = actualDisplay( nodeName, doc );

                if ( display === "none" || !display ) {

                    iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

                    doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;

                    doc.write();
                    doc.close();

                    display = actualDisplay( nodeName, doc );
                    iframe.detach();
                }

                elemdisplay[ nodeName ] = display;
            }

            return display;
        }


        (function() {
            var shrinkWrapBlocksVal;

            support.shrinkWrapBlocks = function() {
                if ( shrinkWrapBlocksVal != null ) {
                    return shrinkWrapBlocksVal;
                }

                shrinkWrapBlocksVal = false;

                var div, body, container;

                body = document.getElementsByTagName( "body" )[ 0 ];
                if ( !body || !body.style ) {
                    return;
                }

                div = document.createElement( "div" );
                container = document.createElement( "div" );
                container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
                body.appendChild( container ).appendChild( div );

                if ( typeof div.style.zoom !== strundefined ) {
                    div.style.cssText =
                        "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
                        "box-sizing:content-box;display:block;margin:0;border:0;" +
                        "padding:1px;width:1px;zoom:1";
                    div.appendChild( document.createElement( "div" ) ).style.width = "5px";
                    shrinkWrapBlocksVal = div.offsetWidth !== 3;
                }

                body.removeChild( container );

                return shrinkWrapBlocksVal;
            };

        })();
        var rmargin = (/^margin/);

        var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

        var getStyles, curCSS,
            rposition = /^(top|right|bottom|left)$/;

        if ( window.getComputedStyle ) {
            getStyles = function( elem ) {
            		var doc = elem.ownerDocument;
            		var docView = 'defaultView' in doc ? doc.defaultView : doc.parentWindow;
                if ( docView.opener ) {
                    return docView.getComputedStyle( elem, null );
                }

                return window.getComputedStyle( elem, null );
            };

            curCSS = function( elem, name, computed ) {
                var width, minWidth, maxWidth, ret,
                    style = elem.style;

                computed = computed || getStyles( elem );

                ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

                if ( computed ) {

                    if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
                        ret = jQuery.style( elem, name );
                    }

                    if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

                        width = style.width;
                        minWidth = style.minWidth;
                        maxWidth = style.maxWidth;

                        style.minWidth = style.maxWidth = style.width = ret;
                        ret = computed.width;

                        style.width = width;
                        style.minWidth = minWidth;
                        style.maxWidth = maxWidth;
                    }
                }

                return ret === undefined ?
                    ret :
                    ret + "";
            };
        } else if ( document.documentElement.currentStyle ) {
            getStyles = function( elem ) {
                return elem.currentStyle;
            };

            curCSS = function( elem, name, computed ) {
                var left, rs, rsLeft, ret,
                    style = elem.style;

                computed = computed || getStyles( elem );
                ret = computed ? computed[ name ] : undefined;

                if ( ret == null && style && style[ name ] ) {
                    ret = style[ name ];
                }

                if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

                    left = style.left;
                    rs = elem.runtimeStyle;
                    rsLeft = rs && rs.left;

                    if ( rsLeft ) {
                        rs.left = elem.currentStyle.left;
                    }
                    style.left = name === "fontSize" ? "1em" : ret;
                    ret = style.pixelLeft + "px";

                    style.left = left;
                    if ( rsLeft ) {
                        rs.left = rsLeft;
                    }
                }

                return ret === undefined ?
                    ret :
                    ret + "" || "auto";
            };
        }

        function addGetHookIf( conditionFn, hookFn ) {
            return {
                get: function() {
                    var condition = conditionFn();

                    if ( condition == null ) {
                        return;
                    }

                    if ( condition ) {
                        delete this.get;
                        return;
                    }

                    return (this.get = hookFn).apply( this, arguments );
                }
            };
        }


        (function() {
            var div, style, a, pixelPositionVal, boxSizingReliableVal,
                reliableHiddenOffsetsVal, reliableMarginRightVal;

            div = document.createElement( "div" );
            div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
            a = div.getElementsByTagName( "a" )[ 0 ];
            style = a && a.style;

            if ( !style ) {
                return;
            }

            style.cssText = "float:left;opacity:.5";

            support.opacity = style.opacity === "0.5";

            support.cssFloat = !!style.cssFloat;

            div.style.backgroundClip = "content-box";
            div.cloneNode( true ).style.backgroundClip = "";
            support.clearCloneStyle = div.style.backgroundClip === "content-box";

            support.boxSizing = style.boxSizing === "" || style.MozBoxSizing === "" ||
                style.WebkitBoxSizing === "";

            jQuery.extend(support, {
                reliableHiddenOffsets: function() {
                    if ( reliableHiddenOffsetsVal == null ) {
                        computeStyleTests();
                    }
                    return reliableHiddenOffsetsVal;
                },

                boxSizingReliable: function() {
                    if ( boxSizingReliableVal == null ) {
                        computeStyleTests();
                    }
                    return boxSizingReliableVal;
                },

                pixelPosition: function() {
                    if ( pixelPositionVal == null ) {
                        computeStyleTests();
                    }
                    return pixelPositionVal;
                },

                reliableMarginRight: function() {
                    if ( reliableMarginRightVal == null ) {
                        computeStyleTests();
                    }
                    return reliableMarginRightVal;
                }
            });

            function computeStyleTests() {
                // Minified: var b,c,d,j
                var div, body, container, contents;

                body = document.getElementsByTagName( "body" )[ 0 ];
                if ( !body || !body.style ) {
                    // Test fired too early or in an unsupported environment, exit.
                    return;
                }

                div = document.createElement( "div" );
                container = document.createElement( "div" );
                container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
                body.appendChild( container ).appendChild( div );

                div.style.cssText =
                    "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
                    "box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
                    "border:1px;padding:1px;width:4px;position:absolute";

                pixelPositionVal = boxSizingReliableVal = false;
                reliableMarginRightVal = true;

                if ( window.getComputedStyle ) {
                    pixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
                    boxSizingReliableVal =
                        ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

                    contents = div.appendChild( document.createElement( "div" ) );

                    contents.style.cssText = div.style.cssText =
                        "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
                        "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
                    contents.style.marginRight = contents.style.width = "0";
                    div.style.width = "1px";

                    reliableMarginRightVal =
                        !parseFloat( ( window.getComputedStyle( contents, null ) || {} ).marginRight );

                    div.removeChild( contents );
                }

                div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
                contents = div.getElementsByTagName( "td" );
                contents[ 0 ].style.cssText = "margin:0;border:0;padding:0;display:none";
                reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
                if ( reliableHiddenOffsetsVal ) {
                    contents[ 0 ].style.display = "";
                    contents[ 1 ].style.display = "none";
                    reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
                }

                body.removeChild( container );
            }

        })();


        jQuery.swap = function( elem, options, callback, args ) {
            var ret, name,
                old = {};

            for ( name in options ) {
                old[ name ] = elem.style[ name ];
                elem.style[ name ] = options[ name ];
            }

            ret = callback.apply( elem, args || [] );

            for ( name in options ) {
                elem.style[ name ] = old[ name ];
            }

            return ret;
        };


        var ralpha = /alpha\([^)]*\)/i,
            ropacity = /opacity\s*=\s*([^)]*)/,
            rdisplayswap = /^(none|table(?!-c[ea]).+)/,
            rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
            rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

            cssShow = { position: "absolute", visibility: "hidden", display: "block" },
            cssNormalTransform = {
                letterSpacing: "0",
                fontWeight: "400"
            },

            cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

        function vendorPropName( style, name ) {

            if ( name in style ) {
                return name;
            }

            var capName = name.charAt(0).toUpperCase() + name.slice(1),
                origName = name,
                i = cssPrefixes.length;

            while ( i-- ) {
                name = cssPrefixes[ i ] + capName;
                if ( name in style ) {
                    return name;
                }
            }

            return origName;
        }

        function showHide( elements, show ) {
            var display, elem, hidden,
                values = [],
                index = 0,
                length = elements.length;

            for ( ; index < length; index++ ) {
                elem = elements[ index ];
                if ( !elem.style ) {
                    continue;
                }

                values[ index ] = jQuery._data( elem, "olddisplay" );
                display = elem.style.display;
                if ( show ) {
                    if ( !values[ index ] && display === "none" ) {
                        elem.style.display = "";
                    }

                    if ( elem.style.display === "" && isHidden( elem ) ) {
                        values[ index ] = jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
                    }
                } else {
                    hidden = isHidden( elem );

                    if ( display && display !== "none" || !hidden ) {
                        jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
                    }
                }
            }

            for ( index = 0; index < length; index++ ) {
                elem = elements[ index ];
                if ( !elem.style ) {
                    continue;
                }
                if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
                    elem.style.display = show ? values[ index ] || "" : "none";
                }
            }

            return elements;
        }

        function setPositiveNumber( elem, value, subtract ) {
            var matches = rnumsplit.exec( value );
            return matches ?
                Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
                value;
        }

        function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
            var i = extra === ( isBorderBox ? "border" : "content" ) ?
                    4 :
                    name === "width" ? 1 : 0,

                val = 0;

            for ( ; i < 4; i += 2 ) {
                if ( extra === "margin" ) {
                    val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
                }

                if ( isBorderBox ) {
                    if ( extra === "content" ) {
                        val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
                    }

                    if ( extra !== "margin" ) {
                        val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                    }
                } else {
                    val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

                    if ( extra !== "padding" ) {
                        val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                    }
                }
            }

            return val;
        }

        function getWidthOrHeight( elem, name, extra ) {

            var valueIsBorderBox = true,
                val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
                styles = getStyles( elem ),
                isBorderBox = support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

            if ( val <= 0 || val == null ) {
                val = curCSS( elem, name, styles );
                if ( val < 0 || val == null ) {
                    val = elem.style[ name ];
                }

                if ( rnumnonpx.test(val) ) {
                    return val;
                }

                valueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );

                val = parseFloat( val ) || 0;
            }

            return ( val +
                    augmentWidthOrHeight(
                        elem,
                        name,
                        extra || ( isBorderBox ? "border" : "content" ),
                        valueIsBorderBox,
                        styles
                    )
                ) + "px";
        }

        jQuery.extend({
            cssHooks: {
                opacity: {
                    get: function( elem, computed ) {
                        if ( computed ) {
                            var ret = curCSS( elem, "opacity" );
                            return ret === "" ? "1" : ret;
                        }
                    }
                }
            },

            cssNumber: {
                "columnCount": true,
                "fillOpacity": true,
                "flexGrow": true,
                "flexShrink": true,
                "fontWeight": true,
                "lineHeight": true,
                "opacity": true,
                "order": true,
                "orphans": true,
                "widows": true,
                "zIndex": true,
                "zoom": true
            },

            cssProps: {
                "float": support.cssFloat ? "cssFloat" : "styleFloat"
            },

            style: function( elem, name, value, extra ) {
                if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
                    return;
                }

                var ret, type, hooks,
                    origName = jQuery.camelCase( name ),
                    style = elem.style;

                name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

                hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

                if ( value !== undefined ) {
                    type = typeof value;

                    if ( type === "string" && (ret = rrelNum.exec( value )) ) {
                        value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
                        type = "number";
                    }

                    if ( value == null || value !== value ) {
                        return;
                    }

                    if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
                        value += "px";
                    }

                    if ( !support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
                        style[ name ] = "inherit";
                    }

                    if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

                        try {
                            style[ name ] = value;
                        } catch(e) {}
                    }

                } else {
                    if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
                        return ret;
                    }

                    return style[ name ];
                }
            },

            css: function( elem, name, extra, styles ) {
                var num, val, hooks,
                    origName = jQuery.camelCase( name );

                name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

                hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

                if ( hooks && "get" in hooks ) {
                    val = hooks.get( elem, true, extra );
                }

                if ( val === undefined ) {
                    val = curCSS( elem, name, styles );
                }

                if ( val === "normal" && name in cssNormalTransform ) {
                    val = cssNormalTransform[ name ];
                }

                if ( extra === "" || extra ) {
                    num = parseFloat( val );
                    return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
                }
                return val;
            }
        });

        jQuery.each([ "height", "width" ], function( i, name ) {
            jQuery.cssHooks[ name ] = {
                get: function( elem, computed, extra ) {
                    if ( computed ) {
                        return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
                            jQuery.swap( elem, cssShow, function() {
                                return getWidthOrHeight( elem, name, extra );
                            }) :
                            getWidthOrHeight( elem, name, extra );
                    }
                },

                set: function( elem, value, extra ) {
                    var styles = extra && getStyles( elem );
                    return setPositiveNumber( elem, value, extra ?
                        augmentWidthOrHeight(
                            elem,
                            name,
                            extra,
                            support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
                            styles
                        ) : 0
                    );
                }
            };
        });

        if ( !support.opacity ) {
            jQuery.cssHooks.opacity = {
                get: function( elem, computed ) {
                    return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
                        ( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
                        computed ? "1" : "";
                },

                set: function( elem, value ) {
                    var style = elem.style,
                        currentStyle = elem.currentStyle,
                        opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
                        filter = currentStyle && currentStyle.filter || style.filter || "";

                    style.zoom = 1;

                    if ( ( value >= 1 || value === "" ) &&
                        jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
                        style.removeAttribute ) {

                        style.removeAttribute( "filter" );

                        if ( value === "" || currentStyle && !currentStyle.filter ) {
                            return;
                        }
                    }

                    style.filter = ralpha.test( filter ) ?
                        filter.replace( ralpha, opacity ) :
                        filter + " " + opacity;
                }
            };
        }

        jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
            function( elem, computed ) {
                if ( computed ) {
                    return jQuery.swap( elem, { "display": "inline-block" },
                        curCSS, [ elem, "marginRight" ] );
                }
            }
        );

        jQuery.each({
            margin: "",
            padding: "",
            border: "Width"
        }, function( prefix, suffix ) {
            jQuery.cssHooks[ prefix + suffix ] = {
                expand: function( value ) {
                    var i = 0,
                        expanded = {},

                        // assumes a single number if not a string
                        parts = typeof value === "string" ? value.split(" ") : [ value ];

                    for ( ; i < 4; i++ ) {
                        expanded[ prefix + cssExpand[ i ] + suffix ] =
                            parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
                    }

                    return expanded;
                }
            };

            if ( !rmargin.test( prefix ) ) {
                jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
            }
        });

        jQuery.fn.extend({
            css: function( name, value ) {
                return access( this, function( elem, name, value ) {
                    var styles, len,
                        map = {},
                        i = 0;

                    if ( jQuery.isArray( name ) ) {
                        styles = getStyles( elem );
                        len = name.length;

                        for ( ; i < len; i++ ) {
                            map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
                        }

                        return map;
                    }

                    return value !== undefined ?
                        jQuery.style( elem, name, value ) :
                        jQuery.css( elem, name );
                }, name, value, arguments.length > 1 );
            },
            show: function() {
                return showHide( this, true );
            },
            hide: function() {
                return showHide( this );
            },
            toggle: function( state ) {
                if ( typeof state === "boolean" ) {
                    return state ? this.show() : this.hide();
                }

                return this.each(function() {
                    if ( isHidden( this ) ) {
                        jQuery( this ).show();
                    } else {
                        jQuery( this ).hide();
                    }
                });
            }
        });


        function Tween( elem, options, prop, end, easing ) {
            return new Tween.prototype.init( elem, options, prop, end, easing );
        }
        jQuery.Tween = Tween;

        Tween.prototype = {
            constructor: Tween,
            init: function( elem, options, prop, end, easing, unit ) {
                this.elem = elem;
                this.prop = prop;
                this.easing = easing || "swing";
                this.options = options;
                this.start = this.now = this.cur();
                this.end = end;
                this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
            },
            cur: function() {
                var hooks = Tween.propHooks[ this.prop ];

                return hooks && hooks.get ?
                    hooks.get( this ) :
                    Tween.propHooks._default.get( this );
            },
            run: function( percent ) {
                var eased,
                    hooks = Tween.propHooks[ this.prop ];

                if ( this.options.duration ) {
                    this.pos = eased = jQuery.easing[ this.easing ](
                        percent, this.options.duration * percent, 0, 1, this.options.duration
                    );
                } else {
                    this.pos = eased = percent;
                }
                this.now = ( this.end - this.start ) * eased + this.start;

                if ( this.options.step ) {
                    this.options.step.call( this.elem, this.now, this );
                }

                if ( hooks && hooks.set ) {
                    hooks.set( this );
                } else {
                    Tween.propHooks._default.set( this );
                }
                return this;
            }
        };

        Tween.prototype.init.prototype = Tween.prototype;

        Tween.propHooks = {
            _default: {
                get: function( tween ) {
                    var result;

                    if ( tween.elem[ tween.prop ] != null &&
                        (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
                        return tween.elem[ tween.prop ];
                    }

                    result = jQuery.css( tween.elem, tween.prop, "" );
                    return !result || result === "auto" ? 0 : result;
                },
                set: function( tween ) {
                    if ( jQuery.fx.step[ tween.prop ] ) {
                        jQuery.fx.step[ tween.prop ]( tween );
                    } else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
                        jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
                    } else {
                        tween.elem[ tween.prop ] = tween.now;
                    }
                }
            }
        };

        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
            set: function( tween ) {
                if ( tween.elem.nodeType && tween.elem.parentNode ) {
                    tween.elem[ tween.prop ] = tween.now;
                }
            }
        };

        jQuery.easing = {
            linear: function( p ) {
                return p;
            },
            swing: function( p ) {
                return 0.5 - Math.cos( p * Math.PI ) / 2;
            }
        };

        jQuery.fx = Tween.prototype.init;

        jQuery.fx.step = {};

        var fxNow, timerId,
            rfxtypes = /^(?:toggle|show|hide)$/,
            rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
            rrun = /queueHooks$/,
            animationPrefilters = [ defaultPrefilter ],
            tweeners = {
                "*": [ function( prop, value ) {
                    var tween = this.createTween( prop, value ),
                        target = tween.cur(),
                        parts = rfxnum.exec( value ),
                        unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

                        start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
                            rfxnum.exec( jQuery.css( tween.elem, prop ) ),
                        scale = 1,
                        maxIterations = 20;

                    if ( start && start[ 3 ] !== unit ) {
                        unit = unit || start[ 3 ];

                        parts = parts || [];

                        start = +target || 1;

                        do {
                            scale = scale || ".5";

                            start = start / scale;
                            jQuery.style( tween.elem, prop, start + unit );

                        } while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
                    }

                    if ( parts ) {
                        start = tween.start = +start || +target || 0;
                        tween.unit = unit;
                        tween.end = parts[ 1 ] ?
                            start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
                            +parts[ 2 ];
                    }

                    return tween;
                } ]
            };

        function createFxNow() {
            setTimeout(function() {
                fxNow = undefined;
            });
            return ( fxNow = jQuery.now() );
        }

        function genFx( type, includeWidth ) {
            var which,
                attrs = { height: type },
                i = 0;

            includeWidth = includeWidth ? 1 : 0;
            for ( ; i < 4 ; i += 2 - includeWidth ) {
                which = cssExpand[ i ];
                attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
            }

            if ( includeWidth ) {
                attrs.opacity = attrs.width = type;
            }

            return attrs;
        }

        function createTween( value, prop, animation ) {
            var tween,
                collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
                index = 0,
                length = collection.length;
            for ( ; index < length; index++ ) {
                if ( (tween = collection[ index ].call( animation, prop, value )) ) {

                    return tween;
                }
            }
        }

        function defaultPrefilter( elem, props, opts ) {
            var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
                anim = this,
                orig = {},
                style = elem.style,
                hidden = elem.nodeType && isHidden( elem ),
                dataShow = jQuery._data( elem, "fxshow" );

            if ( !opts.queue ) {
                hooks = jQuery._queueHooks( elem, "fx" );
                if ( hooks.unqueued == null ) {
                    hooks.unqueued = 0;
                    oldfire = hooks.empty.fire;
                    hooks.empty.fire = function() {
                        if ( !hooks.unqueued ) {
                            oldfire();
                        }
                    };
                }
                hooks.unqueued++;

                anim.always(function() {
                    anim.always(function() {
                        hooks.unqueued--;
                        if ( !jQuery.queue( elem, "fx" ).length ) {
                            hooks.empty.fire();
                        }
                    });
                });
            }

            if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
                opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

                display = jQuery.css( elem, "display" );

                checkDisplay = display === "none" ?
                    jQuery._data( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

                if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {

                    if ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === "inline" ) {
                        style.display = "inline-block";
                    } else {
                        style.zoom = 1;
                    }
                }
            }

            if ( opts.overflow ) {
                style.overflow = "hidden";
                if ( !support.shrinkWrapBlocks() ) {
                    anim.always(function() {
                        style.overflow = opts.overflow[ 0 ];
                        style.overflowX = opts.overflow[ 1 ];
                        style.overflowY = opts.overflow[ 2 ];
                    });
                }
            }

            for ( prop in props ) {
                value = props[ prop ];
                if ( rfxtypes.exec( value ) ) {
                    delete props[ prop ];
                    toggle = toggle || value === "toggle";
                    if ( value === ( hidden ? "hide" : "show" ) ) {
                        if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
                            hidden = true;
                        } else {
                            continue;
                        }
                    }
                    orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

                } else {
                    display = undefined;
                }
            }

            if ( !jQuery.isEmptyObject( orig ) ) {
                if ( dataShow ) {
                    if ( "hidden" in dataShow ) {
                        hidden = dataShow.hidden;
                    }
                } else {
                    dataShow = jQuery._data( elem, "fxshow", {} );
                }

                if ( toggle ) {
                    dataShow.hidden = !hidden;
                }
                if ( hidden ) {
                    jQuery( elem ).show();
                } else {
                    anim.done(function() {
                        jQuery( elem ).hide();
                    });
                }
                anim.done(function() {
                    var prop;
                    jQuery._removeData( elem, "fxshow" );
                    for ( prop in orig ) {
                        jQuery.style( elem, prop, orig[ prop ] );
                    }
                });
                for ( prop in orig ) {
                    tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

                    if ( !( prop in dataShow ) ) {
                        dataShow[ prop ] = tween.start;
                        if ( hidden ) {
                            tween.end = tween.start;
                            tween.start = prop === "width" || prop === "height" ? 1 : 0;
                        }
                    }
                }

            } else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
                style.display = display;
            }
        }

        function propFilter( props, specialEasing ) {
            var index, name, easing, value, hooks;

            for ( index in props ) {
                name = jQuery.camelCase( index );
                easing = specialEasing[ name ];
                value = props[ index ];
                if ( jQuery.isArray( value ) ) {
                    easing = value[ 1 ];
                    value = props[ index ] = value[ 0 ];
                }

                if ( index !== name ) {
                    props[ name ] = value;
                    delete props[ index ];
                }

                hooks = jQuery.cssHooks[ name ];
                if ( hooks && "expand" in hooks ) {
                    value = hooks.expand( value );
                    delete props[ name ];

                    for ( index in value ) {
                        if ( !( index in props ) ) {
                            props[ index ] = value[ index ];
                            specialEasing[ index ] = easing;
                        }
                    }
                } else {
                    specialEasing[ name ] = easing;
                }
            }
        }

        function Animation( elem, properties, options ) {
            var result,
                stopped,
                index = 0,
                length = animationPrefilters.length,
                deferred = jQuery.Deferred().always( function() {
                    delete tick.elem;
                }),
                tick = function() {
                    if ( stopped ) {
                        return false;
                    }
                    var currentTime = fxNow || createFxNow(),
                        remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
                        temp = remaining / animation.duration || 0,
                        percent = 1 - temp,
                        index = 0,
                        length = animation.tweens.length;

                    for ( ; index < length ; index++ ) {
                        animation.tweens[ index ].run( percent );
                    }

                    deferred.notifyWith( elem, [ animation, percent, remaining ]);

                    if ( percent < 1 && length ) {
                        return remaining;
                    } else {
                        deferred.resolveWith( elem, [ animation ] );
                        return false;
                    }
                },
                animation = deferred.promise({
                    elem: elem,
                    props: jQuery.extend( {}, properties ),
                    opts: jQuery.extend( true, { specialEasing: {} }, options ),
                    originalProperties: properties,
                    originalOptions: options,
                    startTime: fxNow || createFxNow(),
                    duration: options.duration,
                    tweens: [],
                    createTween: function( prop, end ) {
                        var tween = jQuery.Tween( elem, animation.opts, prop, end,
                            animation.opts.specialEasing[ prop ] || animation.opts.easing );
                        animation.tweens.push( tween );
                        return tween;
                    },
                    stop: function( gotoEnd ) {
                        var index = 0,
                            length = gotoEnd ? animation.tweens.length : 0;
                        if ( stopped ) {
                            return this;
                        }
                        stopped = true;
                        for ( ; index < length ; index++ ) {
                            animation.tweens[ index ].run( 1 );
                        }

                        if ( gotoEnd ) {
                            deferred.resolveWith( elem, [ animation, gotoEnd ] );
                        } else {
                            deferred.rejectWith( elem, [ animation, gotoEnd ] );
                        }
                        return this;
                    }
                }),
                props = animation.props;

            propFilter( props, animation.opts.specialEasing );

            for ( ; index < length ; index++ ) {
                result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
                if ( result ) {
                    return result;
                }
            }

            jQuery.map( props, createTween, animation );

            if ( jQuery.isFunction( animation.opts.start ) ) {
                animation.opts.start.call( elem, animation );
            }

            jQuery.fx.timer(
                jQuery.extend( tick, {
                    elem: elem,
                    anim: animation,
                    queue: animation.opts.queue
                })
            );

            return animation.progress( animation.opts.progress )
                .done( animation.opts.done, animation.opts.complete )
                .fail( animation.opts.fail )
                .always( animation.opts.always );
        }

        jQuery.Animation = jQuery.extend( Animation, {
            tweener: function( props, callback ) {
                if ( jQuery.isFunction( props ) ) {
                    callback = props;
                    props = [ "*" ];
                } else {
                    props = props.split(" ");
                }

                var prop,
                    index = 0,
                    length = props.length;

                for ( ; index < length ; index++ ) {
                    prop = props[ index ];
                    tweeners[ prop ] = tweeners[ prop ] || [];
                    tweeners[ prop ].unshift( callback );
                }
            },

            prefilter: function( callback, prepend ) {
                if ( prepend ) {
                    animationPrefilters.unshift( callback );
                } else {
                    animationPrefilters.push( callback );
                }
            }
        });

        jQuery.speed = function( speed, easing, fn ) {
            var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
                    complete: fn || !fn && easing ||
                    jQuery.isFunction( speed ) && speed,
                    duration: speed,
                    easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
                };

            opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
                    opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

            if ( opt.queue == null || opt.queue === true ) {
                opt.queue = "fx";
            }

            opt.old = opt.complete;

            opt.complete = function() {
                if ( jQuery.isFunction( opt.old ) ) {
                    opt.old.call( this );
                }

                if ( opt.queue ) {
                    jQuery.dequeue( this, opt.queue );
                }
            };

            return opt;
        };

        jQuery.fn.extend({
            fadeTo: function( speed, to, easing, callback ) {

                return this.filter( isHidden ).css( "opacity", 0 ).show()

                    .end().animate({ opacity: to }, speed, easing, callback );
            },
            animate: function( prop, speed, easing, callback ) {
                var empty = jQuery.isEmptyObject( prop ),
                    optall = jQuery.speed( speed, easing, callback ),
                    doAnimation = function() {
                        var anim = Animation( this, jQuery.extend( {}, prop ), optall );

                        if ( empty || jQuery._data( this, "finish" ) ) {
                            anim.stop( true );
                        }
                    };
                doAnimation.finish = doAnimation;

                return empty || optall.queue === false ?
                    this.each( doAnimation ) :
                    this.queue( optall.queue, doAnimation );
            },
            stop: function( type, clearQueue, gotoEnd ) {
                var stopQueue = function( hooks ) {
                    var stop = hooks.stop;
                    delete hooks.stop;
                    stop( gotoEnd );
                };

                if ( typeof type !== "string" ) {
                    gotoEnd = clearQueue;
                    clearQueue = type;
                    type = undefined;
                }
                if ( clearQueue && type !== false ) {
                    this.queue( type || "fx", [] );
                }

                return this.each(function() {
                    var dequeue = true,
                        index = type != null && type + "queueHooks",
                        timers = jQuery.timers,
                        data = jQuery._data( this );

                    if ( index ) {
                        if ( data[ index ] && data[ index ].stop ) {
                            stopQueue( data[ index ] );
                        }
                    } else {
                        for ( index in data ) {
                            if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
                                stopQueue( data[ index ] );
                            }
                        }
                    }

                    for ( index = timers.length; index--; ) {
                        if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
                            timers[ index ].anim.stop( gotoEnd );
                            dequeue = false;
                            timers.splice( index, 1 );
                        }
                    }

                    if ( dequeue || !gotoEnd ) {
                        jQuery.dequeue( this, type );
                    }
                });
            },
            finish: function( type ) {
                if ( type !== false ) {
                    type = type || "fx";
                }
                return this.each(function() {
                    var index,
                        data = jQuery._data( this ),
                        queue = data[ type + "queue" ],
                        hooks = data[ type + "queueHooks" ],
                        timers = jQuery.timers,
                        length = queue ? queue.length : 0;

                    data.finish = true;

                    jQuery.queue( this, type, [] );

                    if ( hooks && hooks.stop ) {
                        hooks.stop.call( this, true );
                    }

                    for ( index = timers.length; index--; ) {
                        if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
                            timers[ index ].anim.stop( true );
                            timers.splice( index, 1 );
                        }
                    }

                    for ( index = 0; index < length; index++ ) {
                        if ( queue[ index ] && queue[ index ].finish ) {
                            queue[ index ].finish.call( this );
                        }
                    }

                    delete data.finish;
                });
            }
        });

        jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
            var cssFn = jQuery.fn[ name ];
            jQuery.fn[ name ] = function( speed, easing, callback ) {
                return speed == null || typeof speed === "boolean" ?
                    cssFn.apply( this, arguments ) :
                    this.animate( genFx( name, true ), speed, easing, callback );
            };
        });

        jQuery.each({
            slideDown: genFx("show"),
            slideUp: genFx("hide"),
            slideToggle: genFx("toggle"),
            fadeIn: { opacity: "show" },
            fadeOut: { opacity: "hide" },
            fadeToggle: { opacity: "toggle" }
        }, function( name, props ) {
            jQuery.fn[ name ] = function( speed, easing, callback ) {
                return this.animate( props, speed, easing, callback );
            };
        });

        jQuery.timers = [];
        jQuery.fx.tick = function() {
            var timer,
                timers = jQuery.timers,
                i = 0;

            fxNow = jQuery.now();

            for ( ; i < timers.length; i++ ) {
                timer = timers[ i ];
                if ( !timer() && timers[ i ] === timer ) {
                    timers.splice( i--, 1 );
                }
            }

            if ( !timers.length ) {
                jQuery.fx.stop();
            }
            fxNow = undefined;
        };

        jQuery.fx.timer = function( timer ) {
            jQuery.timers.push( timer );
            if ( timer() ) {
                jQuery.fx.start();
            } else {
                jQuery.timers.pop();
            }
        };

        jQuery.fx.interval = 13;

        jQuery.fx.start = function() {
            if ( !timerId ) {
                timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
            }
        };

        jQuery.fx.stop = function() {
            clearInterval( timerId );
            timerId = null;
        };

        jQuery.fx.speeds = {
            slow: 600,
            fast: 200,
            // Default speed
            _default: 400
        };


        jQuery.fn.delay = function( time, type ) {
            time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
            type = type || "fx";

            return this.queue( type, function( next, hooks ) {
                var timeout = setTimeout( next, time );
                hooks.stop = function() {
                    clearTimeout( timeout );
                };
            });
        };


        (function() {
            var input, div, select, a, opt;

            div = document.createElement( "div" );
            div.setAttribute( "className", "t" );
            div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
            a = div.getElementsByTagName("a")[ 0 ];

            select = document.createElement("select");
            opt = select.appendChild( document.createElement("option") );
            input = div.getElementsByTagName("input")[ 0 ];

            a.style.cssText = "top:1px";

            support.getSetAttribute = div.className !== "t";

            support.style = /top/.test( a.getAttribute("style") );

            support.hrefNormalized = a.getAttribute("href") === "/a";

            support.checkOn = !!input.value;

            support.optSelected = opt.selected;

            support.enctype = !!document.createElement("form").enctype;

            select.disabled = true;
            support.optDisabled = !opt.disabled;

            input = document.createElement( "input" );
            input.setAttribute( "value", "" );
            support.input = input.getAttribute( "value" ) === "";

            input.value = "t";
            input.setAttribute( "type", "radio" );
            support.radioValue = input.value === "t";
        })();


        var rreturn = /\r/g;

        jQuery.fn.extend({
            val: function( value ) {
                var hooks, ret, isFunction,
                    elem = this[0];

                if ( !arguments.length ) {
                    if ( elem ) {
                        hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                        if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
                            return ret;
                        }

                        ret = elem.value;

                        return typeof ret === "string" ?
                            ret.replace(rreturn, "") :
                            ret == null ? "" : ret;
                    }

                    return;
                }

                isFunction = jQuery.isFunction( value );

                return this.each(function( i ) {
                    var val;

                    if ( this.nodeType !== 1 ) {
                        return;
                    }

                    if ( isFunction ) {
                        val = value.call( this, i, jQuery( this ).val() );
                    } else {
                        val = value;
                    }

                    if ( val == null ) {
                        val = "";
                    } else if ( typeof val === "number" ) {
                        val += "";
                    } else if ( jQuery.isArray( val ) ) {
                        val = jQuery.map( val, function( value ) {
                            return value == null ? "" : value + "";
                        });
                    }

                    hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

                    if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
                        this.value = val;
                    }
                });
            }
        });

        jQuery.extend({
            valHooks: {
                option: {
                    get: function( elem ) {
                        var val = jQuery.find.attr( elem, "value" );
                        return val != null ?
                            val :
                            jQuery.trim( jQuery.text( elem ) );
                    }
                },
                select: {
                    get: function( elem ) {
                        var value, option,
                            options = elem.options,
                            index = elem.selectedIndex,
                            one = elem.type === "select-one" || index < 0,
                            values = one ? null : [],
                            max = one ? index + 1 : options.length,
                            i = index < 0 ?
                                max :
                                one ? index : 0;

                        for ( ; i < max; i++ ) {
                            option = options[ i ];

                            if ( ( option.selected || i === index ) &&
                                ( support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
                                ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

                                value = jQuery( option ).val();

                                if ( one ) {
                                    return value;
                                }

                                values.push( value );
                            }
                        }

                        return values;
                    },

                    set: function( elem, value ) {
                        var optionSet, option,
                            options = elem.options,
                            values = jQuery.makeArray( value ),
                            i = options.length;

                        while ( i-- ) {
                            option = options[ i ];

                            if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) >= 0 ) {

                                try {
                                    option.selected = optionSet = true;

                                } catch ( _ ) {
                                    option.scrollHeight;
                                }

                            } else {
                                option.selected = false;
                            }
                        }

                        if ( !optionSet ) {
                            elem.selectedIndex = -1;
                        }

                        return options;
                    }
                }
            }
        });

        jQuery.each([ "radio", "checkbox" ], function() {
            jQuery.valHooks[ this ] = {
                set: function( elem, value ) {
                    if ( jQuery.isArray( value ) ) {
                        return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
                    }
                }
            };
            if ( !support.checkOn ) {
                jQuery.valHooks[ this ].get = function( elem ) {
                    return elem.getAttribute("value") === null ? "on" : elem.value;
                };
            }
        });

        var nodeHook, boolHook,
            attrHandle = jQuery.expr.attrHandle,
            ruseDefault = /^(?:checked|selected)$/i,
            getSetAttribute = support.getSetAttribute,
            getSetInput = support.input;

        jQuery.fn.extend({
            attr: function( name, value ) {
                return access( this, jQuery.attr, name, value, arguments.length > 1 );
            },

            removeAttr: function( name ) {
                return this.each(function() {
                    jQuery.removeAttr( this, name );
                });
            }
        });

        jQuery.extend({
            attr: function( elem, name, value ) {
                var hooks, ret,
                    nType = elem.nodeType;

                if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                    return;
                }

                if ( typeof elem.getAttribute === strundefined ) {
                    return jQuery.prop( elem, name, value );
                }

                if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
                    name = name.toLowerCase();
                    hooks = jQuery.attrHooks[ name ] ||
                        ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
                }

                if ( value !== undefined ) {

                    if ( value === null ) {
                        jQuery.removeAttr( elem, name );

                    } else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
                        return ret;

                    } else {
                        elem.setAttribute( name, value + "" );
                        return value;
                    }

                } else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
                    return ret;

                } else {
                    ret = jQuery.find.attr( elem, name );

                    return ret == null ?
                        undefined :
                        ret;
                }
            },

            removeAttr: function( elem, value ) {
                var name, propName,
                    i = 0,
                    attrNames = value && value.match( rnotwhite );

                if ( attrNames && elem.nodeType === 1 ) {
                    while ( (name = attrNames[i++]) ) {
                        propName = jQuery.propFix[ name ] || name;

                        if ( jQuery.expr.match.bool.test( name ) ) {
                            if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
                                elem[ propName ] = false;
                            } else {
                                elem[ jQuery.camelCase( "default-" + name ) ] =
                                    elem[ propName ] = false;
                            }

                        } else {
                            jQuery.attr( elem, name, "" );
                        }

                        elem.removeAttribute( getSetAttribute ? name : propName );
                    }
                }
            },

            attrHooks: {
                type: {
                    set: function( elem, value ) {
                        if ( !support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
                            var val = elem.value;
                            elem.setAttribute( "type", value );
                            if ( val ) {
                                elem.value = val;
                            }
                            return value;
                        }
                    }
                }
            }
        });

        boolHook = {
            set: function( elem, value, name ) {
                if ( value === false ) {
                    jQuery.removeAttr( elem, name );
                } else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
                    elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );
                } else {
                    elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
                }

                return name;
            }
        };

        jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {

            var getter = attrHandle[ name ] || jQuery.find.attr;

            attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?
                function( elem, name, isXML ) {
                    var ret, handle;
                    if ( !isXML ) {
                        handle = attrHandle[ name ];
                        attrHandle[ name ] = ret;
                        ret = getter( elem, name, isXML ) != null ?
                            name.toLowerCase() :
                            null;
                        attrHandle[ name ] = handle;
                    }
                    return ret;
                } :
                function( elem, name, isXML ) {
                    if ( !isXML ) {
                        return elem[ jQuery.camelCase( "default-" + name ) ] ?
                            name.toLowerCase() :
                            null;
                    }
                };
        });

        if ( !getSetInput || !getSetAttribute ) {
            jQuery.attrHooks.value = {
                set: function( elem, value, name ) {
                    if ( jQuery.nodeName( elem, "input" ) ) {
                        elem.defaultValue = value;
                    } else {
                        return nodeHook && nodeHook.set( elem, value, name );
                    }
                }
            };
        }

        if ( !getSetAttribute ) {
            nodeHook = {
                set: function( elem, value, name ) {
                    var ret = elem.getAttributeNode( name );
                    if ( !ret ) {
                        elem.setAttributeNode(
                            (ret = elem.ownerDocument.createAttribute( name ))
                        );
                    }

                    ret.value = value += "";

                    if ( name === "value" || value === elem.getAttribute( name ) ) {
                        return value;
                    }
                }
            };

            attrHandle.id = attrHandle.name = attrHandle.coords =
                function( elem, name, isXML ) {
                    var ret;
                    if ( !isXML ) {
                        return (ret = elem.getAttributeNode( name )) && ret.value !== "" ?
                            ret.value :
                            null;
                    }
                };

            jQuery.valHooks.button = {
                get: function( elem, name ) {
                    var ret = elem.getAttributeNode( name );
                    if ( ret && ret.specified ) {
                        return ret.value;
                    }
                },
                set: nodeHook.set
            };

            jQuery.attrHooks.contenteditable = {
                set: function( elem, value, name ) {
                    nodeHook.set( elem, value === "" ? false : value, name );
                }
            };

            jQuery.each([ "width", "height" ], function( i, name ) {
                jQuery.attrHooks[ name ] = {
                    set: function( elem, value ) {
                        if ( value === "" ) {
                            elem.setAttribute( name, "auto" );
                            return value;
                        }
                    }
                };
            });
        }

        if ( !support.style ) {
            jQuery.attrHooks.style = {
                get: function( elem ) {
                    return elem.style.cssText || undefined;
                },
                set: function( elem, value ) {
                    return ( elem.style.cssText = value + "" );
                }
            };
        }

        var rfocusable = /^(?:input|select|textarea|button|object)$/i,
            rclickable = /^(?:a|area)$/i;

        jQuery.fn.extend({
            prop: function( name, value ) {
                return access( this, jQuery.prop, name, value, arguments.length > 1 );
            },

            removeProp: function( name ) {
                name = jQuery.propFix[ name ] || name;
                return this.each(function() {
                    try {
                        this[ name ] = undefined;
                        delete this[ name ];
                    } catch( e ) {}
                });
            }
        });

        jQuery.extend({
            propFix: {
                "for": "htmlFor",
                "class": "className"
            },

            prop: function( elem, name, value ) {
                var ret, hooks, notxml,
                    nType = elem.nodeType;

                if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                    return;
                }

                notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

                if ( notxml ) {
                    name = jQuery.propFix[ name ] || name;
                    hooks = jQuery.propHooks[ name ];
                }

                if ( value !== undefined ) {
                    return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
                        ret :
                        ( elem[ name ] = value );

                } else {
                    return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
                        ret :
                        elem[ name ];
                }
            },

            propHooks: {
                tabIndex: {
                    get: function( elem ) {
                        var tabindex = jQuery.find.attr( elem, "tabindex" );

                        return tabindex ?
                            parseInt( tabindex, 10 ) :
                            rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
                                0 :
                                -1;
                    }
                }
            }
        });

        if ( !support.hrefNormalized ) {
            jQuery.each([ "href", "src" ], function( i, name ) {
                jQuery.propHooks[ name ] = {
                    get: function( elem ) {
                        return elem.getAttribute( name, 4 );
                    }
                };
            });
        }

        if ( !support.optSelected ) {
            jQuery.propHooks.selected = {
                get: function( elem ) {
                    var parent = elem.parentNode;

                    if ( parent ) {
                        parent.selectedIndex;

                        if ( parent.parentNode ) {
                            parent.parentNode.selectedIndex;
                        }
                    }
                    return null;
                }
            };
        }

        jQuery.each([
            "tabIndex",
            "readOnly",
            "maxLength",
            "cellSpacing",
            "cellPadding",
            "rowSpan",
            "colSpan",
            "useMap",
            "frameBorder",
            "contentEditable"
        ], function() {
            jQuery.propFix[ this.toLowerCase() ] = this;
        });

        if ( !support.enctype ) {
            jQuery.propFix.enctype = "encoding";
        }

        var rclass = /[\t\r\n\f]/g;

        jQuery.fn.extend({
            addClass: function( value ) {
                var classes, elem, cur, clazz, j, finalValue,
                    i = 0,
                    len = this.length,
                    proceed = typeof value === "string" && value;

                if ( jQuery.isFunction( value ) ) {
                    return this.each(function( j ) {
                        jQuery( this ).addClass( value.call( this, j, this.className ) );
                    });
                }

                if ( proceed ) {
                    classes = ( value || "" ).match( rnotwhite ) || [];

                    for ( ; i < len; i++ ) {
                        elem = this[ i ];
                        cur = elem.nodeType === 1 && ( elem.className ?
                                    ( " " + elem.className + " " ).replace( rclass, " " ) :
                                    " "
                            );

                        if ( cur ) {
                            j = 0;
                            while ( (clazz = classes[j++]) ) {
                                if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
                                    cur += clazz + " ";
                                }
                            }

                            finalValue = jQuery.trim( cur );
                            if ( elem.className !== finalValue ) {
                                elem.className = finalValue;
                            }
                        }
                    }
                }

                return this;
            },

            removeClass: function( value ) {
                var classes, elem, cur, clazz, j, finalValue,
                    i = 0,
                    len = this.length,
                    proceed = arguments.length === 0 || typeof value === "string" && value;

                if ( jQuery.isFunction( value ) ) {
                    return this.each(function( j ) {
                        jQuery( this ).removeClass( value.call( this, j, this.className ) );
                    });
                }
                if ( proceed ) {
                    classes = ( value || "" ).match( rnotwhite ) || [];

                    for ( ; i < len; i++ ) {
                        elem = this[ i ];
                        cur = elem.nodeType === 1 && ( elem.className ?
                                    ( " " + elem.className + " " ).replace( rclass, " " ) :
                                    ""
                            );

                        if ( cur ) {
                            j = 0;
                            while ( (clazz = classes[j++]) ) {
                                while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
                                    cur = cur.replace( " " + clazz + " ", " " );
                                }
                            }

                            finalValue = value ? jQuery.trim( cur ) : "";
                            if ( elem.className !== finalValue ) {
                                elem.className = finalValue;
                            }
                        }
                    }
                }

                return this;
            },

            toggleClass: function( value, stateVal ) {
                var type = typeof value;

                if ( typeof stateVal === "boolean" && type === "string" ) {
                    return stateVal ? this.addClass( value ) : this.removeClass( value );
                }

                if ( jQuery.isFunction( value ) ) {
                    return this.each(function( i ) {
                        jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
                    });
                }

                return this.each(function() {
                    if ( type === "string" ) {
                        var className,
                            i = 0,
                            self = jQuery( this ),
                            classNames = value.match( rnotwhite ) || [];

                        while ( (className = classNames[ i++ ]) ) {
                            if ( self.hasClass( className ) ) {
                                self.removeClass( className );
                            } else {
                                self.addClass( className );
                            }
                        }

                    } else if ( type === strundefined || type === "boolean" ) {
                        if ( this.className ) {
                            jQuery._data( this, "__className__", this.className );
                        }

                        this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
                    }
                });
            },

            hasClass: function( selector ) {
                var className = " " + selector + " ",
                    i = 0,
                    l = this.length;
                for ( ; i < l; i++ ) {
                    if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
                        return true;
                    }
                }

                return false;
            }
        });

        jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

            // Handle event binding
            jQuery.fn[ name ] = function( data, fn ) {
                return arguments.length > 0 ?
                    this.on( name, null, data, fn ) :
                    this.trigger( name );
            };
        });

        jQuery.fn.extend({
            hover: function( fnOver, fnOut ) {
                return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
            },

            bind: function( types, data, fn ) {
                return this.on( types, null, data, fn );
            },
            unbind: function( types, fn ) {
                return this.off( types, null, fn );
            },

            delegate: function( selector, types, data, fn ) {
                return this.on( types, selector, data, fn );
            },
            undelegate: function( selector, types, fn ) {
                // ( namespace ) or ( selector, types [, fn] )
                return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
            }
        });


        var nonce = jQuery.now();

        var rquery = (/\?/);

        var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

        jQuery.parseJSON = function( data ) {
            if ( window.JSON && window.JSON.parse ) {
                return window.JSON.parse( data + "" );
            }

            var requireNonComma,
                depth = null,
                str = jQuery.trim( data + "" );

            return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {

                if ( requireNonComma && comma ) {
                    depth = 0;
                }

                if ( depth === 0 ) {
                    return token;
                }

                requireNonComma = open || comma;

                depth += !close - !open;

                return "";
            }) ) ?
                ( Function( "return " + str ) )() :
                jQuery.error( "Invalid JSON: " + data );
        };


        jQuery.parseXML = function( data ) {
            var xml, tmp;
            if ( !data || typeof data !== "string" ) {
                return null;
            }
            try {
                if ( window.DOMParser ) { // Standard
                    tmp = new DOMParser();
                    xml = tmp.parseFromString( data, "text/xml" );
                } else { // IE
                    xml = new ActiveXObject( "Microsoft.XMLDOM" );
                    xml.async = "false";
                    xml.loadXML( data );
                }
            } catch( e ) {
                xml = undefined;
            }
            if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
                jQuery.error( "Invalid XML: " + data );
            }
            return xml;
        };


        var ajaxLocParts,
            ajaxLocation,

            rhash = /#.*$/,
            rts = /([?&])_=[^&]*/,
            rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
            rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
            rnoContent = /^(?:GET|HEAD)$/,
            rprotocol = /^\/\//,
            rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

            prefilters = {},
            transports = {},

            allTypes = "*/".concat("*");

        try {
            ajaxLocation = location.href;
        } catch( e ) {
            ajaxLocation = document.createElement( "a" );
            ajaxLocation.href = "";
            ajaxLocation = ajaxLocation.href;
        }

        ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

        function addToPrefiltersOrTransports( structure ) {

            return function( dataTypeExpression, func ) {

                if ( typeof dataTypeExpression !== "string" ) {
                    func = dataTypeExpression;
                    dataTypeExpression = "*";
                }

                var dataType,
                    i = 0,
                    dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

                if ( jQuery.isFunction( func ) ) {
                    while ( (dataType = dataTypes[i++]) ) {
                        if ( dataType.charAt( 0 ) === "+" ) {
                            dataType = dataType.slice( 1 ) || "*";
                            (structure[ dataType ] = structure[ dataType ] || []).unshift( func );

                        } else {
                            (structure[ dataType ] = structure[ dataType ] || []).push( func );
                        }
                    }
                }
            };
        }

        function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

            var inspected = {},
                seekingTransport = ( structure === transports );

            function inspect( dataType ) {
                var selected;
                inspected[ dataType ] = true;
                jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
                    var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
                    if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
                        options.dataTypes.unshift( dataTypeOrTransport );
                        inspect( dataTypeOrTransport );
                        return false;
                    } else if ( seekingTransport ) {
                        return !( selected = dataTypeOrTransport );
                    }
                });
                return selected;
            }

            return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
        }

        function ajaxExtend( target, src ) {
            var deep, key,
                flatOptions = jQuery.ajaxSettings.flatOptions || {};

            for ( key in src ) {
                if ( src[ key ] !== undefined ) {
                    ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
                }
            }
            if ( deep ) {
                jQuery.extend( true, target, deep );
            }

            return target;
        }

        function ajaxHandleResponses( s, jqXHR, responses ) {
            var firstDataType, ct, finalDataType, type,
                contents = s.contents,
                dataTypes = s.dataTypes;

            while ( dataTypes[ 0 ] === "*" ) {
                dataTypes.shift();
                if ( ct === undefined ) {
                    ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
                }
            }

            if ( ct ) {
                for ( type in contents ) {
                    if ( contents[ type ] && contents[ type ].test( ct ) ) {
                        dataTypes.unshift( type );
                        break;
                    }
                }
            }

            if ( dataTypes[ 0 ] in responses ) {
                finalDataType = dataTypes[ 0 ];
            } else {
                for ( type in responses ) {
                    if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
                        finalDataType = type;
                        break;
                    }
                    if ( !firstDataType ) {
                        firstDataType = type;
                    }
                }
                finalDataType = finalDataType || firstDataType;
            }

            if ( finalDataType ) {
                if ( finalDataType !== dataTypes[ 0 ] ) {
                    dataTypes.unshift( finalDataType );
                }
                return responses[ finalDataType ];
            }
        }

        function ajaxConvert( s, response, jqXHR, isSuccess ) {
            var conv2, current, conv, tmp, prev,
                converters = {},
                dataTypes = s.dataTypes.slice();

            if ( dataTypes[ 1 ] ) {
                for ( conv in s.converters ) {
                    converters[ conv.toLowerCase() ] = s.converters[ conv ];
                }
            }

            current = dataTypes.shift();

            while ( current ) {

                if ( s.responseFields[ current ] ) {
                    jqXHR[ s.responseFields[ current ] ] = response;
                }

                if ( !prev && isSuccess && s.dataFilter ) {
                    response = s.dataFilter( response, s.dataType );
                }

                prev = current;
                current = dataTypes.shift();

                if ( current ) {
                    if ( current === "*" ) {
                        current = prev;

                    } else if ( prev !== "*" && prev !== current ) {

                        conv = converters[ prev + " " + current ] || converters[ "* " + current ];

                        if ( !conv ) {
                            for ( conv2 in converters ) {

                                tmp = conv2.split( " " );
                                if ( tmp[ 1 ] === current ) {

                                    conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                        converters[ "* " + tmp[ 0 ] ];
                                    if ( conv ) {
                                        if ( conv === true ) {
                                            conv = converters[ conv2 ];

                                        } else if ( converters[ conv2 ] !== true ) {
                                            current = tmp[ 0 ];
                                            dataTypes.unshift( tmp[ 1 ] );
                                        }
                                        break;
                                    }
                                }
                            }
                        }

                        if ( conv !== true ) {

                            if ( conv && s[ "throws" ] ) {
                                response = conv( response );
                            } else {
                                try {
                                    response = conv( response );
                                } catch ( e ) {
                                    return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
                                }
                            }
                        }
                    }
                }
            }

            return { state: "success", data: response };
        }

        jQuery.extend({

            active: 0,

            lastModified: {},
            etag: {},

            ajaxSettings: {
                url: ajaxLocation,
                type: "GET",
                isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
                global: true,
                processData: true,
                async: true,
                contentType: "application/x-www-form-urlencoded; charset=UTF-8",

                accepts: {
                    "*": allTypes,
                    text: "text/plain",
                    html: "text/html",
                    xml: "application/xml, text/xml",
                    json: "application/json, text/javascript"
                },

                contents: {
                    xml: /xml/,
                    html: /html/,
                    json: /json/
                },

                responseFields: {
                    xml: "responseXML",
                    text: "responseText",
                    json: "responseJSON"
                },

                converters: {
                    "* text": String,
                    "text html": true,
                    "text json": jQuery.parseJSON,
                    "text xml": jQuery.parseXML
                },

                flatOptions: {
                    url: true,
                    context: true
                }
            },

            ajaxSetup: function( target, settings ) {
                return settings ?
                    ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
                    ajaxExtend( jQuery.ajaxSettings, target );
            },

            ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
            ajaxTransport: addToPrefiltersOrTransports( transports ),

            ajax: function( url, options ) {

                if ( typeof url === "object" ) {
                    options = url;
                    url = undefined;
                }

                options = options || {};

                var parts,
                    i,
                    cacheURL,
                    responseHeadersString,
                    timeoutTimer,
                    fireGlobals,
                    transport,
                    responseHeaders,
                    s = jQuery.ajaxSetup( {}, options ),
                    callbackContext = s.context || s,
                    globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
                        jQuery( callbackContext ) :
                        jQuery.event,
                    deferred = jQuery.Deferred(),
                    completeDeferred = jQuery.Callbacks("once memory"),
                    statusCode = s.statusCode || {},
                    requestHeaders = {},
                    requestHeadersNames = {},
                    state = 0,
                    strAbort = "canceled",
                    jqXHR = {
                        readyState: 0,

                        getResponseHeader: function( key ) {
                            var match;
                            if ( state === 2 ) {
                                if ( !responseHeaders ) {
                                    responseHeaders = {};
                                    while ( (match = rheaders.exec( responseHeadersString )) ) {
                                        responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
                                    }
                                }
                                match = responseHeaders[ key.toLowerCase() ];
                            }
                            return match == null ? null : match;
                        },

                        getAllResponseHeaders: function() {
                            return state === 2 ? responseHeadersString : null;
                        },

                        setRequestHeader: function( name, value ) {
                            var lname = name.toLowerCase();
                            if ( !state ) {
                                name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                                requestHeaders[ name ] = value;
                            }
                            return this;
                        },

                        overrideMimeType: function( type ) {
                            if ( !state ) {
                                s.mimeType = type;
                            }
                            return this;
                        },

                        statusCode: function( map ) {
                            var code;
                            if ( map ) {
                                if ( state < 2 ) {
                                    for ( code in map ) {
                                        statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                                    }
                                } else {
                                    jqXHR.always( map[ jqXHR.status ] );
                                }
                            }
                            return this;
                        },

                        abort: function( statusText ) {
                            var finalText = statusText || strAbort;
                            if ( transport ) {
                                transport.abort( finalText );
                            }
                            done( 0, finalText );
                            return this;
                        }
                    };

                deferred.promise( jqXHR ).complete = completeDeferred.add;
                jqXHR.success = jqXHR.done;
                jqXHR.error = jqXHR.fail;

                s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

                s.type = options.method || options.type || s.method || s.type;

                s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

                if ( s.crossDomain == null ) {
                    parts = rurl.exec( s.url.toLowerCase() );
                    s.crossDomain = !!( parts &&
                        ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                        ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
                        ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
                    );
                }

                if ( s.data && s.processData && typeof s.data !== "string" ) {
                    s.data = jQuery.param( s.data, s.traditional );
                }

                inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

                if ( state === 2 ) {
                    return jqXHR;
                }

                fireGlobals = jQuery.event && s.global;

                if ( fireGlobals && jQuery.active++ === 0 ) {
                    jQuery.event.trigger("ajaxStart");
                }

                s.type = s.type.toUpperCase();

                s.hasContent = !rnoContent.test( s.type );

                cacheURL = s.url;

                if ( !s.hasContent ) {

                    if ( s.data ) {
                        cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
                        delete s.data;
                    }

                    if ( s.cache === false ) {
                        s.url = rts.test( cacheURL ) ?
                            cacheURL.replace( rts, "$1_=" + nonce++ ) :

                            cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
                    }
                }

                if ( s.ifModified ) {
                    if ( jQuery.lastModified[ cacheURL ] ) {
                        jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
                    }
                    if ( jQuery.etag[ cacheURL ] ) {
                        jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
                    }
                }

                if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
                    jqXHR.setRequestHeader( "Content-Type", s.contentType );
                }

                jqXHR.setRequestHeader(
                    "Accept",
                    s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
                        s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                        s.accepts[ "*" ]
                );

                for ( i in s.headers ) {
                    jqXHR.setRequestHeader( i, s.headers[ i ] );
                }

                if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
                    // Abort if not done already and return
                    return jqXHR.abort();
                }

                strAbort = "abort";

                for ( i in { success: 1, error: 1, complete: 1 } ) {
                    jqXHR[ i ]( s[ i ] );
                }

                transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

                if ( !transport ) {
                    done( -1, "No Transport" );
                } else {
                    jqXHR.readyState = 1;

                    if ( fireGlobals ) {
                        globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
                    }
                    if ( s.timeout > 0 ) {
                        timeoutTimer = setTimeout(function() {
                            jqXHR.abort("timeout");
                        }, s.timeout );
                    }

                    try {
                        state = 1;
                        transport.send( requestHeaders, done );
                    } catch ( e ) {
                        if ( state < 2 ) {
                            done( -1, e );
                        } else {
                            throw e;
                        }
                    }
                }

                function done( status, nativeStatusText, responses, headers ) {
                    var isSuccess, success, error, response, modified,
                        statusText = nativeStatusText;

                    if ( state === 2 ) {
                        return;
                    }

                    state = 2;

                    if ( timeoutTimer ) {
                        clearTimeout( timeoutTimer );
                    }

                    transport = undefined;

                    responseHeadersString = headers || "";

                    jqXHR.readyState = status > 0 ? 4 : 0;

                    isSuccess = status >= 200 && status < 300 || status === 304;

                    if ( responses ) {
                        response = ajaxHandleResponses( s, jqXHR, responses );
                    }

                    response = ajaxConvert( s, response, jqXHR, isSuccess );

                    if ( isSuccess ) {

                        if ( s.ifModified ) {
                            modified = jqXHR.getResponseHeader("Last-Modified");
                            if ( modified ) {
                                jQuery.lastModified[ cacheURL ] = modified;
                            }
                            modified = jqXHR.getResponseHeader("etag");
                            if ( modified ) {
                                jQuery.etag[ cacheURL ] = modified;
                            }
                        }

                        // if no content
                        if ( status === 204 || s.type === "HEAD" ) {
                            statusText = "nocontent";

                            // if not modified
                        } else if ( status === 304 ) {
                            statusText = "notmodified";

                            // If we have data, let's convert it
                        } else {
                            statusText = response.state;
                            success = response.data;
                            error = response.error;
                            isSuccess = !error;
                        }
                    } else {
                        error = statusText;
                        if ( status || !statusText ) {
                            statusText = "error";
                            if ( status < 0 ) {
                                status = 0;
                            }
                        }
                    }

                    // Set data for the fake xhr object
                    jqXHR.status = status;
                    jqXHR.statusText = ( nativeStatusText || statusText ) + "";

                    // Success/Error
                    if ( isSuccess ) {
                        deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                    } else {
                        deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                    }

                    // Status-dependent callbacks
                    jqXHR.statusCode( statusCode );
                    statusCode = undefined;

                    if ( fireGlobals ) {
                        globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
                            [ jqXHR, s, isSuccess ? success : error ] );
                    }

                    // Complete
                    completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

                    if ( fireGlobals ) {
                        globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
                        // Handle the global AJAX counter
                        if ( !( --jQuery.active ) ) {
                            jQuery.event.trigger("ajaxStop");
                        }
                    }
                }

                return jqXHR;
            },

            getJSON: function( url, data, callback ) {
                return jQuery.get( url, data, callback, "json" );
            },

            getScript: function( url, callback ) {
                return jQuery.get( url, undefined, callback, "script" );
            }
        });

        jQuery.each( [ "get", "post" ], function( i, method ) {
            jQuery[ method ] = function( url, data, callback, type ) {
                // shift arguments if data argument was omitted
                if ( jQuery.isFunction( data ) ) {
                    type = type || callback;
                    callback = data;
                    data = undefined;
                }

                return jQuery.ajax({
                    url: url,
                    type: method,
                    dataType: type,
                    data: data,
                    success: callback
                });
            };
        });


        jQuery._evalUrl = function( url ) {
            return jQuery.ajax({
                url: url,
                type: "GET",
                dataType: "script",
                async: false,
                global: false,
                "throws": true
            });
        };


        jQuery.fn.extend({
            wrapAll: function( html ) {
                if ( jQuery.isFunction( html ) ) {
                    return this.each(function(i) {
                        jQuery(this).wrapAll( html.call(this, i) );
                    });
                }

                if ( this[0] ) {
                    // The elements to wrap the target around
                    var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

                    if ( this[0].parentNode ) {
                        wrap.insertBefore( this[0] );
                    }

                    wrap.map(function() {
                        var elem = this;

                        while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
                            elem = elem.firstChild;
                        }

                        return elem;
                    }).append( this );
                }

                return this;
            },

            wrapInner: function( html ) {
                if ( jQuery.isFunction( html ) ) {
                    return this.each(function(i) {
                        jQuery(this).wrapInner( html.call(this, i) );
                    });
                }

                return this.each(function() {
                    var self = jQuery( this ),
                        contents = self.contents();

                    if ( contents.length ) {
                        contents.wrapAll( html );

                    } else {
                        self.append( html );
                    }
                });
            },

            wrap: function( html ) {
                var isFunction = jQuery.isFunction( html );

                return this.each(function(i) {
                    jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
                });
            },

            unwrap: function() {
                return this.parent().each(function() {
                    if ( !jQuery.nodeName( this, "body" ) ) {
                        jQuery( this ).replaceWith( this.childNodes );
                    }
                }).end();
            }
        });


        jQuery.expr.filters.hidden = function( elem ) {
            return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
                (!support.reliableHiddenOffsets() &&
                ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
        };

        jQuery.expr.filters.visible = function( elem ) {
            return !jQuery.expr.filters.hidden( elem );
        };




        var r20 = /%20/g,
            rbracket = /\[\]$/,
            rCRLF = /\r?\n/g,
            rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
            rsubmittable = /^(?:input|select|textarea|keygen)/i;

        function buildParams( prefix, obj, traditional, add ) {
            var name;

            if ( jQuery.isArray( obj ) ) {
                // Serialize array item.
                jQuery.each( obj, function( i, v ) {
                    if ( traditional || rbracket.test( prefix ) ) {
                        // Treat each array item as a scalar.
                        add( prefix, v );

                    } else {
                        // Item is non-scalar (array or object), encode its numeric index.
                        buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
                    }
                });

            } else if ( !traditional && jQuery.type( obj ) === "object" ) {
                // Serialize object item.
                for ( name in obj ) {
                    buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
                }

            } else {
                // Serialize scalar item.
                add( prefix, obj );
            }
        }

        jQuery.param = function( a, traditional ) {
            var prefix,
                s = [],
                add = function( key, value ) {
                    value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
                    s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
                };

            if ( traditional === undefined ) {
                traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
            }

            if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
                // Serialize the form elements
                jQuery.each( a, function() {
                    add( this.name, this.value );
                });

            } else {
                for ( prefix in a ) {
                    buildParams( prefix, a[ prefix ], traditional, add );
                }
            }

            // Return the resulting serialization
            return s.join( "&" ).replace( r20, "+" );
        };

        jQuery.fn.extend({
            serialize: function() {
                return jQuery.param( this.serializeArray() );
            },
            serializeArray: function() {
                return this.map(function() {
                    // Can add propHook for "elements" to filter or add form elements
                    var elements = jQuery.prop( this, "elements" );
                    return elements ? jQuery.makeArray( elements ) : this;
                })
                    .filter(function() {
                        var type = this.type;
                        // Use .is(":disabled") so that fieldset[disabled] works
                        return this.name && !jQuery( this ).is( ":disabled" ) &&
                            rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
                            ( this.checked || !rcheckableType.test( type ) );
                    })
                    .map(function( i, elem ) {
                        var val = jQuery( this ).val();

                        return val == null ?
                            null :
                            jQuery.isArray( val ) ?
                                jQuery.map( val, function( val ) {
                                    return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                                }) :
                                { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                    }).get();
            }
        });

        jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?
            // Support: IE6+
            function() {

                return !this.isLocal &&

                    /^(get|post|head|put|delete|options)$/i.test( this.type ) &&

                    createStandardXHR() || createActiveXHR();
            } :
            createStandardXHR;

        var xhrId = 0,
            xhrCallbacks = {},
            xhrSupported = jQuery.ajaxSettings.xhr();

        if ( window.attachEvent ) {
            window.attachEvent( "onunload", function() {
                for ( var key in xhrCallbacks ) {
                    xhrCallbacks[ key ]( undefined, true );
                }
            });
        }

        support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
        xhrSupported = support.ajax = !!xhrSupported;

        if ( xhrSupported ) {

            jQuery.ajaxTransport(function( options ) {
                if ( !options.crossDomain || support.cors ) {

                    var callback;

                    return {
                        send: function( headers, complete ) {
                            var i,
                                xhr = options.xhr(),
                                id = ++xhrId;

                            xhr.open( options.type, options.url, options.async, options.username, options.password );

                            if ( options.xhrFields ) {
                                for ( i in options.xhrFields ) {
                                    xhr[ i ] = options.xhrFields[ i ];
                                }
                            }

                            if ( options.mimeType && xhr.overrideMimeType ) {
                                xhr.overrideMimeType( options.mimeType );
                            }

                            if ( !options.crossDomain && !headers["X-Requested-With"] ) {
                                headers["X-Requested-With"] = "XMLHttpRequest";
                            }

                            // Set headers
                            for ( i in headers ) {
                                if ( headers[ i ] !== undefined ) {
                                    xhr.setRequestHeader( i, headers[ i ] + "" );
                                }
                            }

                            xhr.send( ( options.hasContent && options.data ) || null );

                            callback = function( _, isAbort ) {
                                var status, statusText, responses;

                                if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
                                    delete xhrCallbacks[ id ];
                                    callback = undefined;
                                    xhr.onreadystatechange = jQuery.noop;

                                    if ( isAbort ) {
                                        if ( xhr.readyState !== 4 ) {
                                            xhr.abort();
                                        }
                                    } else {
                                        responses = {};
                                        status = xhr.status;

                                        if ( typeof xhr.responseText === "string" ) {
                                            responses.text = xhr.responseText;
                                        }

                                        try {
                                            statusText = xhr.statusText;
                                        } catch( e ) {
                                            statusText = "";
                                        }

                                        if ( !status && options.isLocal && !options.crossDomain ) {
                                            status = responses.text ? 200 : 404;
                                        } else if ( status === 1223 ) {
                                            status = 204;
                                        }
                                    }
                                }

                                // Call complete if needed
                                if ( responses ) {
                                    complete( status, statusText, responses, xhr.getAllResponseHeaders() );
                                }
                            };

                            if ( !options.async ) {
                                callback();
                            } else if ( xhr.readyState === 4 ) {
                                setTimeout( callback );
                            } else {
                                xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
                            }
                        },

                        abort: function() {
                            if ( callback ) {
                                callback( undefined, true );
                            }
                        }
                    };
                }
            });
        }

// Functions to create xhrs
        function createStandardXHR() {
            try {
                return new window.XMLHttpRequest();
            } catch( e ) {}
        }

        function createActiveXHR() {
            try {
                return new window.ActiveXObject( "Microsoft.XMLHTTP" );
            } catch( e ) {}
        }

        jQuery.ajaxSetup({
            accepts: {
                script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
            },
            contents: {
                script: /(?:java|ecma)script/
            },
            converters: {
                "text script": function( text ) {
                    jQuery.globalEval( text );
                    return text;
                }
            }
        });

        jQuery.ajaxPrefilter( "script", function( s ) {
            if ( s.cache === undefined ) {
                s.cache = false;
            }
            if ( s.crossDomain ) {
                s.type = "GET";
                s.global = false;
            }
        });

        jQuery.ajaxTransport( "script", function(s) {

            // This transport only deals with cross domain requests
            if ( s.crossDomain ) {

                var script,
                    head = document.head || jQuery("head")[0] || document.documentElement;

                return {

                    send: function( _, callback ) {

                        script = document.createElement("script");

                        script.async = true;

                        if ( s.scriptCharset ) {
                            script.charset = s.scriptCharset;
                        }

                        script.src = s.url;

                        // Attach handlers for all browsers
                        script.onload = script.onreadystatechange = function( _, isAbort ) {

                            if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

                                // Handle memory leak in IE
                                script.onload = script.onreadystatechange = null;

                                // Remove the script
                                if ( script.parentNode ) {
                                    script.parentNode.removeChild( script );
                                }

                                // Dereference the script
                                script = null;

                                // Callback if not abort
                                if ( !isAbort ) {
                                    callback( 200, "success" );
                                }
                            }
                        };
                        head.insertBefore( script, head.firstChild );
                    },

                    abort: function() {
                        if ( script ) {
                            script.onload( undefined, true );
                        }
                    }
                };
            }
        });


        var oldCallbacks = [],
            rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
        jQuery.ajaxSetup({
            jsonp: "callback",
            jsonpCallback: function() {
                var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
                this[ callback ] = true;
                return callback;
            }
        });

// Detect, normalize options and install callbacks for jsonp requests
        jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

            var callbackName, overwritten, responseContainer,
                jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
                            "url" :
                            typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
                    );

            // Handle iff the expected data type is "jsonp" or we have a parameter to set
            if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

                // Get callback name, remembering preexisting value associated with it
                callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
                    s.jsonpCallback() :
                    s.jsonpCallback;

                // Insert callback into url or form data
                if ( jsonProp ) {
                    s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
                } else if ( s.jsonp !== false ) {
                    s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
                }

                // Use data converter to retrieve json after script execution
                s.converters["script json"] = function() {
                    if ( !responseContainer ) {
                        jQuery.error( callbackName + " was not called" );
                    }
                    return responseContainer[ 0 ];
                };

                // force json dataType
                s.dataTypes[ 0 ] = "json";

                // Install callback
                overwritten = window[ callbackName ];
                window[ callbackName ] = function() {
                    responseContainer = arguments;
                };

                // Clean-up function (fires after converters)
                jqXHR.always(function() {
                    // Restore preexisting value
                    window[ callbackName ] = overwritten;

                    // Save back as free
                    if ( s[ callbackName ] ) {
                        // make sure that re-using the options doesn't screw things around
                        s.jsonpCallback = originalSettings.jsonpCallback;

                        // save the callback name for future use
                        oldCallbacks.push( callbackName );
                    }

                    // Call if it was a function and we have a response
                    if ( responseContainer && jQuery.isFunction( overwritten ) ) {
                        overwritten( responseContainer[ 0 ] );
                    }

                    responseContainer = overwritten = undefined;
                });

                // Delegate to script
                return "script";
            }
        });

        jQuery.parseHTML = function( data, context, keepScripts ) {
            if ( !data || typeof data !== "string" ) {
                return null;
            }
            if ( typeof context === "boolean" ) {
                keepScripts = context;
                context = false;
            }
            context = context || document;

            var parsed = rsingleTag.exec( data ),
                scripts = !keepScripts && [];

            // Single tag
            if ( parsed ) {
                return [ context.createElement( parsed[1] ) ];
            }

            parsed = jQuery.buildFragment( [ data ], context, scripts );

            if ( scripts && scripts.length ) {
                jQuery( scripts ).remove();
            }

            return jQuery.merge( [], parsed.childNodes );
        };


// Keep a copy of the old load method
        var _load = jQuery.fn.load;

        /**
         * Load a url into a page
         */
        jQuery.fn.load = function( url, params, callback ) {
            if ( typeof url !== "string" && _load ) {
                return _load.apply( this, arguments );
            }

            var selector, response, type,
                self = this,
                off = url.indexOf(" ");

            if ( off >= 0 ) {
                selector = jQuery.trim( url.slice( off, url.length ) );
                url = url.slice( 0, off );
            }

            // If it's a function
            if ( jQuery.isFunction( params ) ) {

                // We assume that it's the callback
                callback = params;
                params = undefined;

                // Otherwise, build a param string
            } else if ( params && typeof params === "object" ) {
                type = "POST";
            }

            // If we have elements to modify, make the request
            if ( self.length > 0 ) {
                jQuery.ajax({
                    url: url,
                    type: type,
                    dataType: "html",
                    data: params
                }).done(function( responseText ) {

                    // Save response for use in complete callback
                    response = arguments;

                    self.html( selector ?

                        jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

                        // Otherwise use the full result
                        responseText );

                }).complete( callback && function( jqXHR, status ) {
                        self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
                    });
            }

            return this;
        };

        jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
            jQuery.fn[ type ] = function( fn ) {
                return this.on( type, fn );
            };
        });

        jQuery.expr.filters.animated = function( elem ) {
            return jQuery.grep(jQuery.timers, function( fn ) {
                return elem === fn.elem;
            }).length;
        };

        var docElem = window.document.documentElement;

        /**
         * Gets a window from an element
         */
        function getWindow( elem ) {
            return jQuery.isWindow( elem ) ?
                elem :
                elem.nodeType === 9 ?
                    elem.defaultView || elem.parentWindow :
                    false;
        }

        jQuery.offset = {
            setOffset: function( elem, options, i ) {
                var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                    position = jQuery.css( elem, "position" ),
                    curElem = jQuery( elem ),
                    props = {};

                // set position first, in-case top/left are set even on static elem
                if ( position === "static" ) {
                    elem.style.position = "relative";
                }

                curOffset = curElem.offset();
                curCSSTop = jQuery.css( elem, "top" );
                curCSSLeft = jQuery.css( elem, "left" );
                calculatePosition = ( position === "absolute" || position === "fixed" ) &&
                    jQuery.inArray("auto", [ curCSSTop, curCSSLeft ] ) > -1;

                if ( calculatePosition ) {
                    curPosition = curElem.position();
                    curTop = curPosition.top;
                    curLeft = curPosition.left;
                } else {
                    curTop = parseFloat( curCSSTop ) || 0;
                    curLeft = parseFloat( curCSSLeft ) || 0;
                }

                if ( jQuery.isFunction( options ) ) {
                    options = options.call( elem, i, curOffset );
                }

                if ( options.top != null ) {
                    props.top = ( options.top - curOffset.top ) + curTop;
                }
                if ( options.left != null ) {
                    props.left = ( options.left - curOffset.left ) + curLeft;
                }

                if ( "using" in options ) {
                    options.using.call( elem, props );
                } else {
                    curElem.css( props );
                }
            }
        };

        jQuery.fn.extend({
            offset: function( options ) {
                if ( arguments.length ) {
                    return options === undefined ?
                        this :
                        this.each(function( i ) {
                            jQuery.offset.setOffset( this, options, i );
                        });
                }

                var docElem, win,
                    box = { top: 0, left: 0 },
                    elem = this[ 0 ],
                    doc = elem && elem.ownerDocument;

                if ( !doc ) {
                    return;
                }

                docElem = doc.documentElement;

                // Make sure it's not a disconnected DOM node
                if ( !jQuery.contains( docElem, elem ) ) {
                    return box;
                }

                if ( typeof elem.getBoundingClientRect !== strundefined ) {
                    box = elem.getBoundingClientRect();
                }
                win = getWindow( doc );
                return {
                    top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
                    left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
                };
            },

            position: function() {
                if ( !this[ 0 ] ) {
                    return;
                }

                var offsetParent, offset,
                    parentOffset = { top: 0, left: 0 },
                    elem = this[ 0 ];

                // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
                if ( jQuery.css( elem, "position" ) === "fixed" ) {
                    // we assume that getBoundingClientRect is available when computed position is fixed
                    offset = elem.getBoundingClientRect();
                } else {
                    // Get *real* offsetParent
                    offsetParent = this.offsetParent();

                    // Get correct offsets
                    offset = this.offset();
                    if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
                        parentOffset = offsetParent.offset();
                    }

                    // Add offsetParent borders
                    parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
                    parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
                }

                return {
                    top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
                    left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
                };
            },

            offsetParent: function() {
                return this.map(function() {
                    var offsetParent = this.offsetParent || docElem;

                    while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
                        offsetParent = offsetParent.offsetParent;
                    }
                    return offsetParent || docElem;
                });
            }
        });

        jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
            var top = /Y/.test( prop );

            jQuery.fn[ method ] = function( val ) {
                return access( this, function( elem, method, val ) {
                    var win = getWindow( elem );

                    if ( val === undefined ) {
                        return win ? (prop in win) ? win[ prop ] :
                                win.document.documentElement[ method ] :
                            elem[ method ];
                    }

                    if ( win ) {
                        win.scrollTo(
                            !top ? val : jQuery( win ).scrollLeft(),
                            top ? val : jQuery( win ).scrollTop()
                        );

                    } else {
                        elem[ method ] = val;
                    }
                }, method, val, arguments.length, null );
            };
        });

        jQuery.each( [ "top", "left" ], function( i, prop ) {
            jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
                function( elem, computed ) {
                    if ( computed ) {
                        computed = curCSS( elem, prop );
                        // if curCSS returns percentage, fallback to offset
                        return rnumnonpx.test( computed ) ?
                            jQuery( elem ).position()[ prop ] + "px" :
                            computed;
                    }
                }
            );
        });


        jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
            jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
                // margin is only for outerHeight, outerWidth
                jQuery.fn[ funcName ] = function( margin, value ) {
                    var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
                        extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

                    return access( this, function( elem, type, value ) {
                        var doc;

                        if ( jQuery.isWindow( elem ) ) {
                            return elem.document.documentElement[ "client" + name ];
                        }

                        // Get document width or height
                        if ( elem.nodeType === 9 ) {
                            doc = elem.documentElement;

                            return Math.max(
                                elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                                elem.body[ "offset" + name ], doc[ "offset" + name ],
                                doc[ "client" + name ]
                            );
                        }

                        return value === undefined ?
                            // Get width or height on the element, requesting but not forcing parseFloat
                            jQuery.css( elem, type, extra ) :

                            // Set width or height on the element
                            jQuery.style( elem, type, value, extra );
                    }, type, chainable ? margin : undefined, chainable, null );
                };
            });
        });


// The number of elements contained in the matched element set
        jQuery.fn.size = function() {
            return this.length;
        };

        jQuery.fn.andSelf = jQuery.fn.addBack;

        kcaseQuery = jQuery;

        // Create the defaults once
        var pluginName = "isLoading",
            defaults = {
                'position': "right",        // right | inside | overlay
                'text': "",                 // Text to display next to the loader
                'class': "icon-refresh",    // loader CSS class
                'tpl': '<span class="isloading-wrapper %wrapper%">%text%<span class="loading"><span></span><span></span><span></span><span></span><span></span></span></span>',    // loader base Tag
                'disableSource': true,      // true | false
                'disableOthers': []
            };

        // The actual plugin constructor
        function Plugin(element, options) {
            this.element = element;

            // Merge user options with default ones
            this.options = kcaseQuery.extend({}, defaults, options);

            this._defaults = defaults;
            this._name = pluginName;
            this._loader = null;                // Contain the loading tag element
            this.init();
        }

        // Contructor function for the plugin (only once on page load)
        function contruct() {
            if (!kcaseQuery[pluginName]) {
                window.isLoading = function (opts) {
                    kcaseQuery("body").isLoading(opts);
                };
                /*$.isLoading = function (opts) {
                 $("body").isLoading(opts);
                 };*/
            }
        }

        Plugin.prototype = {
            init: function () {

                if (kcaseQuery(this.element).is("body")) {
                    this.options.position = "overlay";
                }
                this.show();
            },

            show: function () {

                var self = this,
                    tpl = self.options.tpl.replace('%wrapper%', ' isloading-show ' + ' isloading-' + self.options.position);
                tpl = tpl.replace('%class%', self.options['class']);
                tpl = tpl.replace('%text%', (self.options.text !== "") ? self.options.text + ' ' : '');
                self._loader = kcaseQuery(tpl);

                // Disable the element
                if (kcaseQuery(self.element).is("input, textarea") && true === self.options.disableSource) {
                    kcaseQuery(self.element).attr("disabled", "disabled");
                }
                else if (true === self.options.disableSource) {
                    kcaseQuery(self.element).addClass("disabled");
                }

                // Set position
                switch (self.options.position) {
                    case "inside":
                        kcaseQuery(self.element).html(self._loader);
                        break;
                    case "overlay":
                        var $wrapperTpl = null;

                        if (kcaseQuery(self.element).is("body")) {
                            $wrapperTpl = kcaseQuery('<div class="isloading-overlay" style="position:fixed; left:0; top:0; z-index: 10000; width: 100%; height: ' + kcaseQuery(window).height() + 'px;" />');
                            kcaseQuery("body").prepend($wrapperTpl);

                            kcaseQuery(window).on('resize', function () {
                                $wrapperTpl.height(kcaseQuery(window).height() + 'px');
                                self._loader.css({top: (kcaseQuery(window).height() / 2 - self._loader.outerHeight() / 2) + 'px'});
                            });
                        } else {
                            var cssPosition = kcaseQuery(self.element).css('position'),
                                pos = {},
                                height = kcaseQuery(self.element).outerHeight() + 'px',
                                width = '100%'; // kcaseQuery( self.element ).outerWidth() + 'px;

                            if ('relative' === cssPosition || 'absolute' === cssPosition) {
                                pos = {'top': 0, 'left': 0};
                            } else {
                                pos = kcaseQuery(self.element).position();
                            }
                            $wrapperTpl = kcaseQuery('<div class="isloading-overlay" style="position:absolute; top: ' + pos.top + 'px; left: ' + pos.left + 'px; z-index: 10000; width: ' + width + '; height: ' + height + ';" />');
                            kcaseQuery(self.element).prepend($wrapperTpl);

                            kcaseQuery(window).on('resize', function () {
                                $wrapperTpl.height(kcaseQuery(self.element).outerHeight() + 'px');
                                self._loader.css({top: ($wrapperTpl.outerHeight() / 2 - self._loader.outerHeight() / 2) + 'px'});
                            });
                        }
                        $wrapperTpl.html(self._loader);
                        self._loader.css({top: ($wrapperTpl.outerHeight() / 2 - self._loader.outerHeight() / 2) + 'px'});
                        break;
                    default:
                        kcaseQuery(self.element).after(self._loader);
                        break;
                }

                self.disableOthers();
            },

            hide: function () {

                if ("overlay" === this.options.position) {

                    kcaseQuery(this.element).find(".isloading-overlay").first().remove();

                } else {

                    kcaseQuery(this._loader).remove();
                    kcaseQuery(this.element).text(kcaseQuery(this.element).attr("data-isloading-label"));

                }

                kcaseQuery(this.element).removeAttr("disabled").removeClass("disabled");

                this.enableOthers();
            },

            disableOthers: function () {
                kcaseQuery.each(this.options.disableOthers, function (i, e) {
                    var elt = kcaseQuery(e);
                    if (elt.is("button, input, textarea")) {
                        elt.attr("disabled", "disabled");
                    }
                    else {
                        elt.addClass("disabled");
                    }
                });
            },

            enableOthers: function () {
                kcaseQuery.each(this.options.disableOthers, function (i, e) {
                    var elt = kcaseQuery(e);
                    if (elt.is("button, input, textarea")) {
                        elt.removeAttr("disabled");
                    }
                    else {
                        elt.removeClass("disabled");
                    }
                });
            }
        };

        // Constructor
        kcaseQuery.fn[pluginName] = function (options) {
            return this.each(function () {
                if (options && "hide" !== options || !kcaseQuery.data(this, "plugin_" + pluginName)) {
                    kcaseQuery.data(this, "plugin_" + pluginName, new Plugin(this, options));
                } else {
                    var elt = kcaseQuery.data(this, "plugin_" + pluginName);

                    if ("hide" === options) {
                        elt.hide();
                    }
                    else {
                        elt.show();
                    }
                }
            });
        };

        contruct();

        /*! jQuery UI - v1.11.4 - 2016-06-18
         * http://jqueryui.com
         * Includes: core.js, widget.js, mouse.js, position.js
         * Copyright jQuery Foundation and other contributors; Licensed MIT */

        (function( factory ) {
            if ( typeof define === "function" && define.amd ) {
                // AMD. Register as an anonymous module.
                define([ "kcasequery" ], factory );
            } else {
                // Browser globals
                factory( kcaseQuery );
            }
        }
        (function() {
// kcaseQuery.ui might exist from components with no dependencies, e.g., kcaseQuery.ui.position
            kcaseQuery.ui = kcaseQuery.ui || {};

            kcaseQuery.extend( kcaseQuery.ui, {
                version: "1.11.4",

                keyCode: {
                    BACKSPACE: 8,
                    COMMA: 188,
                    DELETE: 46,
                    DOWN: 40,
                    END: 35,
                    ENTER: 13,
                    ESCAPE: 27,
                    HOME: 36,
                    LEFT: 37,
                    PAGE_DOWN: 34,
                    PAGE_UP: 33,
                    PERIOD: 190,
                    RIGHT: 39,
                    SPACE: 32,
                    TAB: 9,
                    UP: 38
                }
            });

// plugins
            kcaseQuery.fn.extend({
                scrollParent: function( includeHidden ) {
                    var position = this.css( "position" ),
                        excludeStaticParent = position === "absolute",
                        overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
                        scrollParent = this.parents().filter( function() {
                            var parent = kcaseQuery( this );
                            if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
                                return false;
                            }
                            return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) + parent.css( "overflow-x" ) );
                        }).eq( 0 );

                    return position === "fixed" || !scrollParent.length ? kcaseQuery( this[ 0 ].ownerDocument || document ) : scrollParent;
                },

                uniqueId: (function() {
                    var uuid = 0;

                    return function() {
                        return this.each(function() {
                            if ( !this.id ) {
                                this.id = "ui-id-" + ( ++uuid );
                            }
                        });
                    };
                })(),

                removeUniqueId: function() {
                    return this.each(function() {
                        if ( /^ui-id-\d+kcaseQuery/.test( this.id ) ) {
                            kcaseQuery( this ).removeAttr( "id" );
                        }
                    });
                }
            });

// selectors
            function focusable( element, isTabIndexNotNaN ) {
                var map, mapName, img,
                    nodeName = element.nodeName.toLowerCase();
                if ( "area" === nodeName ) {
                    map = element.parentNode;
                    mapName = map.name;
                    if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
                        return false;
                    }
                    img = kcaseQuery( "img[usemap='#" + mapName + "']" )[ 0 ];
                    return !!img && visible( img );
                }
                return ( /^(input|select|textarea|button|object)$/.test( nodeName ) ?
                        !element.disabled :
                        "a" === nodeName ?
                            element.href || isTabIndexNotNaN :
                            isTabIndexNotNaN) &&
                    // the element and all of its ancestors must be visible
                    visible( element );
            }

            function visible( element ) {
                return kcaseQuery.expr.filters.visible( element ) &&
                    !kcaseQuery( element ).parents().addBack().filter(function() {
                        return kcaseQuery.css( this, "visibility" ) === "hidden";
                    }).length;
            }

            kcaseQuery.extend( kcaseQuery.expr[ ":" ], {
                data: kcaseQuery.expr.createPseudo ?
                    kcaseQuery.expr.createPseudo(function( dataName ) {
                        return function( elem ) {
                            return !!kcaseQuery.data( elem, dataName );
                        };
                    }) :
                    // support: jQuery <1.8
                    function( elem, i, match ) {
                        return !!kcaseQuery.data( elem, match[ 3 ] );
                    },

                focusable: function( element ) {
                    return focusable( element, !isNaN( kcaseQuery.attr( element, "tabindex" ) ) );
                },

                tabbable: function( element ) {
                    var tabIndex = kcaseQuery.attr( element, "tabindex" ),
                        isTabIndexNaN = isNaN( tabIndex );
                    return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
                }
            });

// support: jQuery <1.8
            if ( !kcaseQuery( "<a>" ).outerWidth( 1 ).jquery ) {
                kcaseQuery.each( [ "Width", "Height" ], function( i, name ) {
                    var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
                        type = name.toLowerCase(),
                        orig = {
                            innerWidth: kcaseQuery.fn.innerWidth,
                            innerHeight: kcaseQuery.fn.innerHeight,
                            outerWidth: kcaseQuery.fn.outerWidth,
                            outerHeight: kcaseQuery.fn.outerHeight
                        };

                    function reduce( elem, size, border, margin ) {
                        kcaseQuery.each( side, function() {
                            size -= parseFloat( kcaseQuery.css( elem, "padding" + this ) ) || 0;
                            if ( border ) {
                                size -= parseFloat( kcaseQuery.css( elem, "border" + this + "Width" ) ) || 0;
                            }
                            if ( margin ) {
                                size -= parseFloat( kcaseQuery.css( elem, "margin" + this ) ) || 0;
                            }
                        });
                        return size;
                    }

                    kcaseQuery.fn[ "inner" + name ] = function( size ) {
                        if ( size === undefined ) {
                            return orig[ "inner" + name ].call( this );
                        }

                        return this.each(function() {
                            kcaseQuery( this ).css( type, reduce( this, size ) + "px" );
                        });
                    };

                    kcaseQuery.fn[ "outer" + name] = function( size, margin ) {
                        if ( typeof size !== "number" ) {
                            return orig[ "outer" + name ].call( this, size );
                        }

                        return this.each(function() {
                            kcaseQuery( this).css( type, reduce( this, size, true, margin ) + "px" );
                        });
                    };
                });
            }

// support: jQuery <1.8
            if ( !kcaseQuery.fn.addBack ) {
                kcaseQuery.fn.addBack = function( selector ) {
                    return this.add( selector == null ?
                        this.prevObject : this.prevObject.filter( selector )
                    );
                };
            }

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
            if ( kcaseQuery( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
                kcaseQuery.fn.removeData = (function( removeData ) {
                    return function( key ) {
                        if ( arguments.length ) {
                            return removeData.call( this, kcaseQuery.camelCase( key ) );
                        } else {
                            return removeData.call( this );
                        }
                    };
                })( kcaseQuery.fn.removeData );
            }

// deprecated
            kcaseQuery.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

            kcaseQuery.fn.extend({
                focus: (function( orig ) {
                    return function( delay, fn ) {
                        return typeof delay === "number" ?
                            this.each(function() {
                                var elem = this;
                                setTimeout(function() {
                                    kcaseQuery( elem ).focus();
                                    if ( fn ) {
                                        fn.call( elem );
                                    }
                                }, delay );
                            }) :
                            orig.apply( this, arguments );
                    };
                })( kcaseQuery.fn.focus ),

                disableSelection: (function() {
                    var eventType = "onselectstart" in document.createElement( "div" ) ?
                        "selectstart" :
                        "mousedown";

                    return function() {
                        return this.bind( eventType + ".ui-disableSelection", function( event ) {
                            event.preventDefault();
                        });
                    };
                })(),

                enableSelection: function() {
                    return this.unbind( ".ui-disableSelection" );
                },

                zIndex: function( zIndex ) {
                    if ( zIndex !== undefined ) {
                        return this.css( "zIndex", zIndex );
                    }

                    if ( this.length ) {
                        var elem = kcaseQuery( this[ 0 ] ), position, value;
                        while ( elem.length && elem[ 0 ] !== document ) {
                            // Ignore z-index if position is set to a value where z-index is ignored by the browser
                            // This makes behavior of this function consistent across browsers
                            // WebKit always returns auto if the element is positioned
                            position = elem.css( "position" );
                            if ( position === "absolute" || position === "relative" || position === "fixed" ) {
                                // IE returns 0 when zIndex is not specified
                                // other browsers return a string
                                // we ignore the case of nested elements with an explicit value of 0
                                // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                                value = parseInt( elem.css( "zIndex" ), 10 );
                                if ( !isNaN( value ) && value !== 0 ) {
                                    return value;
                                }
                            }
                            elem = elem.parent();
                        }
                    }

                    return 0;
                }
            });

// $.ui.plugin is deprecated. Use $.widget() extensions instead.
            kcaseQuery.ui.plugin = {
                add: function( module, option, set ) {
                    var i,
                        proto = kcaseQuery.ui[ module ].prototype;
                    for ( i in set ) {
                        proto.plugins[ i ] = proto.plugins[ i ] || [];
                        proto.plugins[ i ].push( [ option, set[ i ] ] );
                    }
                },
                call: function( instance, name, args, allowDisconnected ) {
                    var i,
                        set = instance.plugins[ name ];

                    if ( !set ) {
                        return;
                    }

                    if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
                        return;
                    }

                    for ( i = 0; i < set.length; i++ ) {
                        if ( instance.options[ set[ i ][ 0 ] ] ) {
                            set[ i ][ 1 ].apply( instance.element, args );
                        }
                    }
                }
            };


            /*!
             * jQuery UI Widget 1.11.4
             * http://jqueryui.com
             *
             * Copyright jQuery Foundation and other contributors
             * Released under the MIT license.
             * http://jquery.org/license
             *
             * http://api.jqueryui.com/jQuery.widget/
             */


            var widget_uuid = 0,
                widget_slice = Array.prototype.slice;

            kcaseQuery.cleanData = (function( orig ) {
                return function( elems ) {
                    var events, elem, i;
                    for ( i = 0; (elem = elems[i]) != null; i++ ) {
                        try {

                            // Only trigger remove when necessary to save time
                            events = kcaseQuery._data( elem, "events" );
                            if ( events && events.remove ) {
                                kcaseQuery( elem ).triggerHandler( "remove" );
                            }

                            // http://bugs.jquery.com/ticket/8235
                        } catch ( e ) {}
                    }
                    orig( elems );
                };
            })( kcaseQuery.cleanData );

            kcaseQuery.widget = function( name, base, prototype ) {
                var fullName, existingConstructor, constructor, basePrototype,
                    // proxiedPrototype allows the provided prototype to remain unmodified
                    // so that it can be used as a mixin for multiple widgets (#8876)
                    proxiedPrototype = {},
                    namespace = name.split( "." )[ 0 ];

                name = name.split( "." )[ 1 ];
                fullName = namespace + "-" + name;

                if ( !prototype ) {
                    prototype = base;
                    base = kcaseQuery.Widget;
                }

                // create selector for plugin
                kcaseQuery.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
                    return !!kcaseQuery.data( elem, fullName );
                };

                kcaseQuery[ namespace ] = kcaseQuery[ namespace ] || {};
                existingConstructor = kcaseQuery[ namespace ][ name ];
                constructor = kcaseQuery[ namespace ][ name ] = function( options, element ) {
                    // allow instantiation without "new" keyword
                    if ( !this._createWidget ) {
                        return new constructor( options, element );
                    }

                    // allow instantiation without initializing for simple inheritance
                    // must use "new" keyword (the code above always passes args)
                    if ( arguments.length ) {
                        this._createWidget( options, element );
                    }
                };
                // extend with the existing constructor to carry over any static properties
                kcaseQuery.extend( constructor, existingConstructor, {
                    version: prototype.version,
                    // copy the object used to create the prototype in case we need to
                    // redefine the widget later
                    _proto: kcaseQuery.extend( {}, prototype ),
                    // track widgets that inherit from this widget in case this widget is
                    // redefined after a widget inherits from it
                    _childConstructors: []
                });

                basePrototype = new base();
                // we need to make the options hash a property directly on the new instance
                // otherwise we'll modify the options hash on the prototype that we're
                // inheriting from
                basePrototype.options = kcaseQuery.widget.extend( {}, basePrototype.options );
                kcaseQuery.each( prototype, function( prop, value ) {
                    if ( !kcaseQuery.isFunction( value ) ) {
                        proxiedPrototype[ prop ] = value;
                        return;
                    }
                    proxiedPrototype[ prop ] = (function() {
                        var _super = function() {
                                return base.prototype[ prop ].apply( this, arguments );
                            },
                            _superApply = function( args ) {
                                return base.prototype[ prop ].apply( this, args );
                            };
                        return function() {
                            var __super = this._super,
                                __superApply = this._superApply,
                                returnValue;

                            this._super = _super;
                            this._superApply = _superApply;

                            returnValue = value.apply( this, arguments );

                            this._super = __super;
                            this._superApply = __superApply;

                            return returnValue;
                        };
                    })();
                });
                constructor.prototype = kcaseQuery.widget.extend( basePrototype, {
                    // TODO: remove support for widgetEventPrefix
                    // always use the name + a colon as the prefix, e.g., draggable:start
                    // don't prefix for widgets that aren't DOM-based
                    widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
                }, proxiedPrototype, {
                    constructor: constructor,
                    namespace: namespace,
                    widgetName: name,
                    widgetFullName: fullName
                });

                // If this widget is being redefined then we need to find all widgets that
                // are inheriting from it and redefine all of them so that they inherit from
                // the new version of this widget. We're essentially trying to replace one
                // level in the prototype chain.
                if ( existingConstructor ) {
                    kcaseQuery.each( existingConstructor._childConstructors, function( i, child ) {
                        var childPrototype = child.prototype;

                        // redefine the child widget using the same prototype that was
                        // originally used, but inherit from the new version of the base
                        kcaseQuery.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
                    });
                    // remove the list of existing child constructors from the old constructor
                    // so the old child constructors can be garbage collected
                    delete existingConstructor._childConstructors;
                } else {
                    base._childConstructors.push( constructor );
                }

                kcaseQuery.widget.bridge( name, constructor );

                return constructor;
            };

            kcaseQuery.widget.extend = function( target ) {
                var input = widget_slice.call( arguments, 1 ),
                    inputIndex = 0,
                    inputLength = input.length,
                    key,
                    value;
                for ( ; inputIndex < inputLength; inputIndex++ ) {
                    for ( key in input[ inputIndex ] ) {
                        value = input[ inputIndex ][ key ];
                        if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
                            // Clone objects
                            if ( kcaseQuery.isPlainObject( value ) ) {
                                target[ key ] = kcaseQuery.isPlainObject( target[ key ] ) ?
                                    kcaseQuery.widget.extend( {}, target[ key ], value ) :
                                    // Don't extend strings, arrays, etc. with objects
                                    kcaseQuery.widget.extend( {}, value );
                                // Copy everything else by reference
                            } else {
                                target[ key ] = value;
                            }
                        }
                    }
                }
                return target;
            };

            kcaseQuery.widget.bridge = function( name, object ) {
                var fullName = object.prototype.widgetFullName || name;
                kcaseQuery.fn[ name ] = function( options ) {
                    var isMethodCall = typeof options === "string",
                        args = widget_slice.call( arguments, 1 ),
                        returnValue = this;

                    if ( isMethodCall ) {
                        this.each(function() {
                            var methodValue,
                                instance = kcaseQuery.data( this, fullName );
                            if ( options === "instance" ) {
                                returnValue = instance;
                                return false;
                            }
                            if ( !instance ) {
                                return kcaseQuery.error( "cannot call methods on " + name + " prior to initialization; " +
                                    "attempted to call method '" + options + "'" );
                            }
                            if ( !kcaseQuery.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
                                return kcaseQuery.error( "no such method '" + options + "' for " + name + " widget instance" );
                            }
                            methodValue = instance[ options ].apply( instance, args );
                            if ( methodValue !== instance && methodValue !== undefined ) {
                                returnValue = methodValue && methodValue.jquery ?
                                    returnValue.pushStack( methodValue.get() ) :
                                    methodValue;
                                return false;
                            }
                        });
                    } else {

                        // Allow multiple hashes to be passed on init
                        if ( args.length ) {
                            options = kcaseQuery.widget.extend.apply( null, [ options ].concat(args) );
                        }

                        this.each(function() {
                            var instance = kcaseQuery.data( this, fullName );
                            if ( instance ) {
                                instance.option( options || {} );
                                if ( instance._init ) {
                                    instance._init();
                                }
                            } else {
                                kcaseQuery.data( this, fullName, new object( options, this ) );
                            }
                        });
                    }

                    return returnValue;
                };
            };

            kcaseQuery.Widget = function( /* options, element */ ) {};
            kcaseQuery.Widget._childConstructors = [];

            kcaseQuery.Widget.prototype = {
                widgetName: "widget",
                widgetEventPrefix: "",
                defaultElement: "<div>",
                options: {
                    disabled: false,

                    // callbacks
                    create: null
                },
                _createWidget: function( options, element ) {
                    element = kcaseQuery( element || this.defaultElement || this )[ 0 ];
                    this.element = kcaseQuery( element );
                    this.uuid = widget_uuid++;
                    this.eventNamespace = "." + this.widgetName + this.uuid;

                    this.bindings = kcaseQuery();
                    this.hoverable = kcaseQuery();
                    this.focusable = kcaseQuery();

                    if ( element !== this ) {
                        kcaseQuery.data( element, this.widgetFullName, this );
                        this._on( true, this.element, {
                            remove: function( event ) {
                                if ( event.target === element ) {
                                    this.destroy();
                                }
                            }
                        });
                        this.document = kcaseQuery( element.style ?
                            // element within the document
                            element.ownerDocument :
                            // element is window or document
                            element.document || element );
                        this.window = kcaseQuery( this.document[0].defaultView || this.document[0].parentWindow );
                    }

                    this.options = kcaseQuery.widget.extend( {},
                        this.options,
                        this._getCreateOptions(),
                        options );

                    this._create();
                    this._trigger( "create", null, this._getCreateEventData() );
                    this._init();
                },
                _getCreateOptions: kcaseQuery.noop,
                _getCreateEventData: kcaseQuery.noop,
                _create: kcaseQuery.noop,
                _init: kcaseQuery.noop,

                destroy: function() {
                    this._destroy();
                    // we can probably remove the unbind calls in 2.0
                    // all event bindings should go through this._on()
                    this.element
                        .unbind( this.eventNamespace )
                        .removeData( this.widgetFullName )
                        // support: jquery <1.6.3
                        // http://bugs.jquery.com/ticket/9413
                        .removeData( kcaseQuery.camelCase( this.widgetFullName ) );
                    this.widget()
                        .unbind( this.eventNamespace )
                        .removeAttr( "aria-disabled" )
                        .removeClass(
                            this.widgetFullName + "-disabled " +
                            "ui-state-disabled" );

                    // clean up events and states
                    this.bindings.unbind( this.eventNamespace );
                    this.hoverable.removeClass( "ui-state-hover" );
                    this.focusable.removeClass( "ui-state-focus" );
                },
                _destroy: kcaseQuery.noop,

                widget: function() {
                    return this.element;
                },

                option: function( key, value ) {
                    var options = key,
                        parts,
                        curOption,
                        i;

                    if ( arguments.length === 0 ) {
                        // don't return a reference to the internal hash
                        return kcaseQuery.widget.extend( {}, this.options );
                    }

                    if ( typeof key === "string" ) {
                        // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                        options = {};
                        parts = key.split( "." );
                        key = parts.shift();
                        if ( parts.length ) {
                            curOption = options[ key ] = kcaseQuery.widget.extend( {}, this.options[ key ] );
                            for ( i = 0; i < parts.length - 1; i++ ) {
                                curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
                                curOption = curOption[ parts[ i ] ];
                            }
                            key = parts.pop();
                            if ( arguments.length === 1 ) {
                                return curOption[ key ] === undefined ? null : curOption[ key ];
                            }
                            curOption[ key ] = value;
                        } else {
                            if ( arguments.length === 1 ) {
                                return this.options[ key ] === undefined ? null : this.options[ key ];
                            }
                            options[ key ] = value;
                        }
                    }

                    this._setOptions( options );

                    return this;
                },
                _setOptions: function( options ) {
                    var key;

                    for ( key in options ) {
                        this._setOption( key, options[ key ] );
                    }

                    return this;
                },
                _setOption: function( key, value ) {
                    this.options[ key ] = value;

                    if ( key === "disabled" ) {
                        this.widget()
                            .toggleClass( this.widgetFullName + "-disabled", !!value );

                        // If the widget is becoming disabled, then nothing is interactive
                        if ( value ) {
                            this.hoverable.removeClass( "ui-state-hover" );
                            this.focusable.removeClass( "ui-state-focus" );
                        }
                    }

                    return this;
                },

                enable: function() {
                    return this._setOptions({ disabled: false });
                },
                disable: function() {
                    return this._setOptions({ disabled: true });
                },

                _on: function( suppressDisabledCheck, element, handlers ) {
                    var delegateElement,
                        instance = this;

                    // no suppressDisabledCheck flag, shuffle arguments
                    if ( typeof suppressDisabledCheck !== "boolean" ) {
                        handlers = element;
                        element = suppressDisabledCheck;
                        suppressDisabledCheck = false;
                    }

                    // no element argument, shuffle and use this.element
                    if ( !handlers ) {
                        handlers = element;
                        element = this.element;
                        delegateElement = this.widget();
                    } else {
                        element = delegateElement = kcaseQuery( element );
                        this.bindings = this.bindings.add( element );
                    }

                    kcaseQuery.each( handlers, function( event, handler ) {
                        function handlerProxy() {
                            // allow widgets to customize the disabled handling
                            // - disabled as an array instead of boolean
                            // - disabled class as method for disabling individual parts
                            if ( !suppressDisabledCheck &&
                                ( instance.options.disabled === true ||
                                kcaseQuery( this ).hasClass( "ui-state-disabled" ) ) ) {
                                return;
                            }
                            return ( typeof handler === "string" ? instance[ handler ] : handler )
                                .apply( instance, arguments );
                        }

                        // copy the guid so direct unbinding works
                        if ( typeof handler !== "string" ) {
                            handlerProxy.guid = handler.guid =
                                handler.guid || handlerProxy.guid || kcaseQuery.guid++;
                        }

                        var match = event.match( /^([\w:-]*)\s*(.*)$/ ),
                            eventName = match[1] + instance.eventNamespace,
                            selector = match[2];
                        if ( selector ) {
                            delegateElement.delegate( selector, eventName, handlerProxy );
                        } else {
                            element.bind( eventName, handlerProxy );
                        }
                    });
                },

                _off: function( element, eventName ) {
                    eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) +
                        this.eventNamespace;
                    element.unbind( eventName ).undelegate( eventName );

                    // Clear the stack to avoid memory leaks (#10056)
                    this.bindings = kcaseQuery( this.bindings.not( element ).get() );
                    this.focusable = kcaseQuery( this.focusable.not( element ).get() );
                    this.hoverable = kcaseQuery( this.hoverable.not( element ).get() );
                },

                _delay: function( handler, delay ) {
                    function handlerProxy() {
                        return ( typeof handler === "string" ? instance[ handler ] : handler )
                            .apply( instance, arguments );
                    }
                    var instance = this;
                    return setTimeout( handlerProxy, delay || 0 );
                },

                _hoverable: function( element ) {
                    this.hoverable = this.hoverable.add( element );
                    this._on( element, {
                        mouseenter: function( event ) {
                            kcaseQuery( event.currentTarget ).addClass( "ui-state-hover" );
                        },
                        mouseleave: function( event ) {
                            kcaseQuery( event.currentTarget ).removeClass( "ui-state-hover" );
                        }
                    });
                },

                _focusable: function( element ) {
                    this.focusable = this.focusable.add( element );
                    this._on( element, {
                        focusin: function( event ) {
                            kcaseQuery( event.currentTarget ).addClass( "ui-state-focus" );
                        },
                        focusout: function( event ) {
                            kcaseQuery( event.currentTarget ).removeClass( "ui-state-focus" );
                        }
                    });
                },

                _trigger: function( type, event, data ) {
                    var prop, orig,
                        callback = this.options[ type ];

                    data = data || {};
                    event = kcaseQuery.Event( event );
                    event.type = ( type === this.widgetEventPrefix ?
                        type :
                        this.widgetEventPrefix + type ).toLowerCase();
                    // the original event may come from any element
                    // so we need to reset the target on the new event
                    event.target = this.element[ 0 ];

                    // copy original event properties over to the new event
                    orig = event.originalEvent;
                    if ( orig ) {
                        for ( prop in orig ) {
                            if ( !( prop in event ) ) {
                                event[ prop ] = orig[ prop ];
                            }
                        }
                    }

                    this.element.trigger( event, data );
                    return !( kcaseQuery.isFunction( callback ) &&
                    callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
                    event.isDefaultPrevented() );
                }
            };

            kcaseQuery.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
                kcaseQuery.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
                    if ( typeof options === "string" ) {
                        options = { effect: options };
                    }
                    var hasOptions,
                        effectName = !options ?
                            method :
                            options === true || typeof options === "number" ?
                                defaultEffect :
                                options.effect || defaultEffect;
                    options = options || {};
                    if ( typeof options === "number" ) {
                        options = { duration: options };
                    }
                    hasOptions = !kcaseQuery.isEmptyObject( options );
                    options.complete = callback;
                    if ( options.delay ) {
                        element.delay( options.delay );
                    }
                    if ( hasOptions && kcaseQuery.effects && kcaseQuery.effects.effect[ effectName ] ) {
                        element[ method ]( options );
                    } else if ( effectName !== method && element[ effectName ] ) {
                        element[ effectName ]( options.duration, options.easing, callback );
                    } else {
                        element.queue(function( next ) {
                            kcaseQuery( this )[ method ]();
                            if ( callback ) {
                                callback.call( element[ 0 ] );
                            }
                            next();
                        });
                    }
                };
            });

            var widget = kcaseQuery.widget;


            /*!
             * jQuery UI Mouse 1.11.4
             * http://jqueryui.com
             *
             * Copyright jQuery Foundation and other contributors
             * Released under the MIT license.
             * http://jquery.org/license
             *
             * http://api.jqueryui.com/mouse/
             */


            var mouseHandled = false;
            kcaseQuery( document ).mouseup( function() {
                mouseHandled = false;
            });

            var mouse = kcaseQuery.widget("ui.mouse", {
                version: "1.11.4",
                options: {
                    cancel: "input,textarea,button,select,option",
                    distance: 1,
                    delay: 0
                },
                _mouseInit: function() {
                    var that = this;

                    this.element
                        .bind("mousedown." + this.widgetName, function(event) {
                            return that._mouseDown(event);
                        })
                        .bind("click." + this.widgetName, function(event) {
                            if (true === kcaseQuery.data(event.target, that.widgetName + ".preventClickEvent")) {
                                kcaseQuery.removeData(event.target, that.widgetName + ".preventClickEvent");
                                event.stopImmediatePropagation();
                                return false;
                            }
                        });

                    this.started = false;
                },

                // TODO: make sure destroying one instance of mouse doesn't mess with
                // other instances of mouse
                _mouseDestroy: function() {
                    this.element.unbind("." + this.widgetName);
                    if ( this._mouseMoveDelegate ) {
                        this.document
                            .unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
                            .unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
                    }
                },

                _mouseDown: function(event) {
                    // don't let more than one widget handle mouseStart
                    if ( mouseHandled ) {
                        return;
                    }

                    this._mouseMoved = false;

                    // we may have missed mouseup (out of window)
                    (this._mouseStarted && this._mouseUp(event));

                    this._mouseDownEvent = event;

                    var that = this,
                        btnIsLeft = (event.which === 1),
                        // event.target.nodeName works around a bug in IE 8 with
                        // disabled inputs (#7620)
                        elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? kcaseQuery(event.target).closest(this.options.cancel).length : false);
                    if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
                        return true;
                    }

                    this.mouseDelayMet = !this.options.delay;
                    if (!this.mouseDelayMet) {
                        this._mouseDelayTimer = setTimeout(function() {
                            that.mouseDelayMet = true;
                        }, this.options.delay);
                    }

                    if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                        this._mouseStarted = (this._mouseStart(event) !== false);
                        if (!this._mouseStarted) {
                            event.preventDefault();
                            return true;
                        }
                    }

                    // Click event may never have fired (Gecko & Opera)
                    if (true === kcaseQuery.data(event.target, this.widgetName + ".preventClickEvent")) {
                        kcaseQuery.removeData(event.target, this.widgetName + ".preventClickEvent");
                    }

                    // these delegates are required to keep context
                    this._mouseMoveDelegate = function(event) {
                        return that._mouseMove(event);
                    };
                    this._mouseUpDelegate = function(event) {
                        return that._mouseUp(event);
                    };

                    this.document
                        .bind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
                        .bind( "mouseup." + this.widgetName, this._mouseUpDelegate );

                    event.preventDefault();

                    mouseHandled = true;
                    return true;
                },

                _mouseMove: function(event) {
                    // Only check for mouseups outside the document if you've moved inside the document
                    // at least once. This prevents the firing of mouseup in the case of IE<9, which will
                    // fire a mousemove event if content is placed under the cursor. See #7778
                    // Support: IE <9
                    if ( this._mouseMoved ) {
                        // IE mouseup check - mouseup happened when mouse was out of window
                        if (kcaseQuery.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
                            return this._mouseUp(event);

                            // Iframe mouseup check - mouseup occurred in another document
                        } else if ( !event.which ) {
                            return this._mouseUp( event );
                        }
                    }

                    if ( event.which || event.button ) {
                        this._mouseMoved = true;
                    }

                    if (this._mouseStarted) {
                        this._mouseDrag(event);
                        return event.preventDefault();
                    }

                    if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                        this._mouseStarted =
                            (this._mouseStart(this._mouseDownEvent, event) !== false);
                        (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
                    }

                    return !this._mouseStarted;
                },

                _mouseUp: function(event) {
                    this.document
                        .unbind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
                        .unbind( "mouseup." + this.widgetName, this._mouseUpDelegate );

                    if (this._mouseStarted) {
                        this._mouseStarted = false;

                        if (event.target === this._mouseDownEvent.target) {
                            kcaseQuery.data(event.target, this.widgetName + ".preventClickEvent", true);
                        }

                        this._mouseStop(event);
                    }

                    mouseHandled = false;
                    return false;
                },

                _mouseDistanceMet: function(event) {
                    return (Math.max(
                            Math.abs(this._mouseDownEvent.pageX - event.pageX),
                            Math.abs(this._mouseDownEvent.pageY - event.pageY)
                        ) >= this.options.distance
                    );
                },

                _mouseDelayMet: function(/* event */) {
                    return this.mouseDelayMet;
                },

                // These are placeholder methods, to be overriden by extending plugin
                _mouseStart: function(/* event */) {},
                _mouseDrag: function(/* event */) {},
                _mouseStop: function(/* event */) {},
                _mouseCapture: function(/* event */) { return true; }
            });


            /*!
             * jQuery UI Position 1.11.4
             * http://jqueryui.com
             *
             * Copyright jQuery Foundation and other contributors
             * Released under the MIT license.
             * http://jquery.org/license
             *
             * http://api.jqueryui.com/position/
             */

            (function() {

                kcaseQuery.ui = kcaseQuery.ui || {};

                var cachedScrollbarWidth, supportsOffsetFractions,
                    max = Math.max,
                    abs = Math.abs,
                    round = Math.round,
                    rhorizontal = /left|center|right/,
                    rvertical = /top|center|bottom/,
                    roffset = /[\+\-]\d+(\.[\d]+)?%?/,
                    rposition = /^\w+/,
                    rpercent = /%$/,
                    _position = kcaseQuery.fn.position;

                function getOffsets( offsets, width, height ) {
                    return [
                        parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
                        parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
                    ];
                }

                function parseCss( element, property ) {
                    return parseInt( kcaseQuery.css( element, property ), 10 ) || 0;
                }

                function getDimensions( elem ) {
                    var raw = elem[0];
                    if ( raw.nodeType === 9 ) {
                        return {
                            width: elem.width(),
                            height: elem.height(),
                            offset: { top: 0, left: 0 }
                        };
                    }
                    if ( kcaseQuery.isWindow( raw ) ) {
                        return {
                            width: elem.width(),
                            height: elem.height(),
                            offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
                        };
                    }
                    if ( raw.preventDefault ) {
                        return {
                            width: 0,
                            height: 0,
                            offset: { top: raw.pageY, left: raw.pageX }
                        };
                    }
                    return {
                        width: elem.outerWidth(),
                        height: elem.outerHeight(),
                        offset: elem.offset()
                    };
                }

                kcaseQuery.position = {
                    scrollbarWidth: function() {
                        if ( cachedScrollbarWidth !== undefined ) {
                            return cachedScrollbarWidth;
                        }
                        var w1, w2,
                            div = kcaseQuery( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
                            innerDiv = div.children()[0];

                        kcaseQuery( "body" ).append( div );
                        w1 = innerDiv.offsetWidth;
                        div.css( "overflow", "scroll" );

                        w2 = innerDiv.offsetWidth;

                        if ( w1 === w2 ) {
                            w2 = div[0].clientWidth;
                        }

                        div.remove();

                        return (cachedScrollbarWidth = w1 - w2);
                    },
                    getScrollInfo: function( within ) {
                        var overflowX = within.isWindow || within.isDocument ? "" :
                                within.element.css( "overflow-x" ),
                            overflowY = within.isWindow || within.isDocument ? "" :
                                within.element.css( "overflow-y" ),
                            hasOverflowX = overflowX === "scroll" ||
                                ( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
                            hasOverflowY = overflowY === "scroll" ||
                                ( overflowY === "auto" && within.height < within.element[0].scrollHeight );
                        return {
                            width: hasOverflowY ? kcaseQuery.position.scrollbarWidth() : 0,
                            height: hasOverflowX ? kcaseQuery.position.scrollbarWidth() : 0
                        };
                    },
                    getWithinInfo: function( element ) {
                        var withinElement = kcaseQuery( element || window ),
                            isWindow = kcaseQuery.isWindow( withinElement[0] ),
                            isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;
                        return {
                            element: withinElement,
                            isWindow: isWindow,
                            isDocument: isDocument,
                            offset: withinElement.offset() || { left: 0, top: 0 },
                            scrollLeft: withinElement.scrollLeft(),
                            scrollTop: withinElement.scrollTop(),

                            // support: jQuery 1.6.x
                            // jQuery 1.6 doesn't support .outerWidth/Height() on documents or windows
                            width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
                            height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
                        };
                    }
                };

                kcaseQuery.fn.position = function( options ) {
                    if ( !options || !options.of ) {
                        return _position.apply( this, arguments );
                    }

                    // make a copy, we don't want to modify arguments
                    options = kcaseQuery.extend( {}, options );

                    var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
                        target = kcaseQuery( options.of ),
                        within = kcaseQuery.position.getWithinInfo( options.within ),
                        scrollInfo = kcaseQuery.position.getScrollInfo( within ),
                        collision = ( options.collision || "flip" ).split( " " ),
                        offsets = {};

                    dimensions = getDimensions( target );
                    if ( target[0].preventDefault ) {
                        // force left top to allow flipping
                        options.at = "left top";
                    }
                    targetWidth = dimensions.width;
                    targetHeight = dimensions.height;
                    targetOffset = dimensions.offset;
                    // clone to reuse original targetOffset later
                    basePosition = kcaseQuery.extend( {}, targetOffset );

                    // force my and at to have valid horizontal and vertical positions
                    // if a value is missing or invalid, it will be converted to center
                    kcaseQuery.each( [ "my", "at" ], function() {
                        var pos = ( options[ this ] || "" ).split( " " ),
                            horizontalOffset,
                            verticalOffset;

                        if ( pos.length === 1) {
                            pos = rhorizontal.test( pos[ 0 ] ) ?
                                pos.concat( [ "center" ] ) :
                                rvertical.test( pos[ 0 ] ) ?
                                    [ "center" ].concat( pos ) :
                                    [ "center", "center" ];
                        }
                        pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
                        pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

                        // calculate offsets
                        horizontalOffset = roffset.exec( pos[ 0 ] );
                        verticalOffset = roffset.exec( pos[ 1 ] );
                        offsets[ this ] = [
                            horizontalOffset ? horizontalOffset[ 0 ] : 0,
                            verticalOffset ? verticalOffset[ 0 ] : 0
                        ];

                        // reduce to just the positions without the offsets
                        options[ this ] = [
                            rposition.exec( pos[ 0 ] )[ 0 ],
                            rposition.exec( pos[ 1 ] )[ 0 ]
                        ];
                    });

                    // normalize collision option
                    if ( collision.length === 1 ) {
                        collision[ 1 ] = collision[ 0 ];
                    }

                    if ( options.at[ 0 ] === "right" ) {
                        basePosition.left += targetWidth;
                    } else if ( options.at[ 0 ] === "center" ) {
                        basePosition.left += targetWidth / 2;
                    }

                    if ( options.at[ 1 ] === "bottom" ) {
                        basePosition.top += targetHeight;
                    } else if ( options.at[ 1 ] === "center" ) {
                        basePosition.top += targetHeight / 2;
                    }

                    atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
                    basePosition.left += atOffset[ 0 ];
                    basePosition.top += atOffset[ 1 ];

                    return this.each(function() {
                        var collisionPosition, using,
                            elem = kcaseQuery( this ),
                            elemWidth = elem.outerWidth(),
                            elemHeight = elem.outerHeight(),
                            marginLeft = parseCss( this, "marginLeft" ),
                            marginTop = parseCss( this, "marginTop" ),
                            collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
                            collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
                            position = kcaseQuery.extend( {}, basePosition ),
                            myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

                        if ( options.my[ 0 ] === "right" ) {
                            position.left -= elemWidth;
                        } else if ( options.my[ 0 ] === "center" ) {
                            position.left -= elemWidth / 2;
                        }

                        if ( options.my[ 1 ] === "bottom" ) {
                            position.top -= elemHeight;
                        } else if ( options.my[ 1 ] === "center" ) {
                            position.top -= elemHeight / 2;
                        }

                        position.left += myOffset[ 0 ];
                        position.top += myOffset[ 1 ];

                        // if the browser doesn't support fractions, then round for consistent results
                        if ( !supportsOffsetFractions ) {
                            position.left = round( position.left );
                            position.top = round( position.top );
                        }

                        collisionPosition = {
                            marginLeft: marginLeft,
                            marginTop: marginTop
                        };

                        kcaseQuery.each( [ "left", "top" ], function( i, dir ) {
                            if ( kcaseQuery.ui.position[ collision[ i ] ] ) {
                                kcaseQuery.ui.position[ collision[ i ] ][ dir ]( position, {
                                    targetWidth: targetWidth,
                                    targetHeight: targetHeight,
                                    elemWidth: elemWidth,
                                    elemHeight: elemHeight,
                                    collisionPosition: collisionPosition,
                                    collisionWidth: collisionWidth,
                                    collisionHeight: collisionHeight,
                                    offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
                                    my: options.my,
                                    at: options.at,
                                    within: within,
                                    elem: elem
                                });
                            }
                        });

                        if ( options.using ) {
                            // adds feedback as second argument to using callback, if present
                            using = function( props ) {
                                var left = targetOffset.left - position.left,
                                    right = left + targetWidth - elemWidth,
                                    top = targetOffset.top - position.top,
                                    bottom = top + targetHeight - elemHeight,
                                    feedback = {
                                        target: {
                                            element: target,
                                            left: targetOffset.left,
                                            top: targetOffset.top,
                                            width: targetWidth,
                                            height: targetHeight
                                        },
                                        element: {
                                            element: elem,
                                            left: position.left,
                                            top: position.top,
                                            width: elemWidth,
                                            height: elemHeight
                                        },
                                        horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                                        vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                                    };
                                if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
                                    feedback.horizontal = "center";
                                }
                                if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
                                    feedback.vertical = "middle";
                                }
                                if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
                                    feedback.important = "horizontal";
                                } else {
                                    feedback.important = "vertical";
                                }
                                options.using.call( this, props, feedback );
                            };
                        }

                        elem.offset( kcaseQuery.extend( position, { using: using } ) );
                    });
                };

                kcaseQuery.ui.position = {
                    fit: {
                        left: function( position, data ) {
                            var within = data.within,
                                withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                                outerWidth = within.width,
                                collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                                overLeft = withinOffset - collisionPosLeft,
                                overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                                newOverRight;

                            // element is wider than within
                            if ( data.collisionWidth > outerWidth ) {
                                // element is initially over the left side of within
                                if ( overLeft > 0 && overRight <= 0 ) {
                                    newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
                                    position.left += overLeft - newOverRight;
                                    // element is initially over right side of within
                                } else if ( overRight > 0 && overLeft <= 0 ) {
                                    position.left = withinOffset;
                                    // element is initially over both left and right sides of within
                                } else {
                                    if ( overLeft > overRight ) {
                                        position.left = withinOffset + outerWidth - data.collisionWidth;
                                    } else {
                                        position.left = withinOffset;
                                    }
                                }
                                // too far left -> align with left edge
                            } else if ( overLeft > 0 ) {
                                position.left += overLeft;
                                // too far right -> align with right edge
                            } else if ( overRight > 0 ) {
                                position.left -= overRight;
                                // adjust based on position and margin
                            } else {
                                position.left = max( position.left - collisionPosLeft, position.left );
                            }
                        },
                        top: function( position, data ) {
                            var within = data.within,
                                withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                                outerHeight = data.within.height,
                                collisionPosTop = position.top - data.collisionPosition.marginTop,
                                overTop = withinOffset - collisionPosTop,
                                overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                                newOverBottom;

                            // element is taller than within
                            if ( data.collisionHeight > outerHeight ) {
                                // element is initially over the top of within
                                if ( overTop > 0 && overBottom <= 0 ) {
                                    newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
                                    position.top += overTop - newOverBottom;
                                    // element is initially over bottom of within
                                } else if ( overBottom > 0 && overTop <= 0 ) {
                                    position.top = withinOffset;
                                    // element is initially over both top and bottom of within
                                } else {
                                    if ( overTop > overBottom ) {
                                        position.top = withinOffset + outerHeight - data.collisionHeight;
                                    } else {
                                        position.top = withinOffset;
                                    }
                                }
                                // too far up -> align with top
                            } else if ( overTop > 0 ) {
                                position.top += overTop;
                                // too far down -> align with bottom edge
                            } else if ( overBottom > 0 ) {
                                position.top -= overBottom;
                                // adjust based on position and margin
                            } else {
                                position.top = max( position.top - collisionPosTop, position.top );
                            }
                        }
                    },
                    flip: {
                        left: function( position, data ) {
                            var within = data.within,
                                withinOffset = within.offset.left + within.scrollLeft,
                                outerWidth = within.width,
                                offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                                collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                                overLeft = collisionPosLeft - offsetLeft,
                                overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                                myOffset = data.my[ 0 ] === "left" ?
                                    -data.elemWidth :
                                    data.my[ 0 ] === "right" ?
                                        data.elemWidth :
                                        0,
                                atOffset = data.at[ 0 ] === "left" ?
                                    data.targetWidth :
                                    data.at[ 0 ] === "right" ?
                                        -data.targetWidth :
                                        0,
                                offset = -2 * data.offset[ 0 ],
                                newOverRight,
                                newOverLeft;

                            if ( overLeft < 0 ) {
                                newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
                                if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
                                    position.left += myOffset + atOffset + offset;
                                }
                            } else if ( overRight > 0 ) {
                                newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
                                if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
                                    position.left += myOffset + atOffset + offset;
                                }
                            }
                        },
                        top: function( position, data ) {
                            var within = data.within,
                                withinOffset = within.offset.top + within.scrollTop,
                                outerHeight = within.height,
                                offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                                collisionPosTop = position.top - data.collisionPosition.marginTop,
                                overTop = collisionPosTop - offsetTop,
                                overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                                top = data.my[ 1 ] === "top",
                                myOffset = top ?
                                    -data.elemHeight :
                                    data.my[ 1 ] === "bottom" ?
                                        data.elemHeight :
                                        0,
                                atOffset = data.at[ 1 ] === "top" ?
                                    data.targetHeight :
                                    data.at[ 1 ] === "bottom" ?
                                        -data.targetHeight :
                                        0,
                                offset = -2 * data.offset[ 1 ],
                                newOverTop,
                                newOverBottom;
                            if ( overTop < 0 ) {
                                newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                                if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
                                    position.top += myOffset + atOffset + offset;
                                }
                            } else if ( overBottom > 0 ) {
                                newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                                if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
                                    position.top += myOffset + atOffset + offset;
                                }
                            }
                        }
                    },
                    flipfit: {
                        left: function() {
                            kcaseQuery.ui.position.flip.left.apply( this, arguments );
                            kcaseQuery.ui.position.fit.left.apply( this, arguments );
                        },
                        top: function() {
                            kcaseQuery.ui.position.flip.top.apply( this, arguments );
                            kcaseQuery.ui.position.fit.top.apply( this, arguments );
                        }
                    }
                };

// fraction support test
                (function() {
                    var testElement, testElementParent, testElementStyle, offsetLeft, i,
                        body = document.getElementsByTagName( "body" )[ 0 ],
                        div = document.createElement( "div" );

                    //Create a "fake body" for testing based on method used in jQuery.support
                    testElement = document.createElement( body ? "div" : "body" );
                    testElementStyle = {
                        visibility: "hidden",
                        width: 0,
                        height: 0,
                        border: 0,
                        margin: 0,
                        background: "none"
                    };
                    if ( body ) {
                        kcaseQuery.extend( testElementStyle, {
                            position: "absolute",
                            left: "-1000px",
                            top: "-1000px"
                        });
                    }
                    for ( i in testElementStyle ) {
                        testElement.style[ i ] = testElementStyle[ i ];
                    }
                    testElement.appendChild( div );
                    testElementParent = body || document.documentElement;
                    testElementParent.insertBefore( testElement, testElementParent.firstChild );

                    div.style.cssText = "position: absolute; left: 10.7432222px;";

                    offsetLeft = kcaseQuery( div ).offset().left;
                    supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;

                    testElement.innerHTML = "";
                    testElementParent.removeChild( testElement );
                })();

            })();

            var position = kcaseQuery.ui.position;

            kcaseQuery.widget("ui.draggable", kcaseQuery.ui.mouse, {
                version: "1.11.4",
                widgetEventPrefix: "drag",
                options: {
                    addClasses: true,
                    appendTo: "parent",
                    axis: false,
                    connectToSortable: false,
                    containment: false,
                    cursor: "auto",
                    cursorAt: false,
                    grid: false,
                    handle: false,
                    helper: "original",
                    iframeFix: false,
                    opacity: false,
                    refreshPositions: false,
                    revert: false,
                    revertDuration: 500,
                    scope: "default",
                    scroll: true,
                    scrollSensitivity: 20,
                    scrollSpeed: 20,
                    snap: false,
                    snapMode: "both",
                    snapTolerance: 20,
                    stack: false,
                    zIndex: false,

                    // callbacks
                    drag: null,
                    start: null,
                    stop: null
                },
                _create: function() {

                    if ( this.options.helper === "original" ) {
                        this._setPositionRelative();
                    }
                    if (this.options.addClasses){
                        this.element.addClass("ui-draggable");
                    }
                    if (this.options.disabled){
                        this.element.addClass("ui-draggable-disabled");
                    }
                    this._setHandleClassName();

                    this._mouseInit();
                },

                _setOption: function( key, value ) {
                    this._super( key, value );
                    if ( key === "handle" ) {
                        this._removeHandleClassName();
                        this._setHandleClassName();
                    }
                },

                _destroy: function() {
                    if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
                        this.destroyOnClear = true;
                        return;
                    }
                    this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
                    this._removeHandleClassName();
                    this._mouseDestroy();
                },

                _mouseCapture: function(event) {
                    var o = this.options;

                    this._blurActiveElement( event );

                    // among others, prevent a drag on a resizable-handle
                    if (this.helper || o.disabled || kcaseQuery(event.target).closest(".ui-resizable-handle").length > 0) {
                        return false;
                    }

                    //Quit if we're not on a valid handle
                    this.handle = this._getHandle(event);
                    if (!this.handle) {
                        return false;
                    }

                    this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );

                    return true;

                },

                _blockFrames: function( selector ) {
                    this.iframeBlocks = this.document.find( selector ).map(function() {
                        var iframe = kcaseQuery( this );

                        return kcaseQuery( "<div>" )
                            .css( "position", "absolute" )
                            .appendTo( iframe.parent() )
                            .outerWidth( iframe.outerWidth() )
                            .outerHeight( iframe.outerHeight() )
                            .offset( iframe.offset() )[ 0 ];
                    });
                },

                _unblockFrames: function() {
                    if ( this.iframeBlocks ) {
                        this.iframeBlocks.remove();
                        delete this.iframeBlocks;
                    }
                },

                _blurActiveElement: function( event ) {
                    var document = this.document[ 0 ];

                    // Only need to blur if the event occurred on the draggable itself, see #10527
                    if ( !this.handleElement.is( event.target ) ) {
                        return;
                    }

                    // support: IE9
                    // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
                    try {

                        // Support: IE9, IE10
                        // If the <body> is blurred, IE will switch windows, see #9520
                        if ( document.activeElement && document.activeElement.nodeName.toLowerCase() !== "body" ) {

                            // Blur any element that currently has focus, see #4261
                            kcaseQuery( document.activeElement ).blur();
                        }
                    } catch ( error ) {}
                },

                _mouseStart: function(event) {

                    var o = this.options;

                    //Create and append the visible helper
                    this.helper = this._createHelper(event);

                    this.helper.addClass("ui-draggable-dragging");

                    //Cache the helper size
                    this._cacheHelperProportions();

                    //If ddmanager is used for droppables, set the global draggable
                    if (kcaseQuery.ui.ddmanager) {
                        kcaseQuery.ui.ddmanager.current = this;
                    }

                    /*
                     * - Position generation -
                     * This block generates everything position related - it's the core of draggables.
                     */

                    //Cache the margins of the original element
                    this._cacheMargins();

                    //Store the helper's css position
                    this.cssPosition = this.helper.css( "position" );
                    this.scrollParent = this.helper.scrollParent( true );
                    this.offsetParent = this.helper.offsetParent();
                    this.hasFixedAncestor = this.helper.parents().filter(function() {
                            return kcaseQuery( this ).css( "position" ) === "fixed";
                        }).length > 0;

                    //The element's absolute position on the page minus margins
                    this.positionAbs = this.element.offset();
                    this._refreshOffsets( event );

                    //Generate the original position
                    this.originalPosition = this.position = this._generatePosition( event, false );
                    this.originalPageX = event.pageX;
                    this.originalPageY = event.pageY;

                    //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
                    (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

                    //Set a containment if given in the options
                    this._setContainment();

                    //Trigger event + callbacks
                    if (this._trigger("start", event) === false) {
                        this._clear();
                        return false;
                    }

                    //Recache the helper size
                    this._cacheHelperProportions();

                    //Prepare the droppable offsets
                    if (kcaseQuery.ui.ddmanager && !o.dropBehaviour) {
                        kcaseQuery.ui.ddmanager.prepareOffsets(this, event);
                    }

                    // Reset helper's right/bottom css if they're set and set explicit width/height instead
                    // as this prevents resizing of elements with right/bottom set (see #7772)
                    this._normalizeRightBottom();

                    this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

                    //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
                    if ( kcaseQuery.ui.ddmanager ) {
                        kcaseQuery.ui.ddmanager.dragStart(this, event);
                    }

                    return true;
                },

                _refreshOffsets: function( event ) {
                    this.offset = {
                        top: this.positionAbs.top - this.margins.top,
                        left: this.positionAbs.left - this.margins.left,
                        scroll: false,
                        parent: this._getParentOffset(),
                        relative: this._getRelativeOffset()
                    };

                    this.offset.click = {
                        left: event.pageX - this.offset.left,
                        top: event.pageY - this.offset.top
                    };
                },

                _mouseDrag: function(event, noPropagation) {
                    // reset any necessary cached properties (see #5009)
                    if ( this.hasFixedAncestor ) {
                        this.offset.parent = this._getParentOffset();
                    }

                    //Compute the helpers position
                    this.position = this._generatePosition( event, true );
                    this.positionAbs = this._convertPositionTo("absolute");

                    //Call plugins and callbacks and use the resulting position if something is returned
                    if (!noPropagation) {
                        var ui = this._uiHash();
                        if (this._trigger("drag", event, ui) === false) {
                            this._mouseUp({});
                            return false;
                        }
                        this.position = ui.position;
                    }

                    this.helper[ 0 ].style.left = this.position.left + "px";
                    this.helper[ 0 ].style.top = this.position.top + "px";

                    if (kcaseQuery.ui.ddmanager) {
                        kcaseQuery.ui.ddmanager.drag(this, event);
                    }

                    return false;
                },

                _mouseStop: function(event) {

                    //If we are using droppables, inform the manager about the drop
                    var that = this,
                        dropped = false;
                    if (kcaseQuery.ui.ddmanager && !this.options.dropBehaviour) {
                        dropped = kcaseQuery.ui.ddmanager.drop(this, event);
                    }

                    //if a drop comes from outside (a sortable)
                    if (this.dropped) {
                        dropped = this.dropped;
                        this.dropped = false;
                    }

                    if ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || (kcaseQuery.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
                        kcaseQuery(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
                            if (that._trigger("stop", event) !== false) {
                                that._clear();
                            }
                        });
                    } else {
                        if (this._trigger("stop", event) !== false) {
                            this._clear();
                        }
                    }

                    return false;
                },

                _mouseUp: function( event ) {
                    this._unblockFrames();

                    //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
                    if ( kcaseQuery.ui.ddmanager ) {
                        kcaseQuery.ui.ddmanager.dragStop(this, event);
                    }

                    // Only need to focus if the event occurred on the draggable itself, see #10527
                    if ( this.handleElement.is( event.target ) ) {
                        // The interaction is over; whether or not the click resulted in a drag, focus the element
                        this.element.focus();
                    }

                    return kcaseQuery.ui.mouse.prototype._mouseUp.call(this, event);
                },

                cancel: function() {

                    if (this.helper.is(".ui-draggable-dragging")) {
                        this._mouseUp({});
                    } else {
                        this._clear();
                    }

                    return this;

                },

                _getHandle: function(event) {
                    return this.options.handle ?
                        !!kcaseQuery( event.target ).closest( this.element.find( this.options.handle ) ).length :
                        true;
                },

                _setHandleClassName: function() {
                    this.handleElement = this.options.handle ?
                        this.element.find( this.options.handle ) : this.element;
                    this.handleElement.addClass( "ui-draggable-handle" );
                },

                _removeHandleClassName: function() {
                    this.handleElement.removeClass( "ui-draggable-handle" );
                },

                _createHelper: function(event) {

                    var o = this.options,
                        helperIsFunction = kcaseQuery.isFunction( o.helper ),
                        helper = helperIsFunction ?
                            kcaseQuery( o.helper.apply( this.element[ 0 ], [ event ] ) ) :
                            ( o.helper === "clone" ?
                                this.element.clone().removeAttr( "id" ) :
                                this.element );

                    if (!helper.parents("body").length) {
                        helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
                    }

                    // http://bugs.jqueryui.com/ticket/9446
                    // a helper function can return the original element
                    // which wouldn't have been set to relative in _create
                    if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {
                        this._setPositionRelative();
                    }

                    if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
                        helper.css("position", "absolute");
                    }

                    return helper;

                },

                _setPositionRelative: function() {
                    if ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {
                        this.element[ 0 ].style.position = "relative";
                    }
                },

                _adjustOffsetFromHelper: function(obj) {
                    if (typeof obj === "string") {
                        obj = obj.split(" ");
                    }
                    if (kcaseQuery.isArray(obj)) {
                        obj = { left: +obj[0], top: +obj[1] || 0 };
                    }
                    if ("left" in obj) {
                        this.offset.click.left = obj.left + this.margins.left;
                    }
                    if ("right" in obj) {
                        this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
                    }
                    if ("top" in obj) {
                        this.offset.click.top = obj.top + this.margins.top;
                    }
                    if ("bottom" in obj) {
                        this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
                    }
                },

                _isRootNode: function( element ) {
                    return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
                },

                _getParentOffset: function() {

                    //Get the offsetParent and cache its position
                    var po = this.offsetParent.offset(),
                        document = this.document[ 0 ];

                    // This is a special case where we need to modify a offset calculated on start, since the following happened:
                    // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
                    // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
                    //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
                    if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && kcaseQuery.contains(this.scrollParent[0], this.offsetParent[0])) {
                        po.left += this.scrollParent.scrollLeft();
                        po.top += this.scrollParent.scrollTop();
                    }

                    if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
                        po = { top: 0, left: 0 };
                    }

                    return {
                        top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                        left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
                    };

                },

                _getRelativeOffset: function() {
                    if ( this.cssPosition !== "relative" ) {
                        return { top: 0, left: 0 };
                    }

                    var p = this.element.position(),
                        scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

                    return {
                        top: p.top - ( parseInt(this.helper.css( "top" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
                        left: p.left - ( parseInt(this.helper.css( "left" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
                    };

                },

                _cacheMargins: function() {
                    this.margins = {
                        left: (parseInt(this.element.css("marginLeft"), 10) || 0),
                        top: (parseInt(this.element.css("marginTop"), 10) || 0),
                        right: (parseInt(this.element.css("marginRight"), 10) || 0),
                        bottom: (parseInt(this.element.css("marginBottom"), 10) || 0)
                    };
                },

                _cacheHelperProportions: function() {
                    this.helperProportions = {
                        width: this.helper.outerWidth(),
                        height: this.helper.outerHeight()
                    };
                },

                _setContainment: function() {

                    var isUserScrollable, c, ce,
                        o = this.options,
                        document = this.document[ 0 ];

                    this.relativeContainer = null;

                    if ( !o.containment ) {
                        this.containment = null;
                        return;
                    }

                    if ( o.containment === "window" ) {
                        this.containment = [
                            kcaseQuery( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
                            kcaseQuery( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
                            kcaseQuery( window ).scrollLeft() + kcaseQuery( window ).width() - this.helperProportions.width - this.margins.left,
                            kcaseQuery( window ).scrollTop() + ( kcaseQuery( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
                        ];
                        return;
                    }

                    if ( o.containment === "document") {
                        this.containment = [
                            0,
                            0,
                            kcaseQuery( document ).width() - this.helperProportions.width - this.margins.left,
                            ( kcaseQuery( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
                        ];
                        return;
                    }

                    if ( o.containment.constructor === Array ) {
                        this.containment = o.containment;
                        return;
                    }

                    if ( o.containment === "parent" ) {
                        o.containment = this.helper[ 0 ].parentNode;
                    }

                    c = kcaseQuery( o.containment );
                    ce = c[ 0 ];

                    if ( !ce ) {
                        return;
                    }

                    isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );

                    this.containment = [
                        ( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
                        ( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
                        ( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
                        ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -
                        ( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -
                        this.helperProportions.width -
                        this.margins.left -
                        this.margins.right,
                        ( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
                        ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -
                        ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -
                        this.helperProportions.height -
                        this.margins.top -
                        this.margins.bottom
                    ];
                    this.relativeContainer = c;
                },

                _convertPositionTo: function(d, pos) {

                    if (!pos) {
                        pos = this.position;
                    }

                    var mod = d === "absolute" ? 1 : -1,
                        scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

                    return {
                        top: (
                            pos.top	+																// The absolute mouse position
                            this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
                            this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
                            ( ( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod)
                        ),
                        left: (
                            pos.left +																// The absolute mouse position
                            this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
                            this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
                            ( ( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod)
                        )
                    };

                },

                _generatePosition: function( event, constrainPosition ) {

                    var containment, co, top, left,
                        o = this.options,
                        scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
                        pageX = event.pageX,
                        pageY = event.pageY;

                    // Cache the scroll
                    if ( !scrollIsRootNode || !this.offset.scroll ) {
                        this.offset.scroll = {
                            top: this.scrollParent.scrollTop(),
                            left: this.scrollParent.scrollLeft()
                        };
                    }

                    /*
                     * - Position constraining -
                     * Constrain the position to a mix of grid, containment.
                     */

                    // If we are not dragging yet, we won't check for options
                    if ( constrainPosition ) {
                        if ( this.containment ) {
                            if ( this.relativeContainer ){
                                co = this.relativeContainer.offset();
                                containment = [
                                    this.containment[ 0 ] + co.left,
                                    this.containment[ 1 ] + co.top,
                                    this.containment[ 2 ] + co.left,
                                    this.containment[ 3 ] + co.top
                                ];
                            } else {
                                containment = this.containment;
                            }

                            if (event.pageX - this.offset.click.left < containment[0]) {
                                pageX = containment[0] + this.offset.click.left;
                            }
                            if (event.pageY - this.offset.click.top < containment[1]) {
                                pageY = containment[1] + this.offset.click.top;
                            }
                            if (event.pageX - this.offset.click.left > containment[2]) {
                                pageX = containment[2] + this.offset.click.left;
                            }
                            if (event.pageY - this.offset.click.top > containment[3]) {
                                pageY = containment[3] + this.offset.click.top;
                            }
                        }

                        if (o.grid) {
                            //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
                            top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
                            pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

                            left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
                            pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
                        }

                        if ( o.axis === "y" ) {
                            pageX = this.originalPageX;
                        }

                        if ( o.axis === "x" ) {
                            pageY = this.originalPageY;
                        }
                    }

                    return {
                        top: (
                            pageY -																	// The absolute mouse position
                            this.offset.click.top	-												// Click offset (relative to the element)
                            this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
                            this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
                            ( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
                        ),
                        left: (
                            pageX -																	// The absolute mouse position
                            this.offset.click.left -												// Click offset (relative to the element)
                            this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
                            this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
                            ( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
                        )
                    };

                },

                _clear: function() {
                    this.helper.removeClass("ui-draggable-dragging");
                    if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
                        this.helper.remove();
                    }
                    this.helper = null;
                    this.cancelHelperRemoval = false;
                    if ( this.destroyOnClear ) {
                        this.destroy();
                    }
                },

                _normalizeRightBottom: function() {
                    if ( this.options.axis !== "y" && this.helper.css( "right" ) !== "auto" ) {
                        this.helper.width( this.helper.width() );
                        this.helper.css( "right", "auto" );
                    }
                    if ( this.options.axis !== "x" && this.helper.css( "bottom" ) !== "auto" ) {
                        this.helper.height( this.helper.height() );
                        this.helper.css( "bottom", "auto" );
                    }
                },

                // From now on bulk stuff - mainly helpers

                _trigger: function( type, event, ui ) {
                    ui = ui || this._uiHash();
                    kcaseQuery.ui.plugin.call( this, type, [ event, ui, this ], true );

                    // Absolute position and offset (see #6884 ) have to be recalculated after plugins
                    if ( /^(drag|start|stop)/.test( type ) ) {
                        this.positionAbs = this._convertPositionTo( "absolute" );
                        ui.offset = this.positionAbs;
                    }
                    return kcaseQuery.Widget.prototype._trigger.call( this, type, event, ui );
                },

                plugins: {},

                _uiHash: function() {
                    return {
                        helper: this.helper,
                        position: this.position,
                        originalPosition: this.originalPosition,
                        offset: this.positionAbs
                    };
                }

            });

            kcaseQuery.ui.plugin.add( "draggable", "connectToSortable", {
                start: function( event, ui, draggable ) {
                    var uiSortable = kcaseQuery.extend( {}, ui, {
                        item: draggable.element
                    });

                    draggable.sortables = [];
                    kcaseQuery( draggable.options.connectToSortable ).each(function() {
                        var sortable = kcaseQuery( this ).sortable( "instance" );

                        if ( sortable && !sortable.options.disabled ) {
                            draggable.sortables.push( sortable );

                            // refreshPositions is called at drag start to refresh the containerCache
                            // which is used in drag. This ensures it's initialized and synchronized
                            // with any changes that might have happened on the page since initialization.
                            sortable.refreshPositions();
                            sortable._trigger("activate", event, uiSortable);
                        }
                    });
                },
                stop: function( event, ui, draggable ) {
                    var uiSortable = kcaseQuery.extend( {}, ui, {
                        item: draggable.element
                    });

                    draggable.cancelHelperRemoval = false;

                    kcaseQuery.each( draggable.sortables, function() {
                        var sortable = this;

                        if ( sortable.isOver ) {
                            sortable.isOver = 0;

                            // Allow this sortable to handle removing the helper
                            draggable.cancelHelperRemoval = true;
                            sortable.cancelHelperRemoval = false;

                            // Use _storedCSS To restore properties in the sortable,
                            // as this also handles revert (#9675) since the draggable
                            // may have modified them in unexpected ways (#8809)
                            sortable._storedCSS = {
                                position: sortable.placeholder.css( "position" ),
                                top: sortable.placeholder.css( "top" ),
                                left: sortable.placeholder.css( "left" )
                            };

                            sortable._mouseStop(event);

                            // Once drag has ended, the sortable should return to using
                            // its original helper, not the shared helper from draggable
                            sortable.options.helper = sortable.options._helper;
                        } else {
                            // Prevent this Sortable from removing the helper.
                            // However, don't set the draggable to remove the helper
                            // either as another connected Sortable may yet handle the removal.
                            sortable.cancelHelperRemoval = true;

                            sortable._trigger( "deactivate", event, uiSortable );
                        }
                    });
                },
                drag: function( event, ui, draggable ) {
                    kcaseQuery.each( draggable.sortables, function() {
                        var innermostIntersecting = false,
                            sortable = this;

                        // Copy over variables that sortable's _intersectsWith uses
                        sortable.positionAbs = draggable.positionAbs;
                        sortable.helperProportions = draggable.helperProportions;
                        sortable.offset.click = draggable.offset.click;

                        if ( sortable._intersectsWith( sortable.containerCache ) ) {
                            innermostIntersecting = true;

                            kcaseQuery.each( draggable.sortables, function() {
                                // Copy over variables that sortable's _intersectsWith uses
                                this.positionAbs = draggable.positionAbs;
                                this.helperProportions = draggable.helperProportions;
                                this.offset.click = draggable.offset.click;

                                if ( this !== sortable &&
                                    this._intersectsWith( this.containerCache ) &&
                                    kcaseQuery.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {
                                    innermostIntersecting = false;
                                }

                                return innermostIntersecting;
                            });
                        }

                        if ( innermostIntersecting ) {
                            // If it intersects, we use a little isOver variable and set it once,
                            // so that the move-in stuff gets fired only once.
                            if ( !sortable.isOver ) {
                                sortable.isOver = 1;

                                // Store draggable's parent in case we need to reappend to it later.
                                draggable._parent = ui.helper.parent();

                                sortable.currentItem = ui.helper
                                    .appendTo( sortable.element )
                                    .data( "ui-sortable-item", true );

                                // Store helper option to later restore it
                                sortable.options._helper = sortable.options.helper;

                                sortable.options.helper = function() {
                                    return ui.helper[ 0 ];
                                };

                                // Fire the start events of the sortable with our passed browser event,
                                // and our own helper (so it doesn't create a new one)
                                event.target = sortable.currentItem[ 0 ];
                                sortable._mouseCapture( event, true );
                                sortable._mouseStart( event, true, true );

                                // Because the browser event is way off the new appended portlet,
                                // modify necessary variables to reflect the changes
                                sortable.offset.click.top = draggable.offset.click.top;
                                sortable.offset.click.left = draggable.offset.click.left;
                                sortable.offset.parent.left -= draggable.offset.parent.left -
                                    sortable.offset.parent.left;
                                sortable.offset.parent.top -= draggable.offset.parent.top -
                                    sortable.offset.parent.top;

                                draggable._trigger( "toSortable", event );

                                // Inform draggable that the helper is in a valid drop zone,
                                // used solely in the revert option to handle "valid/invalid".
                                draggable.dropped = sortable.element;

                                // Need to refreshPositions of all sortables in the case that
                                // adding to one sortable changes the location of the other sortables (#9675)
                                kcaseQuery.each( draggable.sortables, function() {
                                    this.refreshPositions();
                                });

                                // hack so receive/update callbacks work (mostly)
                                draggable.currentItem = draggable.element;
                                sortable.fromOutside = draggable;
                            }

                            if ( sortable.currentItem ) {
                                sortable._mouseDrag( event );
                                // Copy the sortable's position because the draggable's can potentially reflect
                                // a relative position, while sortable is always absolute, which the dragged
                                // element has now become. (#8809)
                                ui.position = sortable.position;
                            }
                        } else {
                            // If it doesn't intersect with the sortable, and it intersected before,
                            // we fake the drag stop of the sortable, but make sure it doesn't remove
                            // the helper by using cancelHelperRemoval.
                            if ( sortable.isOver ) {

                                sortable.isOver = 0;
                                sortable.cancelHelperRemoval = true;

                                // Calling sortable's mouseStop would trigger a revert,
                                // so revert must be temporarily false until after mouseStop is called.
                                sortable.options._revert = sortable.options.revert;
                                sortable.options.revert = false;

                                sortable._trigger( "out", event, sortable._uiHash( sortable ) );
                                sortable._mouseStop( event, true );

                                // restore sortable behaviors that were modfied
                                // when the draggable entered the sortable area (#9481)
                                sortable.options.revert = sortable.options._revert;
                                sortable.options.helper = sortable.options._helper;

                                if ( sortable.placeholder ) {
                                    sortable.placeholder.remove();
                                }

                                // Restore and recalculate the draggable's offset considering the sortable
                                // may have modified them in unexpected ways. (#8809, #10669)
                                ui.helper.appendTo( draggable._parent );
                                draggable._refreshOffsets( event );
                                ui.position = draggable._generatePosition( event, true );

                                draggable._trigger( "fromSortable", event );

                                // Inform draggable that the helper is no longer in a valid drop zone
                                draggable.dropped = false;

                                // Need to refreshPositions of all sortables just in case removing
                                // from one sortable changes the location of other sortables (#9675)
                                kcaseQuery.each( draggable.sortables, function() {
                                    this.refreshPositions();
                                });
                            }
                        }
                    });
                }
            });

            kcaseQuery.ui.plugin.add("draggable", "cursor", {
                start: function( event, ui, instance ) {
                    var t = kcaseQuery( "body" ),
                        o = instance.options;

                    if (t.css("cursor")) {
                        o._cursor = t.css("cursor");
                    }
                    t.css("cursor", o.cursor);
                },
                stop: function( event, ui, instance ) {
                    var o = instance.options;
                    if (o._cursor) {
                        kcaseQuery("body").css("cursor", o._cursor);
                    }
                }
            });

            kcaseQuery.ui.plugin.add("draggable", "opacity", {
                start: function( event, ui, instance ) {
                    var t = kcaseQuery( ui.helper ),
                        o = instance.options;
                    if (t.css("opacity")) {
                        o._opacity = t.css("opacity");
                    }
                    t.css("opacity", o.opacity);
                },
                stop: function( event, ui, instance ) {
                    var o = instance.options;
                    if (o._opacity) {
                        kcaseQuery(ui.helper).css("opacity", o._opacity);
                    }
                }
            });

            kcaseQuery.ui.plugin.add("draggable", "scroll", {
                start: function( event, ui, i ) {
                    if ( !i.scrollParentNotHidden ) {
                        i.scrollParentNotHidden = i.helper.scrollParent( false );
                    }

                    if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] && i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {
                        i.overflowOffset = i.scrollParentNotHidden.offset();
                    }
                },
                drag: function( event, ui, i  ) {

                    var o = i.options,
                        scrolled = false,
                        scrollParent = i.scrollParentNotHidden[ 0 ],
                        document = i.document[ 0 ];

                    if ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {
                        if ( !o.axis || o.axis !== "x" ) {
                            if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY < o.scrollSensitivity ) {
                                scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
                            } else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {
                                scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
                            }
                        }

                        if ( !o.axis || o.axis !== "y" ) {
                            if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX < o.scrollSensitivity ) {
                                scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
                            } else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {
                                scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
                            }
                        }

                    } else {

                        if (!o.axis || o.axis !== "x") {
                            if (event.pageY - kcaseQuery(document).scrollTop() < o.scrollSensitivity) {
                                scrolled = kcaseQuery(document).scrollTop(kcaseQuery(document).scrollTop() - o.scrollSpeed);
                            } else if (kcaseQuery(window).height() - (event.pageY - kcaseQuery(document).scrollTop()) < o.scrollSensitivity) {
                                scrolled = kcaseQuery(document).scrollTop(kcaseQuery(document).scrollTop() + o.scrollSpeed);
                            }
                        }

                        if (!o.axis || o.axis !== "y") {
                            if (event.pageX - kcaseQuery(document).scrollLeft() < o.scrollSensitivity) {
                                scrolled = kcaseQuery(document).scrollLeft(kcaseQuery(document).scrollLeft() - o.scrollSpeed);
                            } else if (kcaseQuery(window).width() - (event.pageX - kcaseQuery(document).scrollLeft()) < o.scrollSensitivity) {
                                scrolled = kcaseQuery(document).scrollLeft(kcaseQuery(document).scrollLeft() + o.scrollSpeed);
                            }
                        }

                    }

                    if (scrolled !== false && kcaseQuery.ui.ddmanager && !o.dropBehaviour) {
                        kcaseQuery.ui.ddmanager.prepareOffsets(i, event);
                    }

                }
            });

            kcaseQuery.ui.plugin.add("draggable", "snap", {
                start: function( event, ui, i ) {

                    var o = i.options;

                    i.snapElements = [];

                    kcaseQuery(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
                        var $t = kcaseQuery(this),
                            $o = $t.offset();
                        if (this !== i.element[0]) {
                            i.snapElements.push({
                                item: this,
                                width: $t.outerWidth(), height: $t.outerHeight(),
                                top: $o.top, left: $o.left
                            });
                        }
                    });

                },
                drag: function( event, ui, inst ) {

                    var ts, bs, ls, rs, l, r, t, b, i, first,
                        o = inst.options,
                        d = o.snapTolerance,
                        x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
                        y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

                    for (i = inst.snapElements.length - 1; i >= 0; i--){

                        l = inst.snapElements[i].left - inst.margins.left;
                        r = l + inst.snapElements[i].width;
                        t = inst.snapElements[i].top - inst.margins.top;
                        b = t + inst.snapElements[i].height;

                        if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !kcaseQuery.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
                            if (inst.snapElements[i].snapping) {
                                (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, kcaseQuery.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
                            }
                            inst.snapElements[i].snapping = false;
                            continue;
                        }

                        if (o.snapMode !== "inner") {
                            ts = Math.abs(t - y2) <= d;
                            bs = Math.abs(b - y1) <= d;
                            ls = Math.abs(l - x2) <= d;
                            rs = Math.abs(r - x1) <= d;
                            if (ts) {
                                ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top;
                            }
                            if (bs) {
                                ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top;
                            }
                            if (ls) {
                                ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left;
                            }
                            if (rs) {
                                ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left;
                            }
                        }

                        first = (ts || bs || ls || rs);

                        if (o.snapMode !== "outer") {
                            ts = Math.abs(t - y1) <= d;
                            bs = Math.abs(b - y2) <= d;
                            ls = Math.abs(l - x1) <= d;
                            rs = Math.abs(r - x2) <= d;
                            if (ts) {
                                ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top;
                            }
                            if (bs) {
                                ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top;
                            }
                            if (ls) {
                                ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left;
                            }
                            if (rs) {
                                ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left;
                            }
                        }

                        if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
                            (inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, kcaseQuery.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
                        }
                        inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

                    }

                }
            });

            kcaseQuery.ui.plugin.add("draggable", "stack", {
                start: function( event, ui, instance ) {
                    var min,
                        o = instance.options,
                        group = kcaseQuery.makeArray(kcaseQuery(o.stack)).sort(function(a, b) {
                            return (parseInt(kcaseQuery(a).css("zIndex"), 10) || 0) - (parseInt(kcaseQuery(b).css("zIndex"), 10) || 0);
                        });

                    if (!group.length) { return; }

                    min = parseInt(kcaseQuery(group[0]).css("zIndex"), 10) || 0;
                    kcaseQuery(group).each(function(i) {
                        kcaseQuery(this).css("zIndex", min + i);
                    });
                    this.css("zIndex", (min + group.length));
                }
            });

            kcaseQuery.ui.plugin.add("draggable", "zIndex", {
                start: function( event, ui, instance ) {
                    var t = kcaseQuery( ui.helper ),
                        o = instance.options;

                    if (t.css("zIndex")) {
                        o._zIndex = t.css("zIndex");
                    }
                    t.css("zIndex", o.zIndex);
                },
                stop: function( event, ui, instance ) {
                    var o = instance.options;

                    if (o._zIndex) {
                        kcaseQuery(ui.helper).css("zIndex", o._zIndex);
                    }
                }
            });

            var draggable = kcaseQuery.ui.draggable;

        }));

        this.getOwnPropertyNames = function(obj) {
            var arr = [];
            for (var k in obj) {
                if (obj.hasOwnProperty(k))
                    arr.push(k);
            }
            return arr;
        };

        this.getSelectedObject = function (classId) {
            var idStr, selectedObj = undefined;

            idStr = "." + classId;

            for (var i = 0, tempObject = kcaseQuery(idStr); i < tempObject.length; tempObject = tempObject.next()) {

                if (tempObject.data("selected") == 1) {
                    selectedObj = tempObject.eq(i);
                    break;
                }
            }

            return selectedObj;
        };

        this.setOption = function (options, input) {
            input = kcaseQuery.makeArray(input);
            var inputIndex = 0,
                inputLength = input.length,
                key,
                value;
            for (; inputIndex < inputLength; inputIndex++) {
                for (key in input[inputIndex]) {
                    value = input[inputIndex][key];
                    if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
                        // Clone objects
                        if (kcaseQuery.isPlainObject(value)) {
                            options[key] = kcaseQuery.isPlainObject(options[key]) ?
                                test({}, options[key], value) :
                                // Don't extend strings, arrays, etc. with objects
                                test({}, value);
                            // Copy everything else by reference
                        } else {
                            options[key] = value;
                        }
                    }
                }
            }
            return options;
        };

        // Get Password
        this.getInputPassword = function(dialogId) {
            var pw, passObject;

            if (!prop.usingNosAdapter) {
                passObject = {
                    IsSec: 0,
                    Data: kcaseQuery("#" + dialogId + " ." + prop.cs.pwBox).val()
                };
                pw = JSON.stringify(passObject);
                return pw;
            } else {
                // nProtect Keyboard Security
                var name = kcaseQuery("#" + dialogId + " ." + prop.cs.pwBox).attr("name");
                try {
                    passObject = {
                        IsSec: 1,
                        Table: npPfsCtrl.GetResultField(name + "form", name),
                        Data: npPfsCtrl.GetReplaceField(name + "form", name)
                    };
                    if (passObject.Data.length > 0) {
                        pw = JSON.stringify(passObject);
                        return pw;
                    } else {
                        return "";
                    }
                } catch(e) {
                    log.d(e);
                    return undefined;
                }
            }
        };

        // Verify a valid password
        this.verifyInputPassword = function(_pw, _media) {
            if (_pw === undefined) {
                alert(prop.strings.NO_KEYBOARD_SECURITY);
                return false;
            }
            var contact = JSON.parse(_pw);
					
            if (contact.Data.length <= 0) {
                switch (_media) {
                    case prop.media.pkcs11:
                        alert(prop.strings.NO_INPUT_PIN);
                        break;
                    case prop.media.savetoken:
                        alert(prop.strings.NO_INPUT_ST);
                        break;
                    default:
                        alert(prop.strings.NO_INPUT_PASSWORD);
                        kcaseQuery("#" + prop.id.dialog.cert + " ." + prop.cs.pwBox).val("");
                }
                return false;
            }

            return true;
        };

        this.loadDefaultCertListSize = function() {
            kcaseQuery(".kc-mcert").css("width", "98px");
            kcaseQuery(".kc-mcert2").css("width", "158px");
            kcaseQuery(".kc-mcert3").css("width", "72px");
            kcaseQuery(".kc-mcert4").css("width", "72px");
        };

        var interId;

        this.onKeepAliveProc = function() {
            interId = setInterval(_proc, prop.intervalTime);

            function _proc() {
                comm.reqAgentKeepAlive(function(result) {
                    if (result.Status != prop.success) {
                        clearInterval(interId);
                    }
                });
            }
        };

        this.offKeepAliveProc = function() {
            clearInterval(interId);
        };

        this.spinner = {
            show: function (isOverlay) {
            	if(typeof(ksign_visibleLoading) == "undefined" || ksign_visibleLoading == true) {
                var color = "";
                if (isOverlay != undefined) {
                    color = "background-color:rgba(0, 0, 0, 0.5);";
                }

                var overlayEl = kcaseQuery('<div class="isloading-overlay" style="'+color+'position:fixed; left:0; top:0; z-index: 10000; width: 100%; height: ' + kcaseQuery(window).height() + 'px;" />');
                kcaseQuery("body").prepend(overlayEl);

                var libRoot = prop.ROOT_DIR;
                var imgPath = libRoot + "/img/loading.png";

                var imgEl = kcaseQuery('<div style="background: url(' + imgPath + '); position:fixed; left:'+ ((kcaseQuery(window).width()/2) - 175) +'px; top: '+ (((kcaseQuery(window).height())/2) - 100) +'px; z-index: 10001; width: 350px; height: 187px;" />');
                
								imgEl.on("mouseup", function(e) {
               		kcaseQuery("body").find(".isloading-overlay").remove();
            		});
                kcaseQuery("body").find(".isloading-overlay").first().prepend(imgEl);
							}
            },
            hide: function () {
            	if(typeof(ksign_visibleLoading) == "undefined" || ksign_visibleLoading == true){
                kcaseQuery("body").find(".isloading-overlay").remove();
              }
            }
        };

        this.getElementsByClassName = function(cl) {
            var retnode = [];
            var elem = document.getElementsByTagName('*');
            for (var i = 0; i < elem.length; i++) {
                if((' ' + elem[i].className + ' ').indexOf(' ' + cl + ' ') > -1) retnode.push(elem[i]);
            }
            return retnode;
        };

        function _browserDetect() {
            var BrowserDetect = {
                init: function () {
                    this.browser = this.searchString(this.dataBrowser) || "An unknown browser";
                    this.version = this.searchVersion(navigator.userAgent)
                        || this.searchVersion(navigator.appVersion)
                        || "an unknown version";
                    this.OS = this.searchString(this.dataOS) || "an unknown OS";
                },
                searchString: function (data) {
                    for (var i = 0; i < data.length; i++) {
                        var dataString = data[i].string;
                        var dataProp = data[i].prop;
                        this.versionSearchString = data[i].versionSearch || data[i].identity;
                        if (dataString) {
                            if (dataString.indexOf(data[i].subString) != -1)
                                return data[i].identity;
                        }
                        else if (dataProp)
                            return data[i].identity;
                    }
                },
                searchVersion: function (dataString) {
                    var index = dataString.indexOf(this.versionSearchString);
                    if (index == -1) return;
                    return parseFloat(dataString.substring(index + this.versionSearchString.length + 1));
                },
                dataBrowser: [
                    {
                        string: navigator.userAgent,
                        subString: "Chrome",
                        identity: "Chrome"
                    },
                    {
                        string: navigator.userAgent,
                        subString: "OmniWeb",
                        versionSearch: "OmniWeb/",
                        identity: "OmniWeb"
                    },
                    {
                        string: navigator.vendor,
                        subString: "Apple",
                        identity: "Safari",
                        versionSearch: "Version"
                    },
                    /*{
                     prop: window.opera,
                     identity: "Opera",
                     versionSearch: "Version"
                     },*/
                    {
                        string: navigator.userAgent,
                        subString: "OPR",
                        identity: "OPR",
                        versionSearch: "OPR"
                    },
                    {
                        string: navigator.vendor,
                        subString: "iCab",
                        identity: "iCab"
                    },
                    {
                        string: navigator.vendor,
                        subString: "KDE",
                        identity: "Konqueror"
                    },
                    {
                        string: navigator.userAgent,
                        subString: "Firefox",
                        identity: "Firefox"
                    },
                    {
                        string: navigator.vendor,
                        subString: "Camino",
                        identity: "Camino"
                    },
                    {		// for newer Netscapes (6+)
                        string: navigator.userAgent,
                        subString: "Netscape",
                        identity: "Netscape"
                    },
                    {
                        string: navigator.userAgent,
                        subString: "MSIE",
                        identity: "Explorer",
                        versionSearch: "MSIE"
                    },
                    {
                        string: navigator.userAgent,
                        subString: "Gecko",
                        identity: "Mozilla",
                        versionSearch: "rv"
                    },
                    { 		// for older Netscapes (4-)
                        string: navigator.userAgent,
                        subString: "Mozilla",
                        identity: "Netscape",
                        versionSearch: "Mozilla"
                    }
                ],
                dataOS: [
                    {
                        string: navigator.platform,
                        subString: "Win",
                        identity: "Windows"
                    },
                    {
                        string: navigator.platform,
                        subString: "Mac",
                        identity: "Mac"
                    },
                    {
                        string: navigator.userAgent,
                        subString: "iPhone",
                        identity: "iPhone/iPod"
                    },
                    {
                        string: navigator.platform,
                        subString: "Linux",
                        identity: "Linux"
                    }
                ]

            };

            BrowserDetect.init();

            var isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;

            if (isOpera == true) {
                BrowserDetect.browser = "Opera";
            }

            var isSwing = navigator.userAgent.indexOf(' Swing/') >= 0;

            if (isSwing == true) {
                BrowserDetect.browser = "Swing";
            }

            return BrowserDetect;
        }

        var browserObj = new _browserDetect();

        this.getBrowserName = function() {
            return browserObj.browser;
        };

        this.getBrowserVersion = function() {
            return browserObj.version;
        };

        this.getOSName = function() {
            return browserObj.OS;
        };

        // define isArray
        this.isArray = Array.isArray || function (x) {
                return Object.prototype.toString.call(x) === '[object Array]';
            };

        // define isArrayBuffer
        this.isArrayBuffer = function (x) {
            return typeof ArrayBuffer !== 'undefined' && x instanceof ArrayBuffer;
        };

        // define isArrayBufferView
        var _arrayBufferViews = [];
        if (typeof DataView !== 'undefined') {
            _arrayBufferViews.push(DataView);
        }
        if (typeof Int8Array !== 'undefined') {
            _arrayBufferViews.push(Int8Array);
        }
        if (typeof Uint8Array !== 'undefined') {
            _arrayBufferViews.push(Uint8Array);
        }
        if (typeof Uint8ClampedArray !== 'undefined') {
            _arrayBufferViews.push(Uint8ClampedArray);
        }
        if (typeof Int16Array !== 'undefined') {
            _arrayBufferViews.push(Int16Array);
        }
        if (typeof Uint16Array !== 'undefined') {
            _arrayBufferViews.push(Uint16Array);
        }
        if (typeof Int32Array !== 'undefined') {
            _arrayBufferViews.push(Int32Array);
        }
        if (typeof Uint32Array !== 'undefined') {
            _arrayBufferViews.push(Uint32Array);
        }
        if (typeof Float32Array !== 'undefined') {
            _arrayBufferViews.push(Float32Array);
        }
        if (typeof Float64Array !== 'undefined') {
            _arrayBufferViews.push(Float64Array);
        }
        this.isArrayBufferView = function (x) {
            for (var i = 0; i < _arrayBufferViews.length; ++i) {
                if (x instanceof _arrayBufferViews[i]) {
                    return true;
                }
            }
            return false;
        };

        this.ByteBuffer = ByteStringBuffer;

        function ByteStringBuffer(b) {
            // TODO: update to match DataBuffer API

            // the data in this buffer
            this.data = '';
            // the pointer for reading from this buffer
            this.read = 0;

            if (typeof b === 'string') {
                this.data = b;
            } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
                // convert native buffer to forge buffer
                // FIXME: support native buffers internally instead
                var arr = new Uint8Array(b);
                try {
                    this.data = String.fromCharCode.apply(null, arr);
                } catch (e) {
                    for (var i = 0; i < arr.length; ++i) {
                        this.putByte(arr[i]);
                    }
                }
            } else if (b instanceof ByteStringBuffer ||
                (typeof b === 'object' && typeof b.data === 'string' &&
                typeof b.read === 'number')) {
                // copy existing buffer
                this.data = b.data;
                this.read = b.read;
            }

            // used for v8 optimization
            this._constructedStringLength = 0;
        }

        this.ByteStringBuffer = ByteStringBuffer;

        var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
        this.ByteStringBuffer.prototype._optimizeConstructedString = function (x) {
            this._constructedStringLength += x;
            if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
                // this substr() should cause the constructed string to join
                this.data.substr(0, 1);
                this._constructedStringLength = 0;
            }
        };

        this.ByteStringBuffer.prototype.length = function () {
            return this.data.length - this.read;
        };

        this.ByteStringBuffer.prototype.isEmpty = function () {
            return this.length() <= 0;
        };

        this.ByteStringBuffer.prototype.putByte = function (b) {
            return this.putBytes(String.fromCharCode(b));
        };

        this.ByteStringBuffer.prototype.fillWithByte = function (b, n) {
            b = String.fromCharCode(b);
            var d = this.data;
            while (n > 0) {
                if (n & 1) {
                    d += b;
                }
                n >>>= 1;
                if (n > 0) {
                    b += b;
                }
            }
            this.data = d;
            this._optimizeConstructedString(n);
            return this;
        };

        this.ByteStringBuffer.prototype.putBytes = function (bytes) {
            this.data += bytes;
            this._optimizeConstructedString(bytes.length);
            return this;
        };

        this.ByteStringBuffer.prototype.putString = function (str) {
            return this.putBytes(this.encodeUtf8(str));
        };

        this.ByteStringBuffer.prototype.putInt16 = function (i) {
            return this.putBytes(
                String.fromCharCode(i >> 8 & 0xFF) +
                String.fromCharCode(i & 0xFF));
        };

        this.ByteStringBuffer.prototype.putInt24 = function (i) {
            return this.putBytes(
                String.fromCharCode(i >> 16 & 0xFF) +
                String.fromCharCode(i >> 8 & 0xFF) +
                String.fromCharCode(i & 0xFF));
        };

        this.ByteStringBuffer.prototype.putInt32 = function (i) {
            return this.putBytes(
                String.fromCharCode(i >> 24 & 0xFF) +
                String.fromCharCode(i >> 16 & 0xFF) +
                String.fromCharCode(i >> 8 & 0xFF) +
                String.fromCharCode(i & 0xFF));
        };

        this.ByteStringBuffer.prototype.putInt16Le = function (i) {
            return this.putBytes(
                String.fromCharCode(i & 0xFF) +
                String.fromCharCode(i >> 8 & 0xFF));
        };

        this.ByteStringBuffer.prototype.putInt24Le = function (i) {
            return this.putBytes(
                String.fromCharCode(i & 0xFF) +
                String.fromCharCode(i >> 8 & 0xFF) +
                String.fromCharCode(i >> 16 & 0xFF));
        };

        this.ByteStringBuffer.prototype.putInt32Le = function (i) {
            return this.putBytes(
                String.fromCharCode(i & 0xFF) +
                String.fromCharCode(i >> 8 & 0xFF) +
                String.fromCharCode(i >> 16 & 0xFF) +
                String.fromCharCode(i >> 24 & 0xFF));
        };

        this.ByteStringBuffer.prototype.putInt = function (i, n) {
            var bytes = '';
            do {
                n -= 8;
                bytes += String.fromCharCode((i >> n) & 0xFF);
            } while (n > 0);
            return this.putBytes(bytes);
        };

        this.ByteStringBuffer.prototype.putSignedInt = function (i, n) {
            if (i < 0) {
                i += 2 << (n - 1);
            }
            return this.putInt(i, n);
        };

        this.ByteStringBuffer.prototype.putBuffer = function (buffer) {
            return this.putBytes(buffer.getBytes());
        };

        this.ByteStringBuffer.prototype.getByte = function () {
            return this.data.charCodeAt(this.read++);
        };

        this.ByteStringBuffer.prototype.getInt16 = function () {
            var rval = (
            this.data.charCodeAt(this.read) << 8 ^
            this.data.charCodeAt(this.read + 1));
            this.read += 2;
            return rval;
        };

        this.ByteStringBuffer.prototype.getInt24 = function () {
            var rval = (
            this.data.charCodeAt(this.read) << 16 ^
            this.data.charCodeAt(this.read + 1) << 8 ^
            this.data.charCodeAt(this.read + 2));
            this.read += 3;
            return rval;
        };

        this.ByteStringBuffer.prototype.getInt32 = function () {
            var rval = (
            this.data.charCodeAt(this.read) << 24 ^
            this.data.charCodeAt(this.read + 1) << 16 ^
            this.data.charCodeAt(this.read + 2) << 8 ^
            this.data.charCodeAt(this.read + 3));
            this.read += 4;
            return rval;
        };

        this.ByteStringBuffer.prototype.getInt16Le = function () {
            var rval = (
            this.data.charCodeAt(this.read) ^
            this.data.charCodeAt(this.read + 1) << 8);
            this.read += 2;
            return rval;
        };

        this.ByteStringBuffer.prototype.getInt24Le = function () {
            var rval = (
            this.data.charCodeAt(this.read) ^
            this.data.charCodeAt(this.read + 1) << 8 ^
            this.data.charCodeAt(this.read + 2) << 16);
            this.read += 3;
            return rval;
        };

        this.ByteStringBuffer.prototype.getInt32Le = function () {
            var rval = (
            this.data.charCodeAt(this.read) ^
            this.data.charCodeAt(this.read + 1) << 8 ^
            this.data.charCodeAt(this.read + 2) << 16 ^
            this.data.charCodeAt(this.read + 3) << 24);
            this.read += 4;
            return rval;
        };

        this.ByteStringBuffer.prototype.getInt = function (n) {
            var rval = 0;
            do {
                rval = (rval << 8) + this.data.charCodeAt(this.read++);
                n -= 8;
            } while (n > 0);
            return rval;
        };

        this.ByteStringBuffer.prototype.getSignedInt = function (n) {
            var x = this.getInt(n);
            var max = 2 << (n - 2);
            if (x >= max) {
                x -= max << 1;
            }
            return x;
        };

        this.ByteStringBuffer.prototype.getBytes = function (count) {
            var rval;
            if (count) {
                // read count bytes
                count = Math.min(this.length(), count);
                rval = this.data.slice(this.read, this.read + count);
                this.read += count;
            } else if (count === 0) {
                rval = '';
            } else {
                // read all bytes, optimize to only copy when needed
                rval = (this.read === 0) ? this.data : this.data.slice(this.read);
                this.clear();
            }
            return rval;
        };

        this.ByteStringBuffer.prototype.bytes = function (count) {
            return (typeof(count) === 'undefined' ?
                this.data.slice(this.read) :
                this.data.slice(this.read, this.read + count));
        };

        this.ByteStringBuffer.prototype.at = function (i) {
            return this.data.charCodeAt(this.read + i);
        };

        this.ByteStringBuffer.prototype.setAt = function (i, b) {
            this.data = this.data.substr(0, this.read + i) +
                String.fromCharCode(b) +
                this.data.substr(this.read + i + 1);
            return this;
        };

        this.ByteStringBuffer.prototype.last = function () {
            return this.data.charCodeAt(this.data.length - 1);
        };

        this.ByteStringBuffer.prototype.copy = function () {
            var c = this.createBuffer(this.data);
            c.read = this.read;
            return c;
        };

        this.ByteStringBuffer.prototype.compact = function () {
            if (this.read > 0) {
                this.data = this.data.slice(this.read);
                this.read = 0;
            }
            return this;
        };

        this.ByteStringBuffer.prototype.clear = function () {
            this.data = '';
            this.read = 0;
            return this;
        };

        this.ByteStringBuffer.prototype.truncate = function (count) {
            var len = Math.max(0, this.length() - count);
            this.data = this.data.substr(this.read, len);
            this.read = 0;
            return this;
        };

        this.ByteStringBuffer.prototype.toHex = function () {
            var rval = '';
            for (var i = this.read; i < this.data.length; ++i) {
                var b = this.data.charCodeAt(i);
                if (b < 16) {
                    rval += '0';
                }
                rval += b.toString(16);
            }
            return rval;
        };

        this.ByteStringBuffer.prototype.toString = function () {
            return util.decodeUtf8(this.bytes());
        };

        function DataBuffer(b, options) {
            // default options
            options = options || {};

            // pointers for read from/write to buffer
            this.read = options.readOffset || 0;
            this.growSize = options.growSize || 1024;

            var isArrayBuffer = this.isArrayBuffer(b);
            var isArrayBufferView = this.isArrayBufferView(b);
            if (isArrayBuffer || isArrayBufferView) {
                // use ArrayBuffer directly
                if (isArrayBuffer) {
                    this.data = new DataView(b);
                } else {
                    // TODO: adjust read/write offset based on the type of view
                    // or specify that this must be done in the options ... that the
                    // offsets are byte-based
                    this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
                }
                this.write = ('writeOffset' in options ?
                    options.writeOffset : this.data.byteLength);
                return;
            }

            // initialize to empty array buffer and add any given bytes using putBytes
            this.data = new DataView(new ArrayBuffer(0));
            this.write = 0;

            if (b !== null && b !== undefined) {
                this.putBytes(b);
            }

            if ('writeOffset' in options) {
                this.write = options.writeOffset;
            }
        }

        this.DataBuffer = DataBuffer;

        this.DataBuffer.prototype.length = function () {
            return this.write - this.read;
        };

        this.DataBuffer.prototype.isEmpty = function () {
            return this.length() <= 0;
        };

        this.DataBuffer.prototype.accommodate = function (amount, growSize) {
            if (this.length() >= amount) {
                return this;
            }
            growSize = Math.max(growSize || this.growSize, amount);

            // grow buffer
            var src = new Uint8Array(
                this.data.buffer, this.data.byteOffset, this.data.byteLength);
            var dst = new Uint8Array(this.length() + growSize);
            dst.set(src);
            this.data = new DataView(dst.buffer);

            return this;
        };

        this.DataBuffer.prototype.putByte = function (b) {
            this.accommodate(1);
            this.data.setUint8(this.write++, b);
            return this;
        };

        this.DataBuffer.prototype.fillWithByte = function (b, n) {
            this.accommodate(n);
            for (var i = 0; i < n; ++i) {
                this.data.setUint8(b);
            }
            return this;
        };

        this.DataBuffer.prototype.putBytes = function (bytes, encoding) {
            if (this.isArrayBufferView(bytes)) {
                var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
                var len = src.byteLength - src.byteOffset;
                this.accommodate(len);
                var dst = new Uint8Array(this.data.buffer, this.write);
                dst.set(src);
                this.write += len;
                return this;
            }

            if (this.isArrayBuffer(bytes)) {
                var src = new Uint8Array(bytes);
                this.accommodate(src.byteLength);
                var dst = new Uint8Array(this.data.buffer);
                dst.set(src, this.write);
                this.write += src.byteLength;
                return this;
            }

            // bytes is a this.DataBuffer or equivalent
            if (bytes instanceof this.DataBuffer ||
                (typeof bytes === 'object' &&
                typeof bytes.read === 'number' && typeof bytes.write === 'number' &&
                this.isArrayBufferView(bytes.data))) {
                var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
                this.accommodate(src.byteLength);
                var dst = new Uint8Array(bytes.data.byteLength, this.write);
                dst.set(src);
                this.write += src.byteLength;
                return this;
            }

            if (bytes instanceof this.ByteStringBuffer) {
                // copy binary string and process as the same as a string parameter below
                bytes = bytes.data;
                encoding = 'binary';
            }

            // string conversion
            encoding = encoding || 'binary';
            if (typeof bytes === 'string') {
                var view;

                // decode from string
                if (encoding === 'hex') {
                    this.accommodate(Math.ceil(bytes.length / 2));
                    view = new Uint8Array(this.data.buffer, this.write);
                    this.write += this.binary.hex.decode(bytes, view, this.write);
                    return this;
                }
                if (encoding === 'base64') {
                    this.accommodate(Math.ceil(bytes.length / 4) * 3);
                    view = new Uint8Array(this.data.buffer, this.write);
                    this.write += this.binary.base64.decode(bytes, view, this.write);
                    return this;
                }

                // encode text as UTF-8 bytes
                if (encoding === 'utf8') {
                    // encode as UTF-8 then decode string as raw binary
                    bytes = this.encodeUtf8(bytes);
                    encoding = 'binary';
                }

                // decode string as raw binary
                if (encoding === 'binary' || encoding === 'raw') {
                    // one byte per character
                    this.accommodate(bytes.length);
                    view = new Uint8Array(this.data.buffer, this.write);
                    this.write += this.binary.raw.decode(view);
                    return this;
                }

                // encode text as UTF-16 bytes
                if (encoding === 'utf16') {
                    // two bytes per character
                    this.accommodate(bytes.length * 2);
                    view = new Uint16Array(this.data.buffer, this.write);
                    this.write += this.text.utf16.encode(view);
                    return this;
                }

                throw new Error('Invalid encoding: ' + encoding);
            }

            throw Error('Invalid parameter: ' + bytes);
        };

        this.DataBuffer.prototype.putBuffer = function (buffer) {
            this.putBytes(buffer);
            buffer.clear();
            return this;
        };

        this.DataBuffer.prototype.putString = function (str) {
            return this.putBytes(str, 'utf16');
        };

        this.DataBuffer.prototype.putInt16 = function (i) {
            this.accommodate(2);
            this.data.setInt16(this.write, i);
            this.write += 2;
            return this;
        };

        this.DataBuffer.prototype.putInt24 = function (i) {
            this.accommodate(3);
            this.data.setInt16(this.write, i >> 8 & 0xFFFF);
            this.data.setInt8(this.write, i >> 16 & 0xFF);
            this.write += 3;
            return this;
        };

        this.DataBuffer.prototype.putInt32 = function (i) {
            this.accommodate(4);
            this.data.setInt32(this.write, i);
            this.write += 4;
            return this;
        };

        this.DataBuffer.prototype.putInt16Le = function (i) {
            this.accommodate(2);
            this.data.setInt16(this.write, i, true);
            this.write += 2;
            return this;
        };

        this.DataBuffer.prototype.putInt24Le = function (i) {
            this.accommodate(3);
            this.data.setInt8(this.write, i >> 16 & 0xFF);
            this.data.setInt16(this.write, i >> 8 & 0xFFFF, true);
            this.write += 3;
            return this;
        };

        this.DataBuffer.prototype.putInt32Le = function (i) {
            this.accommodate(4);
            this.data.setInt32(this.write, i, true);
            this.write += 4;
            return this;
        };

        this.DataBuffer.prototype.putInt = function (i, n) {
            this.accommodate(n / 8);
            do {
                n -= 8;
                this.data.setInt8(this.write++, (i >> n) & 0xFF);
            } while (n > 0);
            return this;
        };

        this.DataBuffer.prototype.putSignedInt = function (i, n) {
            this.accommodate(n / 8);
            if (i < 0) {
                i += 2 << (n - 1);
            }
            return this.putInt(i, n);
        };

        this.DataBuffer.prototype.getByte = function () {
            return this.data.getInt8(this.read++);
        };

        this.DataBuffer.prototype.getInt16 = function () {
            var rval = this.data.getInt16(this.read);
            this.read += 2;
            return rval;
        };

        this.DataBuffer.prototype.getInt24 = function () {
            var rval = (
            this.data.getInt16(this.read) << 8 ^
            this.data.getInt8(this.read + 2));
            this.read += 3;
            return rval;
        };

        this.DataBuffer.prototype.getInt32 = function () {
            var rval = this.data.getInt32(this.read);
            this.read += 4;
            return rval;
        };

        this.DataBuffer.prototype.getInt16Le = function () {
            var rval = this.data.getInt16(this.read, true);
            this.read += 2;
            return rval;
        };

        this.DataBuffer.prototype.getInt24Le = function () {
            var rval = (
            this.data.getInt8(this.read) ^
            this.data.getInt16(this.read + 1, true) << 8);
            this.read += 3;
            return rval;
        };

        this.DataBuffer.prototype.getInt32Le = function () {
            var rval = this.data.getInt32(this.read, true);
            this.read += 4;
            return rval;
        };

        this.DataBuffer.prototype.getInt = function (n) {
            var rval = 0;
            do {
                rval = (rval << 8) + this.data.getInt8(this.read++);
                n -= 8;
            } while (n > 0);
            return rval;
        };

        this.DataBuffer.prototype.getSignedInt = function (n) {
            var x = this.getInt(n);
            var max = 2 << (n - 2);
            if (x >= max) {
                x -= max << 1;
            }
            return x;
        };

        this.DataBuffer.prototype.getBytes = function (count) {
            // TODO: deprecate this method, it is poorly named and
            // this.toString('binary') replaces it
            // add a toTypedArray()/toArrayBuffer() function
            var rval;
            if (count) {
                // read count bytes
                count = Math.min(this.length(), count);
                rval = this.data.slice(this.read, this.read + count);
                this.read += count;
            } else if (count === 0) {
                rval = '';
            } else {
                // read all bytes, optimize to only copy when needed
                rval = (this.read === 0) ? this.data : this.data.slice(this.read);
                this.clear();
            }
            return rval;
        };

        this.DataBuffer.prototype.bytes = function (count) {
            // TODO: deprecate this method, it is poorly named, add "getString()"
            return (typeof(count) === 'undefined' ?
                this.data.slice(this.read) :
                this.data.slice(this.read, this.read + count));
        };

        this.DataBuffer.prototype.at = function (i) {
            return this.data.getUint8(this.read + i);
        };

        this.DataBuffer.prototype.setAt = function (i, b) {
            this.data.setUint8(i, b);
            return this;
        };

        this.DataBuffer.prototype.last = function () {
            return this.data.getUint8(this.write - 1);
        };

        this.DataBuffer.prototype.copy = function () {
            return new this.DataBuffer(this);
        };

        this.DataBuffer.prototype.compact = function () {
            if (this.read > 0) {
                var src = new Uint8Array(this.data.buffer, this.read);
                var dst = new Uint8Array(src.byteLength);
                dst.set(src);
                this.data = new DataView(dst);
                this.write -= this.read;
                this.read = 0;
            }
            return this;
        };

        this.DataBuffer.prototype.clear = function () {
            this.data = new DataView(new ArrayBuffer(0));
            this.read = this.write = 0;
            return this;
        };

        this.DataBuffer.prototype.truncate = function (count) {
            this.write = Math.max(0, this.length() - count);
            this.read = Math.min(this.read, this.write);
            return this;
        };

        this.DataBuffer.prototype.toHex = function () {
            var rval = '';
            for (var i = this.read; i < this.data.byteLength; ++i) {
                var b = this.data.getUint8(i);
                if (b < 16) {
                    rval += '0';
                }
                rval += b.toString(16);
            }
            return rval;
        };

        this.DataBuffer.prototype.toString = function (encoding) {
            var view = new Uint8Array(this.data, this.read, this.length());
            encoding = encoding || 'utf8';

            // encode to string
            if (encoding === 'binary' || encoding === 'raw') {
                return this.binary.raw.encode(view);
            }
            if (encoding === 'hex') {
                return this.binary.hex.encode(view);
            }
            if (encoding === 'base64') {
                return this.binary.base64.encode(view);
            }

            // decode to text
            if (encoding === 'utf8') {
                return this.text.utf8.decode(view);
            }
            if (encoding === 'utf16') {
                return this.text.utf16.decode(view);
            }

            throw new Error('Invalid encoding: ' + encoding);
        };

        this.createBuffer = function (input, encoding) {
            // TODO: deprecate, use new ByteBuffer() instead
            encoding = encoding || 'raw';
            if (input !== undefined && encoding === 'utf8') {
                input = this.encodeUtf8(input);
            }
            return new this.ByteBuffer(input);
        };

        this.fillString = function (c, n) {
            var s = '';
            while (n > 0) {
                if (n & 1) {
                    s += c;
                }
                n >>>= 1;
                if (n > 0) {
                    c += c;
                }
            }
            return s;
        };

        this.xorBytes = function (s1, s2, n) {
            var s3 = '';
            var b = '';
            var t = '';
            var i = 0;
            var c = 0;
            for (; n > 0; --n, ++i) {
                b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
                if (c >= 10) {
                    s3 += t;
                    t = '';
                    c = 0;
                }
                t += String.fromCharCode(b);
                ++c;
            }
            s3 += t;
            return s3;
        };

        this.hexToBytes = function (hex) {
            // TODO: deprecate: "Deprecated. Use this.binary.hex.decode instead."
            var rval = '';
            var i = 0;
            if (hex.length & 1 == 1) {
                hex = hex.substr(1, hex.length);
            }

            // convert 2 characters (1 byte) at a time
            for (; i < hex.length; i += 2) {
                rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
            }
            return rval;
        };

        this.bytesToHex = function (bytes) {
            // TODO: deprecate: "Deprecated. Use this.binary.hex.encode instead."
            return this.createBuffer(bytes).toHex();
        };

        this.int32ToBytes = function (i) {
            return (
            String.fromCharCode(i >> 24 & 0xFF) +
            String.fromCharCode(i >> 16 & 0xFF) +
            String.fromCharCode(i >> 8 & 0xFF) +
            String.fromCharCode(i & 0xFF));
        };

        // base64 characters, reverse mapping
        var _base64 =
            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        var _base64Idx = [
            /*43 -43 = 0*/
            /*'+',  1,  2,  3,'/' */
            62, -1, -1, -1, 63,

            /*'0','1','2','3','4','5','6','7','8','9' */
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61,

            /*15, 16, 17,'=', 19, 20, 21 */
            -1, -1, -1, 64, -1, -1, -1,

            /*65 - 43 = 22*/
            /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,

            /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
            13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,

            /*91 - 43 = 48 */
            /*48, 49, 50, 51, 52, 53 */
            -1, -1, -1, -1, -1, -1,

            /*97 - 43 = 54*/
            /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
            26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,

            /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
            39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
        ];

        this.encode64 = function (input, maxline) {
            var line = '';
            var output = '';
            var chr1, chr2, chr3;
            var i = 0;
            while (i < input.length) {
                chr1 = input.charCodeAt(i++);
                chr2 = input.charCodeAt(i++);
                chr3 = input.charCodeAt(i++);

                // encode 4 character group
                line += _base64.charAt(chr1 >> 2);
                line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));
                if (isNaN(chr2)) {
                    line += '==';
                } else {
                    line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));
                    line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);
                }

                if (maxline && line.length > maxline) {
                    output += line.substr(0, maxline) + '\r\n';
                    line = line.substr(maxline);
                }
            }
            output += line;
            return output;
        };

        this.decode64 = function (input) {
            // remove all non-base64 characters
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

            var output = '';
            var enc1, enc2, enc3, enc4;
            var i = 0;

            while (i < input.length) {
                enc1 = _base64Idx[input.charCodeAt(i++) - 43];
                enc2 = _base64Idx[input.charCodeAt(i++) - 43];
                enc3 = _base64Idx[input.charCodeAt(i++) - 43];
                enc4 = _base64Idx[input.charCodeAt(i++) - 43];

                output += String.fromCharCode((enc1 << 2) | (enc2 >> 4));
                if (enc3 !== 64) {
                    // decoded at least 2 bytes
                    output += String.fromCharCode(((enc2 & 15) << 4) | (enc3 >> 2));
                    if (enc4 !== 64) {
                        // decoded 3 bytes
                        output += String.fromCharCode(((enc3 & 3) << 6) | enc4);
                    }
                }
            }

            return output;
        };

        this.encodeUtf8 = function (str) {
            return unescape(encodeURIComponent(str));
        };

        this.decodeUtf8 = function (str) {
            return decodeURIComponent(escape(str));
        };

        this.binary = {
            raw: {},
            hex: {},
            base64: {}
        };

        this.binary.raw.encode = function (bytes) {
            return String.fromCharCode.apply(null, bytes);
        };

        this.binary.raw.decode = function (str, output, offset) {
            var out = output;
            if (!out) {
                out = new Uint8Array(str.length);
            }
            offset = offset || 0;
            var j = offset;
            for (var i = 0; i < str.length; ++i) {
                out[j++] = str.charCodeAt(i);
            }
            return output ? (j - offset) : out;
        };

        this.binary.hex.encode = this.bytesToHex;

        this.binary.hex.decode = function (hex, output, offset) {
            var out = output;
            if (!out) {
                out = new Uint8Array(Math.ceil(hex.length / 2));
            }
            offset = offset || 0;
            var i = 0, j = offset;
            if (hex.length & 1) {
                // odd number of characters, convert first character alone
                i = 1;
                out[j++] = parseInt(hex[0], 16);
            }
            // convert 2 characters (1 byte) at a time
            for (; i < hex.length; i += 2) {
                out[j++] = parseInt(hex.substr(i, 2), 16);
            }
            return output ? (j - offset) : out;
        };

        this.binary.base64.encode = function (input, maxline) {
            var line = '';
            var output = '';
            var chr1, chr2, chr3;
            var i = 0;
            while (i < input.byteLength) {
                chr1 = input[i++];
                chr2 = input[i++];
                chr3 = input[i++];

                // encode 4 character group
                line += _base64.charAt(chr1 >> 2);
                line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));
                if (isNaN(chr2)) {
                    line += '==';
                } else {
                    line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));
                    line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);
                }

                if (maxline && line.length > maxline) {
                    output += line.substr(0, maxline) + '\r\n';
                    line = line.substr(maxline);
                }
            }
            output += line;
            return output;
        };

        this.binary.base64.decode = function (input, output, offset) {
            var out = output;
            if (!out) {
                out = new Uint8Array(Math.ceil(input.length / 4) * 3);
            }

            // remove all non-base64 characters
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

            offset = offset || 0;
            var enc1, enc2, enc3, enc4;
            var i = 0, j = offset;

            while (i < input.length) {
                enc1 = _base64Idx[input.charCodeAt(i++) - 43];
                enc2 = _base64Idx[input.charCodeAt(i++) - 43];
                enc3 = _base64Idx[input.charCodeAt(i++) - 43];
                enc4 = _base64Idx[input.charCodeAt(i++) - 43];

                out[j++] = (enc1 << 2) | (enc2 >> 4);
                if (enc3 !== 64) {
                    // decoded at least 2 bytes
                    out[j++] = ((enc2 & 15) << 4) | (enc3 >> 2);
                    if (enc4 !== 64) {
                        // decoded 3 bytes
                        out[j++] = ((enc3 & 3) << 6) | enc4;
                    }
                }
            }

            // make sure result is the exact decoded length
            return output ?
                (j - offset) :
                out.subarray(0, j);
        };

        this.text = {
            utf8: {},
            utf16: {}
        };

        this.text.utf8.encode = function (str, output, offset) {
            str = this.encodeUtf8(str);
            var out = output;
            if (!out) {
                out = new Uint8Array(str.length);
            }
            offset = offset || 0;
            var j = offset;
            for (var i = 0; i < str.length; ++i) {
                out[j++] = str.charCodeAt(i);
            }
            return output ? (j - offset) : out;
        };

        this.text.utf8.decode = function (bytes) {
            return this.decodeUtf8(String.fromCharCode.apply(null, bytes));
        };

        this.text.utf16.encode = function (str, output, offset) {
            var out = output;
            if (!out) {
                out = new Uint8Array(str.length);
            }
            var view = new Uint16Array(out);
            offset = offset || 0;
            var j = offset;
            var k = offset;
            for (var i = 0; i < str.length; ++i) {
                view[k++] = str.charCodeAt(i);
                j += 2;
            }
            return output ? (j - offset) : out;
        };

        this.text.utf16.decode = function (bytes) {
            return String.fromCharCode.apply(null, new Uint16Array(bytes));
        };

        this.deflate = function (api, bytes, raw) {
            bytes = this.decode64(api.deflate(this.encode64(bytes)).rval);

            // strip zlib header and trailer if necessary
            if (raw) {
                // zlib header is 2 bytes (CMF,FLG) where FLG indicates that
                // there is a 4-byte DICT (alder-32) block before the data if
                // its 5th bit is set
                var start = 2;
                var flg = bytes.charCodeAt(1);
                if (flg & 0x20) {
                    start = 6;
                }
                // zlib trailer is 4 bytes of adler-32
                bytes = bytes.substring(start, bytes.length - 4);
            }

            return bytes;
        };

        this.inflate = function (api, bytes, raw) {
            // TODO: add zlib header and trailer if necessary/possible
            var rval = api.inflate(this.encode64(bytes)).rval;
            return (rval === null) ? null : this.decode64(rval);
        };

        var _setStorageObject = function (api, id, obj) {
            if (!api) {
                throw new Error('WebStorage not available.');
            }

            var rval;
            if (obj === null) {
                rval = api.removeItem(id);
            } else {
                // json-encode and base64-encode object
                obj = this.encode64(JSON.stringify(obj));
                rval = api.setItem(id, obj);
            }

            // handle potential flash error
            if (typeof(rval) !== 'undefined' && rval.rval !== true) {
                var error = new Error(rval.error.message);
                error.id = rval.error.id;
                error.name = rval.error.name;
                throw error;
            }
        };

        var _getStorageObject = function (api, id) {
            if (!api) {
                throw new Error('WebStorage not available.');
            }
            // get the existing entry
            var rval = api.getItem(id);

            // flash returns item wrapped in an object, handle special case
            if (api.init) {
                if (rval.rval === null) {
                    if (rval.error) {
                        var error = new Error(rval.error.message);
                        error.id = rval.error.id;
                        error.name = rval.error.name;
                        throw error;
                    }
                    // no error, but also no item
                    rval = null;
                } else {
                    rval = rval.rval;
                }
            }

            // handle decoding
            if (rval !== null) {
                // base64-decode and json-decode data
                rval = JSON.parse(this.decode64(rval));
            }

            return rval;
        };

        var _setItem = function (api, id, key, data) {
            // get storage object
            var obj = _getStorageObject(api, id);
            if (obj === null) {
                // create a new storage object
                obj = {};
            }
            // update key
            obj[key] = data;

            // set storage object
            _setStorageObject(api, id, obj);
        };

        var _getItem = function (api, id, key) {
            // get storage object
            var rval = _getStorageObject(api, id);
            if (rval !== null) {
                // return data at key
                rval = (key in rval) ? rval[key] : null;
            }

            return rval;
        };

        var _removeItem = function (api, id, key) {
            // get storage object
            var obj = _getStorageObject(api, id);
            if (obj !== null && key in obj) {
                // remove key
                delete obj[key];

                // see if entry has no keys remaining
                var empty = true;
                for (var prop in obj) {
                    empty = false;
                    break;
                }
                if (empty) {
                    // remove entry entirely if no keys are left
                    obj = null;
                }

                // set storage object
                _setStorageObject(api, id, obj);
            }
        };

        var _clearItems = function (api, id) {
            _setStorageObject(api, id, null);
        };

        var _callStorageFunction = function (func, args, location) {
            var rval = null;

            // default storage types
            if (typeof(location) === 'undefined') {
                location = ['web', 'flash'];
            }

            // apply storage types in order of preference
            var type;
            var done = false;
            var exception = null;
            for (var idx in location) {
                type = location[idx];
                try {
                    if (type === 'flash' || type === 'both') {
                        if (args[0] === null) {
                            throw new Error('Flash local storage not available.');
                        }
                        rval = func.apply(this, args);
                        done = (type === 'flash');
                    }
                    if (type === 'web' || type === 'both') {
                        args[0] = localStorage;
                        rval = func.apply(this, args);
                        done = true;
                    }
                } catch (ex) {
                    exception = ex;
                }
                if (done) {
                    break;
                }
            }

            if (!done) {
                throw exception;
            }

            return rval;
        };

        this.setItem = function (api, id, key, data, location) {
            _callStorageFunction(_setItem, arguments, location);
        };

        this.getItem = function (api, id, key, location) {
            return _callStorageFunction(_getItem, arguments, location);
        };

        this.removeItem = function (api, id, key, location) {
            _callStorageFunction(_removeItem, arguments, location);
        };

        var _queryVariables = null;

        this.getQueryVariables = function (query) {
            var parse = function (q) {
                var rval = {};
                var kvpairs = q.split('&');
                for (var i = 0; i < kvpairs.length; i++) {
                    var pos = kvpairs[i].indexOf('=');
                    var key;
                    var val;
                    if (pos > 0) {
                        key = kvpairs[i].substring(0, pos);
                        val = kvpairs[i].substring(pos + 1);
                    } else {
                        key = kvpairs[i];
                        val = null;
                    }
                    if (!(key in rval)) {
                        rval[key] = [];
                    }
                    // disallow overriding object prototype keys
                    if (!(key in Object.prototype) && val !== null) {
                        rval[key].push(unescape(val));
                    }
                }
                return rval;
            };

            var rval;
            if (typeof(query) === 'undefined') {
                // set cached variables if needed
                if (_queryVariables === null) {
                    if (typeof(window) !== 'undefined' && window.location && window.location.search) {
                        // parse window search query
                        _queryVariables = parse(window.location.search.substring(1));
                    } else {
                        // no query variables available
                        _queryVariables = {};
                    }
                }
                rval = _queryVariables;
            } else {
                // parse given query
                rval = parse(query);
            }
            return rval;
        };

        this.parseFragment = function (fragment) {
            // default to whole fragment
            var fp = fragment;
            var fq = '';
            // split into path and query if possible at the first '?'
            var pos = fragment.indexOf('?');
            if (pos > 0) {
                fp = fragment.substring(0, pos);
                fq = fragment.substring(pos + 1);
            }
            // split path based on '/' and ignore first element if empty
            var path = fp.split('/');
            if (path.length > 0 && path[0] === '') {
                path.shift();
            }
            // convert query into object
            var query = (fq === '') ? {} : this.getQueryVariables(fq);

            return {
                pathString: fp,
                queryString: fq,
                path: path,
                query: query
            };
        };

        this.formatNumber = function (number, decimals, dec_point, thousands_sep) {
            var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
            var d = dec_point === undefined ? ',' : dec_point;
            var t = thousands_sep === undefined ?
                '.' : thousands_sep, s = n < 0 ? '-' : '';
            var i = parseInt((n = Math.abs(+n || 0).toFixed(c)), 10) + '';
            var j = (i.length > 3) ? i.length % 3 : 0;
            return s + (j ? i.substr(0, j) + t : '') +
                i.substr(j).replace(/(\d{3})(?=\d)/g, '$1' + t) +
                (c ? d + Math.abs(n - i).toFixed(c).slice(2) : '');
        };
    }
})();